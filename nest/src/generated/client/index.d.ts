
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductAdjustment
 * 
 */
export type ProductAdjustment = $Result.DefaultSelection<Prisma.$ProductAdjustmentPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model PaymentMapping
 * 
 */
export type PaymentMapping = $Result.DefaultSelection<Prisma.$PaymentMappingPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Outlet
 * 
 */
export type Outlet = $Result.DefaultSelection<Prisma.$OutletPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model TenantAddon
 * 
 */
export type TenantAddon = $Result.DefaultSelection<Prisma.$TenantAddonPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SubscriptionHistory
 * 
 */
export type SubscriptionHistory = $Result.DefaultSelection<Prisma.$SubscriptionHistoryPayload>
/**
 * Model ReceiptTemplate
 * 
 */
export type ReceiptTemplate = $Result.DefaultSelection<Prisma.$ReceiptTemplatePayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model StockTransfer
 * 
 */
export type StockTransfer = $Result.DefaultSelection<Prisma.$StockTransferPayload>
/**
 * Model StockTransferItem
 * 
 */
export type StockTransferItem = $Result.DefaultSelection<Prisma.$StockTransferItemPayload>
/**
 * Model StockValuation
 * 
 */
export type StockValuation = $Result.DefaultSelection<Prisma.$StockValuationPayload>
/**
 * Model BackupLog
 * 
 */
export type BackupLog = $Result.DefaultSelection<Prisma.$BackupLogPayload>
/**
 * Model StoreShift
 * 
 */
export type StoreShift = $Result.DefaultSelection<Prisma.$StoreShiftPayload>
/**
 * Model CashShift
 * 
 */
export type CashShift = $Result.DefaultSelection<Prisma.$CashShiftPayload>
/**
 * Model DeviceToken
 * 
 */
export type DeviceToken = $Result.DefaultSelection<Prisma.$DeviceTokenPayload>
/**
 * Model CourierConfig
 * 
 */
export type CourierConfig = $Result.DefaultSelection<Prisma.$CourierConfigPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model ContactSubmission
 * 
 */
export type ContactSubmission = $Result.DefaultSelection<Prisma.$ContactSubmissionPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN_TENANT: 'ADMIN_TENANT',
  SUPERVISOR: 'SUPERVISOR',
  CASHIER: 'CASHIER',
  KITCHEN: 'KITCHEN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OrderStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  QRIS: 'QRIS',
  CARD: 'CARD',
  E_WALLET: 'E_WALLET',
  BANK_TRANSFER: 'BANK_TRANSFER',
  SHOPEEPAY: 'SHOPEEPAY',
  DANA: 'DANA'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productAdjustment`: Exposes CRUD operations for the **ProductAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAdjustments
    * const productAdjustments = await prisma.productAdjustment.findMany()
    * ```
    */
  get productAdjustment(): Prisma.ProductAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMapping`: Exposes CRUD operations for the **PaymentMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMappings
    * const paymentMappings = await prisma.paymentMapping.findMany()
    * ```
    */
  get paymentMapping(): Prisma.PaymentMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outlet`: Exposes CRUD operations for the **Outlet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outlets
    * const outlets = await prisma.outlet.findMany()
    * ```
    */
  get outlet(): Prisma.OutletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantAddon`: Exposes CRUD operations for the **TenantAddon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantAddons
    * const tenantAddons = await prisma.tenantAddon.findMany()
    * ```
    */
  get tenantAddon(): Prisma.TenantAddonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionHistory`: Exposes CRUD operations for the **SubscriptionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionHistories
    * const subscriptionHistories = await prisma.subscriptionHistory.findMany()
    * ```
    */
  get subscriptionHistory(): Prisma.SubscriptionHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receiptTemplate`: Exposes CRUD operations for the **ReceiptTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceiptTemplates
    * const receiptTemplates = await prisma.receiptTemplate.findMany()
    * ```
    */
  get receiptTemplate(): Prisma.ReceiptTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransfer`: Exposes CRUD operations for the **StockTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransfers
    * const stockTransfers = await prisma.stockTransfer.findMany()
    * ```
    */
  get stockTransfer(): Prisma.StockTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransferItem`: Exposes CRUD operations for the **StockTransferItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransferItems
    * const stockTransferItems = await prisma.stockTransferItem.findMany()
    * ```
    */
  get stockTransferItem(): Prisma.StockTransferItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockValuation`: Exposes CRUD operations for the **StockValuation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockValuations
    * const stockValuations = await prisma.stockValuation.findMany()
    * ```
    */
  get stockValuation(): Prisma.StockValuationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.backupLog`: Exposes CRUD operations for the **BackupLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackupLogs
    * const backupLogs = await prisma.backupLog.findMany()
    * ```
    */
  get backupLog(): Prisma.BackupLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storeShift`: Exposes CRUD operations for the **StoreShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreShifts
    * const storeShifts = await prisma.storeShift.findMany()
    * ```
    */
  get storeShift(): Prisma.StoreShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashShift`: Exposes CRUD operations for the **CashShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashShifts
    * const cashShifts = await prisma.cashShift.findMany()
    * ```
    */
  get cashShift(): Prisma.CashShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceToken`: Exposes CRUD operations for the **DeviceToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTokens
    * const deviceTokens = await prisma.deviceToken.findMany()
    * ```
    */
  get deviceToken(): Prisma.DeviceTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courierConfig`: Exposes CRUD operations for the **CourierConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourierConfigs
    * const courierConfigs = await prisma.courierConfig.findMany()
    * ```
    */
  get courierConfig(): Prisma.CourierConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactSubmission`: Exposes CRUD operations for the **ContactSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactSubmissions
    * const contactSubmissions = await prisma.contactSubmission.findMany()
    * ```
    */
  get contactSubmission(): Prisma.ContactSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Product: 'Product',
    ProductAdjustment: 'ProductAdjustment',
    Order: 'Order',
    OrderItem: 'OrderItem',
    PaymentMapping: 'PaymentMapping',
    Transaction: 'Transaction',
    Customer: 'Customer',
    Member: 'Member',
    Employee: 'Employee',
    Outlet: 'Outlet',
    Report: 'Report',
    TenantAddon: 'TenantAddon',
    Subscription: 'Subscription',
    SubscriptionHistory: 'SubscriptionHistory',
    ReceiptTemplate: 'ReceiptTemplate',
    Discount: 'Discount',
    AuditLog: 'AuditLog',
    Webhook: 'Webhook',
    WebhookDelivery: 'WebhookDelivery',
    Supplier: 'Supplier',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    StockTransfer: 'StockTransfer',
    StockTransferItem: 'StockTransferItem',
    StockValuation: 'StockValuation',
    BackupLog: 'BackupLog',
    StoreShift: 'StoreShift',
    CashShift: 'CashShift',
    DeviceToken: 'DeviceToken',
    CourierConfig: 'CourierConfig',
    SystemSettings: 'SystemSettings',
    ContactSubmission: 'ContactSubmission',
    SupportTicket: 'SupportTicket'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "product" | "productAdjustment" | "order" | "orderItem" | "paymentMapping" | "transaction" | "customer" | "member" | "employee" | "outlet" | "report" | "tenantAddon" | "subscription" | "subscriptionHistory" | "receiptTemplate" | "discount" | "auditLog" | "webhook" | "webhookDelivery" | "supplier" | "purchaseOrder" | "purchaseOrderItem" | "stockTransfer" | "stockTransferItem" | "stockValuation" | "backupLog" | "storeShift" | "cashShift" | "deviceToken" | "courierConfig" | "systemSettings" | "contactSubmission" | "supportTicket"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductAdjustment: {
        payload: Prisma.$ProductAdjustmentPayload<ExtArgs>
        fields: Prisma.ProductAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.ProductAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>
          }
          findMany: {
            args: Prisma.ProductAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>[]
          }
          create: {
            args: Prisma.ProductAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>
          }
          createMany: {
            args: Prisma.ProductAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.ProductAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>
          }
          update: {
            args: Prisma.ProductAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.ProductAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductAdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.ProductAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.ProductAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductAdjustment>
          }
          groupBy: {
            args: Prisma.ProductAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<ProductAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      PaymentMapping: {
        payload: Prisma.$PaymentMappingPayload<ExtArgs>
        fields: Prisma.PaymentMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>
          }
          findFirst: {
            args: Prisma.PaymentMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>
          }
          findMany: {
            args: Prisma.PaymentMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>[]
          }
          create: {
            args: Prisma.PaymentMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>
          }
          createMany: {
            args: Prisma.PaymentMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>[]
          }
          delete: {
            args: Prisma.PaymentMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>
          }
          update: {
            args: Prisma.PaymentMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMappingPayload>
          }
          aggregate: {
            args: Prisma.PaymentMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMapping>
          }
          groupBy: {
            args: Prisma.PaymentMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMappingCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMappingCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Outlet: {
        payload: Prisma.$OutletPayload<ExtArgs>
        fields: Prisma.OutletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          findFirst: {
            args: Prisma.OutletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          findMany: {
            args: Prisma.OutletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          create: {
            args: Prisma.OutletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          createMany: {
            args: Prisma.OutletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          delete: {
            args: Prisma.OutletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          update: {
            args: Prisma.OutletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          deleteMany: {
            args: Prisma.OutletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>[]
          }
          upsert: {
            args: Prisma.OutletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutletPayload>
          }
          aggregate: {
            args: Prisma.OutletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutlet>
          }
          groupBy: {
            args: Prisma.OutletGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutletGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutletCountArgs<ExtArgs>
            result: $Utils.Optional<OutletCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      TenantAddon: {
        payload: Prisma.$TenantAddonPayload<ExtArgs>
        fields: Prisma.TenantAddonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantAddonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantAddonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>
          }
          findFirst: {
            args: Prisma.TenantAddonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantAddonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>
          }
          findMany: {
            args: Prisma.TenantAddonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>[]
          }
          create: {
            args: Prisma.TenantAddonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>
          }
          createMany: {
            args: Prisma.TenantAddonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantAddonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>[]
          }
          delete: {
            args: Prisma.TenantAddonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>
          }
          update: {
            args: Prisma.TenantAddonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>
          }
          deleteMany: {
            args: Prisma.TenantAddonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantAddonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantAddonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>[]
          }
          upsert: {
            args: Prisma.TenantAddonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantAddonPayload>
          }
          aggregate: {
            args: Prisma.TenantAddonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantAddon>
          }
          groupBy: {
            args: Prisma.TenantAddonGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantAddonGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantAddonCountArgs<ExtArgs>
            result: $Utils.Optional<TenantAddonCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionHistory: {
        payload: Prisma.$SubscriptionHistoryPayload<ExtArgs>
        fields: Prisma.SubscriptionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          findMany: {
            args: Prisma.SubscriptionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>[]
          }
          create: {
            args: Prisma.SubscriptionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          createMany: {
            args: Prisma.SubscriptionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          update: {
            args: Prisma.SubscriptionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionHistoryPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionHistory>
          }
          groupBy: {
            args: Prisma.SubscriptionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionHistoryCountAggregateOutputType> | number
          }
        }
      }
      ReceiptTemplate: {
        payload: Prisma.$ReceiptTemplatePayload<ExtArgs>
        fields: Prisma.ReceiptTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>
          }
          findFirst: {
            args: Prisma.ReceiptTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>
          }
          findMany: {
            args: Prisma.ReceiptTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>[]
          }
          create: {
            args: Prisma.ReceiptTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>
          }
          createMany: {
            args: Prisma.ReceiptTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>[]
          }
          delete: {
            args: Prisma.ReceiptTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>
          }
          update: {
            args: Prisma.ReceiptTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ReceiptTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceiptTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ReceiptTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptTemplatePayload>
          }
          aggregate: {
            args: Prisma.ReceiptTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceiptTemplate>
          }
          groupBy: {
            args: Prisma.ReceiptTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptTemplateCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      StockTransfer: {
        payload: Prisma.$StockTransferPayload<ExtArgs>
        fields: Prisma.StockTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          findFirst: {
            args: Prisma.StockTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          findMany: {
            args: Prisma.StockTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          create: {
            args: Prisma.StockTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          createMany: {
            args: Prisma.StockTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          delete: {
            args: Prisma.StockTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          update: {
            args: Prisma.StockTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          deleteMany: {
            args: Prisma.StockTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          upsert: {
            args: Prisma.StockTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          aggregate: {
            args: Prisma.StockTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransfer>
          }
          groupBy: {
            args: Prisma.StockTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransferCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransferCountAggregateOutputType> | number
          }
        }
      }
      StockTransferItem: {
        payload: Prisma.$StockTransferItemPayload<ExtArgs>
        fields: Prisma.StockTransferItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransferItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransferItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>
          }
          findFirst: {
            args: Prisma.StockTransferItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransferItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>
          }
          findMany: {
            args: Prisma.StockTransferItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>[]
          }
          create: {
            args: Prisma.StockTransferItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>
          }
          createMany: {
            args: Prisma.StockTransferItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransferItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>[]
          }
          delete: {
            args: Prisma.StockTransferItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>
          }
          update: {
            args: Prisma.StockTransferItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>
          }
          deleteMany: {
            args: Prisma.StockTransferItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransferItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransferItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>[]
          }
          upsert: {
            args: Prisma.StockTransferItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferItemPayload>
          }
          aggregate: {
            args: Prisma.StockTransferItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransferItem>
          }
          groupBy: {
            args: Prisma.StockTransferItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransferItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransferItemCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransferItemCountAggregateOutputType> | number
          }
        }
      }
      StockValuation: {
        payload: Prisma.$StockValuationPayload<ExtArgs>
        fields: Prisma.StockValuationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockValuationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockValuationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>
          }
          findFirst: {
            args: Prisma.StockValuationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockValuationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>
          }
          findMany: {
            args: Prisma.StockValuationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>[]
          }
          create: {
            args: Prisma.StockValuationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>
          }
          createMany: {
            args: Prisma.StockValuationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockValuationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>[]
          }
          delete: {
            args: Prisma.StockValuationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>
          }
          update: {
            args: Prisma.StockValuationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>
          }
          deleteMany: {
            args: Prisma.StockValuationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockValuationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockValuationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>[]
          }
          upsert: {
            args: Prisma.StockValuationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockValuationPayload>
          }
          aggregate: {
            args: Prisma.StockValuationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockValuation>
          }
          groupBy: {
            args: Prisma.StockValuationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockValuationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockValuationCountArgs<ExtArgs>
            result: $Utils.Optional<StockValuationCountAggregateOutputType> | number
          }
        }
      }
      BackupLog: {
        payload: Prisma.$BackupLogPayload<ExtArgs>
        fields: Prisma.BackupLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackupLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackupLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          findFirst: {
            args: Prisma.BackupLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackupLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          findMany: {
            args: Prisma.BackupLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>[]
          }
          create: {
            args: Prisma.BackupLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          createMany: {
            args: Prisma.BackupLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackupLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>[]
          }
          delete: {
            args: Prisma.BackupLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          update: {
            args: Prisma.BackupLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          deleteMany: {
            args: Prisma.BackupLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackupLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BackupLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>[]
          }
          upsert: {
            args: Prisma.BackupLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupLogPayload>
          }
          aggregate: {
            args: Prisma.BackupLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackupLog>
          }
          groupBy: {
            args: Prisma.BackupLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackupLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackupLogCountArgs<ExtArgs>
            result: $Utils.Optional<BackupLogCountAggregateOutputType> | number
          }
        }
      }
      StoreShift: {
        payload: Prisma.$StoreShiftPayload<ExtArgs>
        fields: Prisma.StoreShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>
          }
          findFirst: {
            args: Prisma.StoreShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>
          }
          findMany: {
            args: Prisma.StoreShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>[]
          }
          create: {
            args: Prisma.StoreShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>
          }
          createMany: {
            args: Prisma.StoreShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>[]
          }
          delete: {
            args: Prisma.StoreShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>
          }
          update: {
            args: Prisma.StoreShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>
          }
          deleteMany: {
            args: Prisma.StoreShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>[]
          }
          upsert: {
            args: Prisma.StoreShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreShiftPayload>
          }
          aggregate: {
            args: Prisma.StoreShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreShift>
          }
          groupBy: {
            args: Prisma.StoreShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreShiftCountArgs<ExtArgs>
            result: $Utils.Optional<StoreShiftCountAggregateOutputType> | number
          }
        }
      }
      CashShift: {
        payload: Prisma.$CashShiftPayload<ExtArgs>
        fields: Prisma.CashShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>
          }
          findFirst: {
            args: Prisma.CashShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>
          }
          findMany: {
            args: Prisma.CashShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>[]
          }
          create: {
            args: Prisma.CashShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>
          }
          createMany: {
            args: Prisma.CashShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>[]
          }
          delete: {
            args: Prisma.CashShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>
          }
          update: {
            args: Prisma.CashShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>
          }
          deleteMany: {
            args: Prisma.CashShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>[]
          }
          upsert: {
            args: Prisma.CashShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashShiftPayload>
          }
          aggregate: {
            args: Prisma.CashShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashShift>
          }
          groupBy: {
            args: Prisma.CashShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashShiftCountArgs<ExtArgs>
            result: $Utils.Optional<CashShiftCountAggregateOutputType> | number
          }
        }
      }
      DeviceToken: {
        payload: Prisma.$DeviceTokenPayload<ExtArgs>
        fields: Prisma.DeviceTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findFirst: {
            args: Prisma.DeviceTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findMany: {
            args: Prisma.DeviceTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          create: {
            args: Prisma.DeviceTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          createMany: {
            args: Prisma.DeviceTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          delete: {
            args: Prisma.DeviceTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          update: {
            args: Prisma.DeviceTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          aggregate: {
            args: Prisma.DeviceTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceToken>
          }
          groupBy: {
            args: Prisma.DeviceTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTokenCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenCountAggregateOutputType> | number
          }
        }
      }
      CourierConfig: {
        payload: Prisma.$CourierConfigPayload<ExtArgs>
        fields: Prisma.CourierConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourierConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourierConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>
          }
          findFirst: {
            args: Prisma.CourierConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourierConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>
          }
          findMany: {
            args: Prisma.CourierConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>[]
          }
          create: {
            args: Prisma.CourierConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>
          }
          createMany: {
            args: Prisma.CourierConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourierConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>[]
          }
          delete: {
            args: Prisma.CourierConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>
          }
          update: {
            args: Prisma.CourierConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>
          }
          deleteMany: {
            args: Prisma.CourierConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourierConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourierConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>[]
          }
          upsert: {
            args: Prisma.CourierConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierConfigPayload>
          }
          aggregate: {
            args: Prisma.CourierConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourierConfig>
          }
          groupBy: {
            args: Prisma.CourierConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourierConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourierConfigCountArgs<ExtArgs>
            result: $Utils.Optional<CourierConfigCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      ContactSubmission: {
        payload: Prisma.$ContactSubmissionPayload<ExtArgs>
        fields: Prisma.ContactSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ContactSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findMany: {
            args: Prisma.ContactSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          create: {
            args: Prisma.ContactSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          createMany: {
            args: Prisma.ContactSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ContactSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          update: {
            args: Prisma.ContactSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ContactSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ContactSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ContactSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactSubmission>
          }
          groupBy: {
            args: Prisma.ContactSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    product?: ProductOmit
    productAdjustment?: ProductAdjustmentOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    paymentMapping?: PaymentMappingOmit
    transaction?: TransactionOmit
    customer?: CustomerOmit
    member?: MemberOmit
    employee?: EmployeeOmit
    outlet?: OutletOmit
    report?: ReportOmit
    tenantAddon?: TenantAddonOmit
    subscription?: SubscriptionOmit
    subscriptionHistory?: SubscriptionHistoryOmit
    receiptTemplate?: ReceiptTemplateOmit
    discount?: DiscountOmit
    auditLog?: AuditLogOmit
    webhook?: WebhookOmit
    webhookDelivery?: WebhookDeliveryOmit
    supplier?: SupplierOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderItem?: PurchaseOrderItemOmit
    stockTransfer?: StockTransferOmit
    stockTransferItem?: StockTransferItemOmit
    stockValuation?: StockValuationOmit
    backupLog?: BackupLogOmit
    storeShift?: StoreShiftOmit
    cashShift?: CashShiftOmit
    deviceToken?: DeviceTokenOmit
    courierConfig?: CourierConfigOmit
    systemSettings?: SystemSettingsOmit
    contactSubmission?: ContactSubmissionOmit
    supportTicket?: SupportTicketOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    products: number
    orders: number
    transactions: number
    customers: number
    members: number
    employees: number
    outlets: number
    reports: number
    addons: number
    subscriptions: number
    subscriptionHistory: number
    receiptTemplates: number
    discounts: number
    paymentMappings: number
    productAdjustments: number
    auditLogs: number
    webhooks: number
    suppliers: number
    purchaseOrders: number
    stockTransfers: number
    stockValuations: number
    backupLogs: number
    cashShifts: number
    storeShifts: number
    courierConfigs: number
    supportTickets: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    products?: boolean | TenantCountOutputTypeCountProductsArgs
    orders?: boolean | TenantCountOutputTypeCountOrdersArgs
    transactions?: boolean | TenantCountOutputTypeCountTransactionsArgs
    customers?: boolean | TenantCountOutputTypeCountCustomersArgs
    members?: boolean | TenantCountOutputTypeCountMembersArgs
    employees?: boolean | TenantCountOutputTypeCountEmployeesArgs
    outlets?: boolean | TenantCountOutputTypeCountOutletsArgs
    reports?: boolean | TenantCountOutputTypeCountReportsArgs
    addons?: boolean | TenantCountOutputTypeCountAddonsArgs
    subscriptions?: boolean | TenantCountOutputTypeCountSubscriptionsArgs
    subscriptionHistory?: boolean | TenantCountOutputTypeCountSubscriptionHistoryArgs
    receiptTemplates?: boolean | TenantCountOutputTypeCountReceiptTemplatesArgs
    discounts?: boolean | TenantCountOutputTypeCountDiscountsArgs
    paymentMappings?: boolean | TenantCountOutputTypeCountPaymentMappingsArgs
    productAdjustments?: boolean | TenantCountOutputTypeCountProductAdjustmentsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    webhooks?: boolean | TenantCountOutputTypeCountWebhooksArgs
    suppliers?: boolean | TenantCountOutputTypeCountSuppliersArgs
    purchaseOrders?: boolean | TenantCountOutputTypeCountPurchaseOrdersArgs
    stockTransfers?: boolean | TenantCountOutputTypeCountStockTransfersArgs
    stockValuations?: boolean | TenantCountOutputTypeCountStockValuationsArgs
    backupLogs?: boolean | TenantCountOutputTypeCountBackupLogsArgs
    cashShifts?: boolean | TenantCountOutputTypeCountCashShiftsArgs
    storeShifts?: boolean | TenantCountOutputTypeCountStoreShiftsArgs
    courierConfigs?: boolean | TenantCountOutputTypeCountCourierConfigsArgs
    supportTickets?: boolean | TenantCountOutputTypeCountSupportTicketsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOutletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAddonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantAddonWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSubscriptionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountReceiptTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMappingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProductAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAdjustmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStockTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStockValuationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockValuationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBackupLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShiftWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStoreShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreShiftWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCourierConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierConfigWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    transactions: number
    cashShifts: number
    productAdjustments: number
    auditLogs: number
    storeShifts: number
    deviceTokens: number
    supportTickets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    cashShifts?: boolean | UserCountOutputTypeCountCashShiftsArgs
    productAdjustments?: boolean | UserCountOutputTypeCountProductAdjustmentsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    storeShifts?: boolean | UserCountOutputTypeCountStoreShiftsArgs
    deviceTokens?: boolean | UserCountOutputTypeCountDeviceTokensArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShiftWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAdjustmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStoreShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreShiftWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    adjustments: number
    purchaseOrderItems: number
    stockTransferItems: number
    stockValuations: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    adjustments?: boolean | ProductCountOutputTypeCountAdjustmentsArgs
    purchaseOrderItems?: boolean | ProductCountOutputTypeCountPurchaseOrderItemsArgs
    stockTransferItems?: boolean | ProductCountOutputTypeCountStockTransferItemsArgs
    stockValuations?: boolean | ProductCountOutputTypeCountStockValuationsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAdjustmentWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockTransferItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockValuationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockValuationWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    orders: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | MemberCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type OutletCountOutputType
   */

  export type OutletCountOutputType = {
    orders: number
    storeShifts: number
  }

  export type OutletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OutletCountOutputTypeCountOrdersArgs
    storeShifts?: boolean | OutletCountOutputTypeCountStoreShiftsArgs
  }

  // Custom InputTypes
  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutletCountOutputType
     */
    select?: OutletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeCountStoreShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreShiftWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    history: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | SubscriptionCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    deliveries: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchaseOrders: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }


  /**
   * Count Type StockTransferCountOutputType
   */

  export type StockTransferCountOutputType = {
    items: number
  }

  export type StockTransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | StockTransferCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * StockTransferCountOutputType without action
   */
  export type StockTransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferCountOutputType
     */
    select?: StockTransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockTransferCountOutputType without action
   */
  export type StockTransferCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferItemWhereInput
  }


  /**
   * Count Type StoreShiftCountOutputType
   */

  export type StoreShiftCountOutputType = {
    orders: number
    cashShifts: number
    productAdjustments: number
    stockTransfers: number
  }

  export type StoreShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | StoreShiftCountOutputTypeCountOrdersArgs
    cashShifts?: boolean | StoreShiftCountOutputTypeCountCashShiftsArgs
    productAdjustments?: boolean | StoreShiftCountOutputTypeCountProductAdjustmentsArgs
    stockTransfers?: boolean | StoreShiftCountOutputTypeCountStockTransfersArgs
  }

  // Custom InputTypes
  /**
   * StoreShiftCountOutputType without action
   */
  export type StoreShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShiftCountOutputType
     */
    select?: StoreShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreShiftCountOutputType without action
   */
  export type StoreShiftCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * StoreShiftCountOutputType without action
   */
  export type StoreShiftCountOutputTypeCountCashShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShiftWhereInput
  }

  /**
   * StoreShiftCountOutputType without action
   */
  export type StoreShiftCountOutputTypeCountProductAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAdjustmentWhereInput
  }

  /**
   * StoreShiftCountOutputType without action
   */
  export type StoreShiftCountOutputTypeCountStockTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    tenantsActive: number | null
    tenantsLimit: number | null
  }

  export type TenantSumAggregateOutputType = {
    tenantsActive: number | null
    tenantsLimit: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    email: string | null
    phone: string | null
    address: string | null
    isActive: boolean | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    subscriptionPlan: string | null
    previousPlan: string | null
    temporaryUpgrade: boolean | null
    tenantsActive: number | null
    tenantsLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    email: string | null
    phone: string | null
    address: string | null
    isActive: boolean | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    subscriptionPlan: string | null
    previousPlan: string | null
    temporaryUpgrade: boolean | null
    tenantsActive: number | null
    tenantsLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    email: number
    phone: number
    address: number
    isActive: number
    subscriptionStart: number
    subscriptionEnd: number
    subscriptionPlan: number
    previousPlan: number
    temporaryUpgrade: number
    features: number
    tenantsActive: number
    tenantsLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    tenantsActive?: true
    tenantsLimit?: true
  }

  export type TenantSumAggregateInputType = {
    tenantsActive?: true
    tenantsLimit?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    address?: true
    isActive?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    subscriptionPlan?: true
    previousPlan?: true
    temporaryUpgrade?: true
    tenantsActive?: true
    tenantsLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    address?: true
    isActive?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    subscriptionPlan?: true
    previousPlan?: true
    temporaryUpgrade?: true
    tenantsActive?: true
    tenantsLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    address?: true
    isActive?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    subscriptionPlan?: true
    previousPlan?: true
    temporaryUpgrade?: true
    features?: true
    tenantsActive?: true
    tenantsLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    email: string
    phone: string | null
    address: string | null
    isActive: boolean
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    subscriptionPlan: string | null
    previousPlan: string | null
    temporaryUpgrade: boolean
    features: JsonValue | null
    tenantsActive: number
    tenantsLimit: number
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    subscriptionPlan?: boolean
    previousPlan?: boolean
    temporaryUpgrade?: boolean
    features?: boolean
    tenantsActive?: boolean
    tenantsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    members?: boolean | Tenant$membersArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    outlets?: boolean | Tenant$outletsArgs<ExtArgs>
    reports?: boolean | Tenant$reportsArgs<ExtArgs>
    addons?: boolean | Tenant$addonsArgs<ExtArgs>
    subscriptions?: boolean | Tenant$subscriptionsArgs<ExtArgs>
    subscriptionHistory?: boolean | Tenant$subscriptionHistoryArgs<ExtArgs>
    receiptTemplates?: boolean | Tenant$receiptTemplatesArgs<ExtArgs>
    discounts?: boolean | Tenant$discountsArgs<ExtArgs>
    paymentMappings?: boolean | Tenant$paymentMappingsArgs<ExtArgs>
    productAdjustments?: boolean | Tenant$productAdjustmentsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    webhooks?: boolean | Tenant$webhooksArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    purchaseOrders?: boolean | Tenant$purchaseOrdersArgs<ExtArgs>
    stockTransfers?: boolean | Tenant$stockTransfersArgs<ExtArgs>
    stockValuations?: boolean | Tenant$stockValuationsArgs<ExtArgs>
    backupLogs?: boolean | Tenant$backupLogsArgs<ExtArgs>
    cashShifts?: boolean | Tenant$cashShiftsArgs<ExtArgs>
    storeShifts?: boolean | Tenant$storeShiftsArgs<ExtArgs>
    courierConfigs?: boolean | Tenant$courierConfigsArgs<ExtArgs>
    supportTickets?: boolean | Tenant$supportTicketsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    subscriptionPlan?: boolean
    previousPlan?: boolean
    temporaryUpgrade?: boolean
    features?: boolean
    tenantsActive?: boolean
    tenantsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    subscriptionPlan?: boolean
    previousPlan?: boolean
    temporaryUpgrade?: boolean
    features?: boolean
    tenantsActive?: boolean
    tenantsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    isActive?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    subscriptionPlan?: boolean
    previousPlan?: boolean
    temporaryUpgrade?: boolean
    features?: boolean
    tenantsActive?: boolean
    tenantsLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "email" | "phone" | "address" | "isActive" | "subscriptionStart" | "subscriptionEnd" | "subscriptionPlan" | "previousPlan" | "temporaryUpgrade" | "features" | "tenantsActive" | "tenantsLimit" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    members?: boolean | Tenant$membersArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    outlets?: boolean | Tenant$outletsArgs<ExtArgs>
    reports?: boolean | Tenant$reportsArgs<ExtArgs>
    addons?: boolean | Tenant$addonsArgs<ExtArgs>
    subscriptions?: boolean | Tenant$subscriptionsArgs<ExtArgs>
    subscriptionHistory?: boolean | Tenant$subscriptionHistoryArgs<ExtArgs>
    receiptTemplates?: boolean | Tenant$receiptTemplatesArgs<ExtArgs>
    discounts?: boolean | Tenant$discountsArgs<ExtArgs>
    paymentMappings?: boolean | Tenant$paymentMappingsArgs<ExtArgs>
    productAdjustments?: boolean | Tenant$productAdjustmentsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    webhooks?: boolean | Tenant$webhooksArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    purchaseOrders?: boolean | Tenant$purchaseOrdersArgs<ExtArgs>
    stockTransfers?: boolean | Tenant$stockTransfersArgs<ExtArgs>
    stockValuations?: boolean | Tenant$stockValuationsArgs<ExtArgs>
    backupLogs?: boolean | Tenant$backupLogsArgs<ExtArgs>
    cashShifts?: boolean | Tenant$cashShiftsArgs<ExtArgs>
    storeShifts?: boolean | Tenant$storeShiftsArgs<ExtArgs>
    courierConfigs?: boolean | Tenant$courierConfigsArgs<ExtArgs>
    supportTickets?: boolean | Tenant$supportTicketsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      outlets: Prisma.$OutletPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      addons: Prisma.$TenantAddonPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      subscriptionHistory: Prisma.$SubscriptionHistoryPayload<ExtArgs>[]
      receiptTemplates: Prisma.$ReceiptTemplatePayload<ExtArgs>[]
      discounts: Prisma.$DiscountPayload<ExtArgs>[]
      paymentMappings: Prisma.$PaymentMappingPayload<ExtArgs>[]
      productAdjustments: Prisma.$ProductAdjustmentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      stockTransfers: Prisma.$StockTransferPayload<ExtArgs>[]
      stockValuations: Prisma.$StockValuationPayload<ExtArgs>[]
      backupLogs: Prisma.$BackupLogPayload<ExtArgs>[]
      cashShifts: Prisma.$CashShiftPayload<ExtArgs>[]
      storeShifts: Prisma.$StoreShiftPayload<ExtArgs>[]
      courierConfigs: Prisma.$CourierConfigPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      email: string
      phone: string | null
      address: string | null
      isActive: boolean
      subscriptionStart: Date | null
      subscriptionEnd: Date | null
      subscriptionPlan: string | null
      previousPlan: string | null
      temporaryUpgrade: boolean
      features: Prisma.JsonValue | null
      tenantsActive: number
      tenantsLimit: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Tenant$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Tenant$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Tenant$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Tenant$customersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Tenant$membersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Tenant$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outlets<T extends Tenant$outletsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$outletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Tenant$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addons<T extends Tenant$addonsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$addonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Tenant$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptionHistory<T extends Tenant$subscriptionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$subscriptionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receiptTemplates<T extends Tenant$receiptTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$receiptTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discounts<T extends Tenant$discountsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentMappings<T extends Tenant$paymentMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productAdjustments<T extends Tenant$productAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$productAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    webhooks<T extends Tenant$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Tenant$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Tenant$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransfers<T extends Tenant$stockTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$stockTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockValuations<T extends Tenant$stockValuationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$stockValuationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    backupLogs<T extends Tenant$backupLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$backupLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashShifts<T extends Tenant$cashShiftsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storeShifts<T extends Tenant$storeShiftsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$storeShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courierConfigs<T extends Tenant$courierConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$courierConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends Tenant$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly subscriptionStart: FieldRef<"Tenant", 'DateTime'>
    readonly subscriptionEnd: FieldRef<"Tenant", 'DateTime'>
    readonly subscriptionPlan: FieldRef<"Tenant", 'String'>
    readonly previousPlan: FieldRef<"Tenant", 'String'>
    readonly temporaryUpgrade: FieldRef<"Tenant", 'Boolean'>
    readonly features: FieldRef<"Tenant", 'Json'>
    readonly tenantsActive: FieldRef<"Tenant", 'Int'>
    readonly tenantsLimit: FieldRef<"Tenant", 'Int'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.products
   */
  export type Tenant$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Tenant.orders
   */
  export type Tenant$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Tenant.transactions
   */
  export type Tenant$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Tenant.customers
   */
  export type Tenant$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Tenant.members
   */
  export type Tenant$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Tenant.employees
   */
  export type Tenant$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Tenant.outlets
   */
  export type Tenant$outletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    where?: OutletWhereInput
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    cursor?: OutletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Tenant.reports
   */
  export type Tenant$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Tenant.addons
   */
  export type Tenant$addonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    where?: TenantAddonWhereInput
    orderBy?: TenantAddonOrderByWithRelationInput | TenantAddonOrderByWithRelationInput[]
    cursor?: TenantAddonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantAddonScalarFieldEnum | TenantAddonScalarFieldEnum[]
  }

  /**
   * Tenant.subscriptions
   */
  export type Tenant$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Tenant.subscriptionHistory
   */
  export type Tenant$subscriptionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    cursor?: SubscriptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * Tenant.receiptTemplates
   */
  export type Tenant$receiptTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    where?: ReceiptTemplateWhereInput
    orderBy?: ReceiptTemplateOrderByWithRelationInput | ReceiptTemplateOrderByWithRelationInput[]
    cursor?: ReceiptTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptTemplateScalarFieldEnum | ReceiptTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.discounts
   */
  export type Tenant$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    cursor?: DiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Tenant.paymentMappings
   */
  export type Tenant$paymentMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    where?: PaymentMappingWhereInput
    orderBy?: PaymentMappingOrderByWithRelationInput | PaymentMappingOrderByWithRelationInput[]
    cursor?: PaymentMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMappingScalarFieldEnum | PaymentMappingScalarFieldEnum[]
  }

  /**
   * Tenant.productAdjustments
   */
  export type Tenant$productAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    where?: ProductAdjustmentWhereInput
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    cursor?: ProductAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.webhooks
   */
  export type Tenant$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Tenant.suppliers
   */
  export type Tenant$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Tenant.purchaseOrders
   */
  export type Tenant$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Tenant.stockTransfers
   */
  export type Tenant$stockTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    cursor?: StockTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * Tenant.stockValuations
   */
  export type Tenant$stockValuationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    where?: StockValuationWhereInput
    orderBy?: StockValuationOrderByWithRelationInput | StockValuationOrderByWithRelationInput[]
    cursor?: StockValuationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockValuationScalarFieldEnum | StockValuationScalarFieldEnum[]
  }

  /**
   * Tenant.backupLogs
   */
  export type Tenant$backupLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    where?: BackupLogWhereInput
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    cursor?: BackupLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * Tenant.cashShifts
   */
  export type Tenant$cashShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    where?: CashShiftWhereInput
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    cursor?: CashShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashShiftScalarFieldEnum | CashShiftScalarFieldEnum[]
  }

  /**
   * Tenant.storeShifts
   */
  export type Tenant$storeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    cursor?: StoreShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreShiftScalarFieldEnum | StoreShiftScalarFieldEnum[]
  }

  /**
   * Tenant.courierConfigs
   */
  export type Tenant$courierConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    where?: CourierConfigWhereInput
    orderBy?: CourierConfigOrderByWithRelationInput | CourierConfigOrderByWithRelationInput[]
    cursor?: CourierConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourierConfigScalarFieldEnum | CourierConfigScalarFieldEnum[]
  }

  /**
   * Tenant.supportTickets
   */
  export type Tenant$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    twoFactorBackupCodes: string | null
    passwordHistory: string | null
    passwordChangedAt: Date | null
    mustChangePassword: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    twoFactorBackupCodes: string | null
    passwordHistory: string | null
    passwordChangedAt: Date | null
    mustChangePassword: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    password: number
    name: number
    role: number
    isActive: number
    permissions: number
    lastLogin: number
    twoFactorEnabled: number
    twoFactorSecret: number
    twoFactorBackupCodes: number
    passwordHistory: number
    passwordChangedAt: number
    mustChangePassword: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    lastLogin?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    passwordHistory?: true
    passwordChangedAt?: true
    mustChangePassword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    lastLogin?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    passwordHistory?: true
    passwordChangedAt?: true
    mustChangePassword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    permissions?: true
    lastLogin?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    twoFactorBackupCodes?: true
    passwordHistory?: true
    passwordChangedAt?: true
    mustChangePassword?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    password: string
    name: string
    role: $Enums.UserRole
    isActive: boolean
    permissions: JsonValue | null
    lastLogin: Date | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    twoFactorBackupCodes: string | null
    passwordHistory: string | null
    passwordChangedAt: Date | null
    mustChangePassword: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    lastLogin?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    passwordHistory?: boolean
    passwordChangedAt?: boolean
    mustChangePassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    cashShifts?: boolean | User$cashShiftsArgs<ExtArgs>
    productAdjustments?: boolean | User$productAdjustmentsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    storeShifts?: boolean | User$storeShiftsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    lastLogin?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    passwordHistory?: boolean
    passwordChangedAt?: boolean
    mustChangePassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    lastLogin?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    passwordHistory?: boolean
    passwordChangedAt?: boolean
    mustChangePassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    permissions?: boolean
    lastLogin?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    twoFactorBackupCodes?: boolean
    passwordHistory?: boolean
    passwordChangedAt?: boolean
    mustChangePassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "email" | "password" | "name" | "role" | "isActive" | "permissions" | "lastLogin" | "twoFactorEnabled" | "twoFactorSecret" | "twoFactorBackupCodes" | "passwordHistory" | "passwordChangedAt" | "mustChangePassword" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    cashShifts?: boolean | User$cashShiftsArgs<ExtArgs>
    productAdjustments?: boolean | User$productAdjustmentsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    storeShifts?: boolean | User$storeShiftsArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      cashShifts: Prisma.$CashShiftPayload<ExtArgs>[]
      productAdjustments: Prisma.$ProductAdjustmentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      storeShifts: Prisma.$StoreShiftPayload<ExtArgs>[]
      deviceTokens: Prisma.$DeviceTokenPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      password: string
      name: string
      role: $Enums.UserRole
      isActive: boolean
      permissions: Prisma.JsonValue | null
      lastLogin: Date | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      twoFactorBackupCodes: string | null
      passwordHistory: string | null
      passwordChangedAt: Date | null
      mustChangePassword: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashShifts<T extends User$cashShiftsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productAdjustments<T extends User$productAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$productAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storeShifts<T extends User$storeShiftsArgs<ExtArgs> = {}>(args?: Subset<T, User$storeShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceTokens<T extends User$deviceTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly permissions: FieldRef<"User", 'Json'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'String'>
    readonly passwordHistory: FieldRef<"User", 'String'>
    readonly passwordChangedAt: FieldRef<"User", 'DateTime'>
    readonly mustChangePassword: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.cashShifts
   */
  export type User$cashShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    where?: CashShiftWhereInput
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    cursor?: CashShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashShiftScalarFieldEnum | CashShiftScalarFieldEnum[]
  }

  /**
   * User.productAdjustments
   */
  export type User$productAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    where?: ProductAdjustmentWhereInput
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    cursor?: ProductAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.storeShifts
   */
  export type User$storeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    cursor?: StoreShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreShiftScalarFieldEnum | StoreShiftScalarFieldEnum[]
  }

  /**
   * User.deviceTokens
   */
  export type User$deviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    cursor?: DeviceTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    cost: Decimal | null
    stock: number | null
    minStock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    cost: Decimal | null
    stock: number | null
    minStock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    sku: string | null
    barcode: string | null
    price: Decimal | null
    cost: Decimal | null
    stock: number | null
    minStock: number | null
    category: string | null
    image: string | null
    emoji: string | null
    isActive: boolean | null
    isConsignment: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    sku: string | null
    barcode: string | null
    price: Decimal | null
    cost: Decimal | null
    stock: number | null
    minStock: number | null
    category: string | null
    image: string | null
    emoji: string | null
    isActive: boolean | null
    isConsignment: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    sku: number
    barcode: number
    price: number
    cost: number
    stock: number
    minStock: number
    category: number
    image: number
    emoji: number
    isActive: number
    isConsignment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    cost?: true
    stock?: true
    minStock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    cost?: true
    stock?: true
    minStock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    sku?: true
    barcode?: true
    price?: true
    cost?: true
    stock?: true
    minStock?: true
    category?: true
    image?: true
    emoji?: true
    isActive?: true
    isConsignment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    sku?: true
    barcode?: true
    price?: true
    cost?: true
    stock?: true
    minStock?: true
    category?: true
    image?: true
    emoji?: true
    isActive?: true
    isConsignment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    sku?: true
    barcode?: true
    price?: true
    cost?: true
    stock?: true
    minStock?: true
    category?: true
    image?: true
    emoji?: true
    isActive?: true
    isConsignment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    sku: string | null
    barcode: string | null
    price: Decimal
    cost: Decimal | null
    stock: number
    minStock: number
    category: string | null
    image: string | null
    emoji: string | null
    isActive: boolean
    isConsignment: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    barcode?: boolean
    price?: boolean
    cost?: boolean
    stock?: boolean
    minStock?: boolean
    category?: boolean
    image?: boolean
    emoji?: boolean
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    adjustments?: boolean | Product$adjustmentsArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    stockTransferItems?: boolean | Product$stockTransferItemsArgs<ExtArgs>
    stockValuations?: boolean | Product$stockValuationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    barcode?: boolean
    price?: boolean
    cost?: boolean
    stock?: boolean
    minStock?: boolean
    category?: boolean
    image?: boolean
    emoji?: boolean
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    barcode?: boolean
    price?: boolean
    cost?: boolean
    stock?: boolean
    minStock?: boolean
    category?: boolean
    image?: boolean
    emoji?: boolean
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    sku?: boolean
    barcode?: boolean
    price?: boolean
    cost?: boolean
    stock?: boolean
    minStock?: boolean
    category?: boolean
    image?: boolean
    emoji?: boolean
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "sku" | "barcode" | "price" | "cost" | "stock" | "minStock" | "category" | "image" | "emoji" | "isActive" | "isConsignment" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    adjustments?: boolean | Product$adjustmentsArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    stockTransferItems?: boolean | Product$stockTransferItemsArgs<ExtArgs>
    stockValuations?: boolean | Product$stockValuationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      adjustments: Prisma.$ProductAdjustmentPayload<ExtArgs>[]
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      stockTransferItems: Prisma.$StockTransferItemPayload<ExtArgs>[]
      stockValuations: Prisma.$StockValuationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      sku: string | null
      barcode: string | null
      price: Prisma.Decimal
      cost: Prisma.Decimal | null
      stock: number
      minStock: number
      category: string | null
      image: string | null
      emoji: string | null
      isActive: boolean
      isConsignment: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustments<T extends Product$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Product$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrderItems<T extends Product$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransferItems<T extends Product$stockTransferItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockTransferItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockValuations<T extends Product$stockValuationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockValuationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly tenantId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly cost: FieldRef<"Product", 'Decimal'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly minStock: FieldRef<"Product", 'Int'>
    readonly category: FieldRef<"Product", 'String'>
    readonly image: FieldRef<"Product", 'String'>
    readonly emoji: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly isConsignment: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.adjustments
   */
  export type Product$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    where?: ProductAdjustmentWhereInput
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    cursor?: ProductAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * Product.purchaseOrderItems
   */
  export type Product$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Product.stockTransferItems
   */
  export type Product$stockTransferItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    where?: StockTransferItemWhereInput
    orderBy?: StockTransferItemOrderByWithRelationInput | StockTransferItemOrderByWithRelationInput[]
    cursor?: StockTransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferItemScalarFieldEnum | StockTransferItemScalarFieldEnum[]
  }

  /**
   * Product.stockValuations
   */
  export type Product$stockValuationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    where?: StockValuationWhereInput
    orderBy?: StockValuationOrderByWithRelationInput | StockValuationOrderByWithRelationInput[]
    cursor?: StockValuationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockValuationScalarFieldEnum | StockValuationScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductAdjustment
   */

  export type AggregateProductAdjustment = {
    _count: ProductAdjustmentCountAggregateOutputType | null
    _avg: ProductAdjustmentAvgAggregateOutputType | null
    _sum: ProductAdjustmentSumAggregateOutputType | null
    _min: ProductAdjustmentMinAggregateOutputType | null
    _max: ProductAdjustmentMaxAggregateOutputType | null
  }

  export type ProductAdjustmentAvgAggregateOutputType = {
    quantity: number | null
    stockBefore: number | null
    stockAfter: number | null
  }

  export type ProductAdjustmentSumAggregateOutputType = {
    quantity: number | null
    stockBefore: number | null
    stockAfter: number | null
  }

  export type ProductAdjustmentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    userId: string | null
    storeShiftId: string | null
    type: string | null
    quantity: number | null
    reason: string | null
    stockBefore: number | null
    stockAfter: number | null
    createdAt: Date | null
  }

  export type ProductAdjustmentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    userId: string | null
    storeShiftId: string | null
    type: string | null
    quantity: number | null
    reason: string | null
    stockBefore: number | null
    stockAfter: number | null
    createdAt: Date | null
  }

  export type ProductAdjustmentCountAggregateOutputType = {
    id: number
    tenantId: number
    productId: number
    userId: number
    storeShiftId: number
    type: number
    quantity: number
    reason: number
    stockBefore: number
    stockAfter: number
    createdAt: number
    _all: number
  }


  export type ProductAdjustmentAvgAggregateInputType = {
    quantity?: true
    stockBefore?: true
    stockAfter?: true
  }

  export type ProductAdjustmentSumAggregateInputType = {
    quantity?: true
    stockBefore?: true
    stockAfter?: true
  }

  export type ProductAdjustmentMinAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    userId?: true
    storeShiftId?: true
    type?: true
    quantity?: true
    reason?: true
    stockBefore?: true
    stockAfter?: true
    createdAt?: true
  }

  export type ProductAdjustmentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    userId?: true
    storeShiftId?: true
    type?: true
    quantity?: true
    reason?: true
    stockBefore?: true
    stockAfter?: true
    createdAt?: true
  }

  export type ProductAdjustmentCountAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    userId?: true
    storeShiftId?: true
    type?: true
    quantity?: true
    reason?: true
    stockBefore?: true
    stockAfter?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAdjustment to aggregate.
     */
    where?: ProductAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAdjustments to fetch.
     */
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAdjustments
    **/
    _count?: true | ProductAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAdjustmentMaxAggregateInputType
  }

  export type GetProductAdjustmentAggregateType<T extends ProductAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAdjustment[P]>
      : GetScalarType<T[P], AggregateProductAdjustment[P]>
  }




  export type ProductAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAdjustmentWhereInput
    orderBy?: ProductAdjustmentOrderByWithAggregationInput | ProductAdjustmentOrderByWithAggregationInput[]
    by: ProductAdjustmentScalarFieldEnum[] | ProductAdjustmentScalarFieldEnum
    having?: ProductAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAdjustmentCountAggregateInputType | true
    _avg?: ProductAdjustmentAvgAggregateInputType
    _sum?: ProductAdjustmentSumAggregateInputType
    _min?: ProductAdjustmentMinAggregateInputType
    _max?: ProductAdjustmentMaxAggregateInputType
  }

  export type ProductAdjustmentGroupByOutputType = {
    id: string
    tenantId: string
    productId: string
    userId: string
    storeShiftId: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt: Date
    _count: ProductAdjustmentCountAggregateOutputType | null
    _avg: ProductAdjustmentAvgAggregateOutputType | null
    _sum: ProductAdjustmentSumAggregateOutputType | null
    _min: ProductAdjustmentMinAggregateOutputType | null
    _max: ProductAdjustmentMaxAggregateOutputType | null
  }

  type GetProductAdjustmentGroupByPayload<T extends ProductAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type ProductAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    userId?: boolean
    storeShiftId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    stockBefore?: boolean
    stockAfter?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    storeShift?: boolean | ProductAdjustment$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["productAdjustment"]>

  export type ProductAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    userId?: boolean
    storeShiftId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    stockBefore?: boolean
    stockAfter?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    storeShift?: boolean | ProductAdjustment$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["productAdjustment"]>

  export type ProductAdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    userId?: boolean
    storeShiftId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    stockBefore?: boolean
    stockAfter?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    storeShift?: boolean | ProductAdjustment$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["productAdjustment"]>

  export type ProductAdjustmentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    userId?: boolean
    storeShiftId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    stockBefore?: boolean
    stockAfter?: boolean
    createdAt?: boolean
  }

  export type ProductAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "productId" | "userId" | "storeShiftId" | "type" | "quantity" | "reason" | "stockBefore" | "stockAfter" | "createdAt", ExtArgs["result"]["productAdjustment"]>
  export type ProductAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    storeShift?: boolean | ProductAdjustment$storeShiftArgs<ExtArgs>
  }
  export type ProductAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    storeShift?: boolean | ProductAdjustment$storeShiftArgs<ExtArgs>
  }
  export type ProductAdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    storeShift?: boolean | ProductAdjustment$storeShiftArgs<ExtArgs>
  }

  export type $ProductAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductAdjustment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      storeShift: Prisma.$StoreShiftPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      productId: string
      userId: string
      storeShiftId: string | null
      type: string
      quantity: number
      reason: string
      stockBefore: number
      stockAfter: number
      createdAt: Date
    }, ExtArgs["result"]["productAdjustment"]>
    composites: {}
  }

  type ProductAdjustmentGetPayload<S extends boolean | null | undefined | ProductAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$ProductAdjustmentPayload, S>

  type ProductAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductAdjustmentCountAggregateInputType | true
    }

  export interface ProductAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductAdjustment'], meta: { name: 'ProductAdjustment' } }
    /**
     * Find zero or one ProductAdjustment that matches the filter.
     * @param {ProductAdjustmentFindUniqueArgs} args - Arguments to find a ProductAdjustment
     * @example
     * // Get one ProductAdjustment
     * const productAdjustment = await prisma.productAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductAdjustmentFindUniqueArgs>(args: SelectSubset<T, ProductAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a ProductAdjustment
     * @example
     * // Get one ProductAdjustment
     * const productAdjustment = await prisma.productAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentFindFirstArgs} args - Arguments to find a ProductAdjustment
     * @example
     * // Get one ProductAdjustment
     * const productAdjustment = await prisma.productAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductAdjustmentFindFirstArgs>(args?: SelectSubset<T, ProductAdjustmentFindFirstArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentFindFirstOrThrowArgs} args - Arguments to find a ProductAdjustment
     * @example
     * // Get one ProductAdjustment
     * const productAdjustment = await prisma.productAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAdjustments
     * const productAdjustments = await prisma.productAdjustment.findMany()
     * 
     * // Get first 10 ProductAdjustments
     * const productAdjustments = await prisma.productAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAdjustmentWithIdOnly = await prisma.productAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductAdjustmentFindManyArgs>(args?: SelectSubset<T, ProductAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductAdjustment.
     * @param {ProductAdjustmentCreateArgs} args - Arguments to create a ProductAdjustment.
     * @example
     * // Create one ProductAdjustment
     * const ProductAdjustment = await prisma.productAdjustment.create({
     *   data: {
     *     // ... data to create a ProductAdjustment
     *   }
     * })
     * 
     */
    create<T extends ProductAdjustmentCreateArgs>(args: SelectSubset<T, ProductAdjustmentCreateArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductAdjustments.
     * @param {ProductAdjustmentCreateManyArgs} args - Arguments to create many ProductAdjustments.
     * @example
     * // Create many ProductAdjustments
     * const productAdjustment = await prisma.productAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductAdjustmentCreateManyArgs>(args?: SelectSubset<T, ProductAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductAdjustments and returns the data saved in the database.
     * @param {ProductAdjustmentCreateManyAndReturnArgs} args - Arguments to create many ProductAdjustments.
     * @example
     * // Create many ProductAdjustments
     * const productAdjustment = await prisma.productAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductAdjustments and only return the `id`
     * const productAdjustmentWithIdOnly = await prisma.productAdjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductAdjustment.
     * @param {ProductAdjustmentDeleteArgs} args - Arguments to delete one ProductAdjustment.
     * @example
     * // Delete one ProductAdjustment
     * const ProductAdjustment = await prisma.productAdjustment.delete({
     *   where: {
     *     // ... filter to delete one ProductAdjustment
     *   }
     * })
     * 
     */
    delete<T extends ProductAdjustmentDeleteArgs>(args: SelectSubset<T, ProductAdjustmentDeleteArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductAdjustment.
     * @param {ProductAdjustmentUpdateArgs} args - Arguments to update one ProductAdjustment.
     * @example
     * // Update one ProductAdjustment
     * const productAdjustment = await prisma.productAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductAdjustmentUpdateArgs>(args: SelectSubset<T, ProductAdjustmentUpdateArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductAdjustments.
     * @param {ProductAdjustmentDeleteManyArgs} args - Arguments to filter ProductAdjustments to delete.
     * @example
     * // Delete a few ProductAdjustments
     * const { count } = await prisma.productAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductAdjustmentDeleteManyArgs>(args?: SelectSubset<T, ProductAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAdjustments
     * const productAdjustment = await prisma.productAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductAdjustmentUpdateManyArgs>(args: SelectSubset<T, ProductAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAdjustments and returns the data updated in the database.
     * @param {ProductAdjustmentUpdateManyAndReturnArgs} args - Arguments to update many ProductAdjustments.
     * @example
     * // Update many ProductAdjustments
     * const productAdjustment = await prisma.productAdjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductAdjustments and only return the `id`
     * const productAdjustmentWithIdOnly = await prisma.productAdjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductAdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductAdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductAdjustment.
     * @param {ProductAdjustmentUpsertArgs} args - Arguments to update or create a ProductAdjustment.
     * @example
     * // Update or create a ProductAdjustment
     * const productAdjustment = await prisma.productAdjustment.upsert({
     *   create: {
     *     // ... data to create a ProductAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends ProductAdjustmentUpsertArgs>(args: SelectSubset<T, ProductAdjustmentUpsertArgs<ExtArgs>>): Prisma__ProductAdjustmentClient<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentCountArgs} args - Arguments to filter ProductAdjustments to count.
     * @example
     * // Count the number of ProductAdjustments
     * const count = await prisma.productAdjustment.count({
     *   where: {
     *     // ... the filter for the ProductAdjustments we want to count
     *   }
     * })
    **/
    count<T extends ProductAdjustmentCountArgs>(
      args?: Subset<T, ProductAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAdjustmentAggregateArgs>(args: Subset<T, ProductAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetProductAdjustmentAggregateType<T>>

    /**
     * Group by ProductAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: ProductAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductAdjustment model
   */
  readonly fields: ProductAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    storeShift<T extends ProductAdjustment$storeShiftArgs<ExtArgs> = {}>(args?: Subset<T, ProductAdjustment$storeShiftArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductAdjustment model
   */
  interface ProductAdjustmentFieldRefs {
    readonly id: FieldRef<"ProductAdjustment", 'String'>
    readonly tenantId: FieldRef<"ProductAdjustment", 'String'>
    readonly productId: FieldRef<"ProductAdjustment", 'String'>
    readonly userId: FieldRef<"ProductAdjustment", 'String'>
    readonly storeShiftId: FieldRef<"ProductAdjustment", 'String'>
    readonly type: FieldRef<"ProductAdjustment", 'String'>
    readonly quantity: FieldRef<"ProductAdjustment", 'Int'>
    readonly reason: FieldRef<"ProductAdjustment", 'String'>
    readonly stockBefore: FieldRef<"ProductAdjustment", 'Int'>
    readonly stockAfter: FieldRef<"ProductAdjustment", 'Int'>
    readonly createdAt: FieldRef<"ProductAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductAdjustment findUnique
   */
  export type ProductAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which ProductAdjustment to fetch.
     */
    where: ProductAdjustmentWhereUniqueInput
  }

  /**
   * ProductAdjustment findUniqueOrThrow
   */
  export type ProductAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which ProductAdjustment to fetch.
     */
    where: ProductAdjustmentWhereUniqueInput
  }

  /**
   * ProductAdjustment findFirst
   */
  export type ProductAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which ProductAdjustment to fetch.
     */
    where?: ProductAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAdjustments to fetch.
     */
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAdjustments.
     */
    cursor?: ProductAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAdjustments.
     */
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * ProductAdjustment findFirstOrThrow
   */
  export type ProductAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which ProductAdjustment to fetch.
     */
    where?: ProductAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAdjustments to fetch.
     */
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAdjustments.
     */
    cursor?: ProductAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAdjustments.
     */
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * ProductAdjustment findMany
   */
  export type ProductAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which ProductAdjustments to fetch.
     */
    where?: ProductAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAdjustments to fetch.
     */
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAdjustments.
     */
    cursor?: ProductAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAdjustments.
     */
    skip?: number
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * ProductAdjustment create
   */
  export type ProductAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductAdjustment.
     */
    data: XOR<ProductAdjustmentCreateInput, ProductAdjustmentUncheckedCreateInput>
  }

  /**
   * ProductAdjustment createMany
   */
  export type ProductAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductAdjustments.
     */
    data: ProductAdjustmentCreateManyInput | ProductAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductAdjustment createManyAndReturn
   */
  export type ProductAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many ProductAdjustments.
     */
    data: ProductAdjustmentCreateManyInput | ProductAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductAdjustment update
   */
  export type ProductAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductAdjustment.
     */
    data: XOR<ProductAdjustmentUpdateInput, ProductAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which ProductAdjustment to update.
     */
    where: ProductAdjustmentWhereUniqueInput
  }

  /**
   * ProductAdjustment updateMany
   */
  export type ProductAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductAdjustments.
     */
    data: XOR<ProductAdjustmentUpdateManyMutationInput, ProductAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which ProductAdjustments to update
     */
    where?: ProductAdjustmentWhereInput
    /**
     * Limit how many ProductAdjustments to update.
     */
    limit?: number
  }

  /**
   * ProductAdjustment updateManyAndReturn
   */
  export type ProductAdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update ProductAdjustments.
     */
    data: XOR<ProductAdjustmentUpdateManyMutationInput, ProductAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which ProductAdjustments to update
     */
    where?: ProductAdjustmentWhereInput
    /**
     * Limit how many ProductAdjustments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductAdjustment upsert
   */
  export type ProductAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductAdjustment to update in case it exists.
     */
    where: ProductAdjustmentWhereUniqueInput
    /**
     * In case the ProductAdjustment found by the `where` argument doesn't exist, create a new ProductAdjustment with this data.
     */
    create: XOR<ProductAdjustmentCreateInput, ProductAdjustmentUncheckedCreateInput>
    /**
     * In case the ProductAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductAdjustmentUpdateInput, ProductAdjustmentUncheckedUpdateInput>
  }

  /**
   * ProductAdjustment delete
   */
  export type ProductAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which ProductAdjustment to delete.
     */
    where: ProductAdjustmentWhereUniqueInput
  }

  /**
   * ProductAdjustment deleteMany
   */
  export type ProductAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAdjustments to delete
     */
    where?: ProductAdjustmentWhereInput
    /**
     * Limit how many ProductAdjustments to delete.
     */
    limit?: number
  }

  /**
   * ProductAdjustment.storeShift
   */
  export type ProductAdjustment$storeShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
  }

  /**
   * ProductAdjustment without action
   */
  export type ProductAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    total: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    total: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    idempotencyKey: string | null
    tenantId: string | null
    orderNumber: string | null
    userId: string | null
    customerId: string | null
    memberId: string | null
    outletId: string | null
    storeShiftId: string | null
    total: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
    status: $Enums.OrderStatus | null
    sendToKitchen: boolean | null
    kitchenStatus: string | null
    temporaryCustomerName: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    idempotencyKey: string | null
    tenantId: string | null
    orderNumber: string | null
    userId: string | null
    customerId: string | null
    memberId: string | null
    outletId: string | null
    storeShiftId: string | null
    total: Decimal | null
    discount: Decimal | null
    subtotal: Decimal | null
    status: $Enums.OrderStatus | null
    sendToKitchen: boolean | null
    kitchenStatus: string | null
    temporaryCustomerName: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    idempotencyKey: number
    tenantId: number
    orderNumber: number
    userId: number
    customerId: number
    memberId: number
    outletId: number
    storeShiftId: number
    total: number
    discount: number
    subtotal: number
    status: number
    sendToKitchen: number
    kitchenStatus: number
    temporaryCustomerName: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    total?: true
    discount?: true
    subtotal?: true
  }

  export type OrderSumAggregateInputType = {
    total?: true
    discount?: true
    subtotal?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    idempotencyKey?: true
    tenantId?: true
    orderNumber?: true
    userId?: true
    customerId?: true
    memberId?: true
    outletId?: true
    storeShiftId?: true
    total?: true
    discount?: true
    subtotal?: true
    status?: true
    sendToKitchen?: true
    kitchenStatus?: true
    temporaryCustomerName?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    idempotencyKey?: true
    tenantId?: true
    orderNumber?: true
    userId?: true
    customerId?: true
    memberId?: true
    outletId?: true
    storeShiftId?: true
    total?: true
    discount?: true
    subtotal?: true
    status?: true
    sendToKitchen?: true
    kitchenStatus?: true
    temporaryCustomerName?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    idempotencyKey?: true
    tenantId?: true
    orderNumber?: true
    userId?: true
    customerId?: true
    memberId?: true
    outletId?: true
    storeShiftId?: true
    total?: true
    discount?: true
    subtotal?: true
    status?: true
    sendToKitchen?: true
    kitchenStatus?: true
    temporaryCustomerName?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    idempotencyKey: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId: string | null
    memberId: string | null
    outletId: string | null
    storeShiftId: string | null
    total: Decimal
    discount: Decimal
    subtotal: Decimal
    status: $Enums.OrderStatus
    sendToKitchen: boolean
    kitchenStatus: string | null
    temporaryCustomerName: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idempotencyKey?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    userId?: boolean
    customerId?: boolean
    memberId?: boolean
    outletId?: boolean
    storeShiftId?: boolean
    total?: boolean
    discount?: boolean
    subtotal?: boolean
    status?: boolean
    sendToKitchen?: boolean
    kitchenStatus?: boolean
    temporaryCustomerName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    member?: boolean | Order$memberArgs<ExtArgs>
    outlet?: boolean | Order$outletArgs<ExtArgs>
    storeShift?: boolean | Order$storeShiftArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    transaction?: boolean | Order$transactionArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idempotencyKey?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    userId?: boolean
    customerId?: boolean
    memberId?: boolean
    outletId?: boolean
    storeShiftId?: boolean
    total?: boolean
    discount?: boolean
    subtotal?: boolean
    status?: boolean
    sendToKitchen?: boolean
    kitchenStatus?: boolean
    temporaryCustomerName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    member?: boolean | Order$memberArgs<ExtArgs>
    outlet?: boolean | Order$outletArgs<ExtArgs>
    storeShift?: boolean | Order$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idempotencyKey?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    userId?: boolean
    customerId?: boolean
    memberId?: boolean
    outletId?: boolean
    storeShiftId?: boolean
    total?: boolean
    discount?: boolean
    subtotal?: boolean
    status?: boolean
    sendToKitchen?: boolean
    kitchenStatus?: boolean
    temporaryCustomerName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    member?: boolean | Order$memberArgs<ExtArgs>
    outlet?: boolean | Order$outletArgs<ExtArgs>
    storeShift?: boolean | Order$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    idempotencyKey?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    userId?: boolean
    customerId?: boolean
    memberId?: boolean
    outletId?: boolean
    storeShiftId?: boolean
    total?: boolean
    discount?: boolean
    subtotal?: boolean
    status?: boolean
    sendToKitchen?: boolean
    kitchenStatus?: boolean
    temporaryCustomerName?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idempotencyKey" | "tenantId" | "orderNumber" | "userId" | "customerId" | "memberId" | "outletId" | "storeShiftId" | "total" | "discount" | "subtotal" | "status" | "sendToKitchen" | "kitchenStatus" | "temporaryCustomerName" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    member?: boolean | Order$memberArgs<ExtArgs>
    outlet?: boolean | Order$outletArgs<ExtArgs>
    storeShift?: boolean | Order$storeShiftArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    transaction?: boolean | Order$transactionArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    member?: boolean | Order$memberArgs<ExtArgs>
    outlet?: boolean | Order$outletArgs<ExtArgs>
    storeShift?: boolean | Order$storeShiftArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    member?: boolean | Order$memberArgs<ExtArgs>
    outlet?: boolean | Order$outletArgs<ExtArgs>
    storeShift?: boolean | Order$storeShiftArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      member: Prisma.$MemberPayload<ExtArgs> | null
      outlet: Prisma.$OutletPayload<ExtArgs> | null
      storeShift: Prisma.$StoreShiftPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idempotencyKey: string | null
      tenantId: string
      orderNumber: string
      userId: string
      customerId: string | null
      memberId: string | null
      outletId: string | null
      storeShiftId: string | null
      total: Prisma.Decimal
      discount: Prisma.Decimal
      subtotal: Prisma.Decimal
      status: $Enums.OrderStatus
      sendToKitchen: boolean
      kitchenStatus: string | null
      temporaryCustomerName: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    member<T extends Order$memberArgs<ExtArgs> = {}>(args?: Subset<T, Order$memberArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    outlet<T extends Order$outletArgs<ExtArgs> = {}>(args?: Subset<T, Order$outletArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    storeShift<T extends Order$storeShiftArgs<ExtArgs> = {}>(args?: Subset<T, Order$storeShiftArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaction<T extends Order$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Order$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly idempotencyKey: FieldRef<"Order", 'String'>
    readonly tenantId: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly memberId: FieldRef<"Order", 'String'>
    readonly outletId: FieldRef<"Order", 'String'>
    readonly storeShiftId: FieldRef<"Order", 'String'>
    readonly total: FieldRef<"Order", 'Decimal'>
    readonly discount: FieldRef<"Order", 'Decimal'>
    readonly subtotal: FieldRef<"Order", 'Decimal'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly sendToKitchen: FieldRef<"Order", 'Boolean'>
    readonly kitchenStatus: FieldRef<"Order", 'String'>
    readonly temporaryCustomerName: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.member
   */
  export type Order$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
  }

  /**
   * Order.outlet
   */
  export type Order$outletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    where?: OutletWhereInput
  }

  /**
   * Order.storeShift
   */
  export type Order$storeShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.transaction
   */
  export type Order$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
    cost: Decimal | null
    subtotal: Decimal | null
    profit: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
    cost: Decimal | null
    subtotal: Decimal | null
    profit: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: Decimal | null
    cost: Decimal | null
    subtotal: Decimal | null
    profit: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: Decimal | null
    cost: Decimal | null
    subtotal: Decimal | null
    profit: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: number
    cost: number
    subtotal: number
    profit: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
    cost?: true
    subtotal?: true
    profit?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
    cost?: true
    subtotal?: true
    profit?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    cost?: true
    subtotal?: true
    profit?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    cost?: true
    subtotal?: true
    profit?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    cost?: true
    subtotal?: true
    profit?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: Decimal
    cost: Decimal | null
    subtotal: Decimal
    profit: Decimal | null
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    cost?: boolean
    subtotal?: boolean
    profit?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    cost?: boolean
    subtotal?: boolean
    profit?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    cost?: boolean
    subtotal?: boolean
    profit?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    cost?: boolean
    subtotal?: boolean
    profit?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "price" | "cost" | "subtotal" | "profit" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      price: Prisma.Decimal
      cost: Prisma.Decimal | null
      subtotal: Prisma.Decimal
      profit: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly cost: FieldRef<"OrderItem", 'Decimal'>
    readonly subtotal: FieldRef<"OrderItem", 'Decimal'>
    readonly profit: FieldRef<"OrderItem", 'Decimal'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMapping
   */

  export type AggregatePaymentMapping = {
    _count: PaymentMappingCountAggregateOutputType | null
    _avg: PaymentMappingAvgAggregateOutputType | null
    _sum: PaymentMappingSumAggregateOutputType | null
    _min: PaymentMappingMinAggregateOutputType | null
    _max: PaymentMappingMaxAggregateOutputType | null
  }

  export type PaymentMappingAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMappingSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMappingMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    tenantId: string | null
    itemId: string | null
    itemType: string | null
    itemName: string | null
    amount: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMappingMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    tenantId: string | null
    itemId: string | null
    itemType: string | null
    itemName: string | null
    amount: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMappingCountAggregateOutputType = {
    id: number
    orderId: number
    tenantId: number
    itemId: number
    itemType: number
    itemName: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMappingAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentMappingSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMappingMinAggregateInputType = {
    id?: true
    orderId?: true
    tenantId?: true
    itemId?: true
    itemType?: true
    itemName?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMappingMaxAggregateInputType = {
    id?: true
    orderId?: true
    tenantId?: true
    itemId?: true
    itemType?: true
    itemName?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMappingCountAggregateInputType = {
    id?: true
    orderId?: true
    tenantId?: true
    itemId?: true
    itemType?: true
    itemName?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMapping to aggregate.
     */
    where?: PaymentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMappings to fetch.
     */
    orderBy?: PaymentMappingOrderByWithRelationInput | PaymentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMappings
    **/
    _count?: true | PaymentMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMappingMaxAggregateInputType
  }

  export type GetPaymentMappingAggregateType<T extends PaymentMappingAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMapping[P]>
      : GetScalarType<T[P], AggregatePaymentMapping[P]>
  }




  export type PaymentMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMappingWhereInput
    orderBy?: PaymentMappingOrderByWithAggregationInput | PaymentMappingOrderByWithAggregationInput[]
    by: PaymentMappingScalarFieldEnum[] | PaymentMappingScalarFieldEnum
    having?: PaymentMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMappingCountAggregateInputType | true
    _avg?: PaymentMappingAvgAggregateInputType
    _sum?: PaymentMappingSumAggregateInputType
    _min?: PaymentMappingMinAggregateInputType
    _max?: PaymentMappingMaxAggregateInputType
  }

  export type PaymentMappingGroupByOutputType = {
    id: string
    orderId: string
    tenantId: string
    itemId: string
    itemType: string
    itemName: string | null
    amount: Decimal
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentMappingCountAggregateOutputType | null
    _avg: PaymentMappingAvgAggregateOutputType | null
    _sum: PaymentMappingSumAggregateOutputType | null
    _min: PaymentMappingMinAggregateOutputType | null
    _max: PaymentMappingMaxAggregateOutputType | null
  }

  type GetPaymentMappingGroupByPayload<T extends PaymentMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMappingGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMappingGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    tenantId?: boolean
    itemId?: boolean
    itemType?: boolean
    itemName?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMapping"]>

  export type PaymentMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    tenantId?: boolean
    itemId?: boolean
    itemType?: boolean
    itemName?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMapping"]>

  export type PaymentMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    tenantId?: boolean
    itemId?: boolean
    itemType?: boolean
    itemName?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMapping"]>

  export type PaymentMappingSelectScalar = {
    id?: boolean
    orderId?: boolean
    tenantId?: boolean
    itemId?: boolean
    itemType?: boolean
    itemName?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "tenantId" | "itemId" | "itemType" | "itemName" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMapping"]>
  export type PaymentMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMapping"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      tenantId: string
      itemId: string
      itemType: string
      itemName: string | null
      amount: Prisma.Decimal
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMapping"]>
    composites: {}
  }

  type PaymentMappingGetPayload<S extends boolean | null | undefined | PaymentMappingDefaultArgs> = $Result.GetResult<Prisma.$PaymentMappingPayload, S>

  type PaymentMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMappingCountAggregateInputType | true
    }

  export interface PaymentMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMapping'], meta: { name: 'PaymentMapping' } }
    /**
     * Find zero or one PaymentMapping that matches the filter.
     * @param {PaymentMappingFindUniqueArgs} args - Arguments to find a PaymentMapping
     * @example
     * // Get one PaymentMapping
     * const paymentMapping = await prisma.paymentMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMappingFindUniqueArgs>(args: SelectSubset<T, PaymentMappingFindUniqueArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMappingFindUniqueOrThrowArgs} args - Arguments to find a PaymentMapping
     * @example
     * // Get one PaymentMapping
     * const paymentMapping = await prisma.paymentMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingFindFirstArgs} args - Arguments to find a PaymentMapping
     * @example
     * // Get one PaymentMapping
     * const paymentMapping = await prisma.paymentMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMappingFindFirstArgs>(args?: SelectSubset<T, PaymentMappingFindFirstArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingFindFirstOrThrowArgs} args - Arguments to find a PaymentMapping
     * @example
     * // Get one PaymentMapping
     * const paymentMapping = await prisma.paymentMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMappings
     * const paymentMappings = await prisma.paymentMapping.findMany()
     * 
     * // Get first 10 PaymentMappings
     * const paymentMappings = await prisma.paymentMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMappingWithIdOnly = await prisma.paymentMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMappingFindManyArgs>(args?: SelectSubset<T, PaymentMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMapping.
     * @param {PaymentMappingCreateArgs} args - Arguments to create a PaymentMapping.
     * @example
     * // Create one PaymentMapping
     * const PaymentMapping = await prisma.paymentMapping.create({
     *   data: {
     *     // ... data to create a PaymentMapping
     *   }
     * })
     * 
     */
    create<T extends PaymentMappingCreateArgs>(args: SelectSubset<T, PaymentMappingCreateArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMappings.
     * @param {PaymentMappingCreateManyArgs} args - Arguments to create many PaymentMappings.
     * @example
     * // Create many PaymentMappings
     * const paymentMapping = await prisma.paymentMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMappingCreateManyArgs>(args?: SelectSubset<T, PaymentMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMappings and returns the data saved in the database.
     * @param {PaymentMappingCreateManyAndReturnArgs} args - Arguments to create many PaymentMappings.
     * @example
     * // Create many PaymentMappings
     * const paymentMapping = await prisma.paymentMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMappings and only return the `id`
     * const paymentMappingWithIdOnly = await prisma.paymentMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMapping.
     * @param {PaymentMappingDeleteArgs} args - Arguments to delete one PaymentMapping.
     * @example
     * // Delete one PaymentMapping
     * const PaymentMapping = await prisma.paymentMapping.delete({
     *   where: {
     *     // ... filter to delete one PaymentMapping
     *   }
     * })
     * 
     */
    delete<T extends PaymentMappingDeleteArgs>(args: SelectSubset<T, PaymentMappingDeleteArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMapping.
     * @param {PaymentMappingUpdateArgs} args - Arguments to update one PaymentMapping.
     * @example
     * // Update one PaymentMapping
     * const paymentMapping = await prisma.paymentMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMappingUpdateArgs>(args: SelectSubset<T, PaymentMappingUpdateArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMappings.
     * @param {PaymentMappingDeleteManyArgs} args - Arguments to filter PaymentMappings to delete.
     * @example
     * // Delete a few PaymentMappings
     * const { count } = await prisma.paymentMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMappingDeleteManyArgs>(args?: SelectSubset<T, PaymentMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMappings
     * const paymentMapping = await prisma.paymentMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMappingUpdateManyArgs>(args: SelectSubset<T, PaymentMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMappings and returns the data updated in the database.
     * @param {PaymentMappingUpdateManyAndReturnArgs} args - Arguments to update many PaymentMappings.
     * @example
     * // Update many PaymentMappings
     * const paymentMapping = await prisma.paymentMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMappings and only return the `id`
     * const paymentMappingWithIdOnly = await prisma.paymentMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMapping.
     * @param {PaymentMappingUpsertArgs} args - Arguments to update or create a PaymentMapping.
     * @example
     * // Update or create a PaymentMapping
     * const paymentMapping = await prisma.paymentMapping.upsert({
     *   create: {
     *     // ... data to create a PaymentMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMapping we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMappingUpsertArgs>(args: SelectSubset<T, PaymentMappingUpsertArgs<ExtArgs>>): Prisma__PaymentMappingClient<$Result.GetResult<Prisma.$PaymentMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingCountArgs} args - Arguments to filter PaymentMappings to count.
     * @example
     * // Count the number of PaymentMappings
     * const count = await prisma.paymentMapping.count({
     *   where: {
     *     // ... the filter for the PaymentMappings we want to count
     *   }
     * })
    **/
    count<T extends PaymentMappingCountArgs>(
      args?: Subset<T, PaymentMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMappingAggregateArgs>(args: Subset<T, PaymentMappingAggregateArgs>): Prisma.PrismaPromise<GetPaymentMappingAggregateType<T>>

    /**
     * Group by PaymentMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMappingGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMapping model
   */
  readonly fields: PaymentMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMapping model
   */
  interface PaymentMappingFieldRefs {
    readonly id: FieldRef<"PaymentMapping", 'String'>
    readonly orderId: FieldRef<"PaymentMapping", 'String'>
    readonly tenantId: FieldRef<"PaymentMapping", 'String'>
    readonly itemId: FieldRef<"PaymentMapping", 'String'>
    readonly itemType: FieldRef<"PaymentMapping", 'String'>
    readonly itemName: FieldRef<"PaymentMapping", 'String'>
    readonly amount: FieldRef<"PaymentMapping", 'Decimal'>
    readonly status: FieldRef<"PaymentMapping", 'String'>
    readonly createdAt: FieldRef<"PaymentMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMapping findUnique
   */
  export type PaymentMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMapping to fetch.
     */
    where: PaymentMappingWhereUniqueInput
  }

  /**
   * PaymentMapping findUniqueOrThrow
   */
  export type PaymentMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMapping to fetch.
     */
    where: PaymentMappingWhereUniqueInput
  }

  /**
   * PaymentMapping findFirst
   */
  export type PaymentMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMapping to fetch.
     */
    where?: PaymentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMappings to fetch.
     */
    orderBy?: PaymentMappingOrderByWithRelationInput | PaymentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMappings.
     */
    cursor?: PaymentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMappings.
     */
    distinct?: PaymentMappingScalarFieldEnum | PaymentMappingScalarFieldEnum[]
  }

  /**
   * PaymentMapping findFirstOrThrow
   */
  export type PaymentMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMapping to fetch.
     */
    where?: PaymentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMappings to fetch.
     */
    orderBy?: PaymentMappingOrderByWithRelationInput | PaymentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMappings.
     */
    cursor?: PaymentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMappings.
     */
    distinct?: PaymentMappingScalarFieldEnum | PaymentMappingScalarFieldEnum[]
  }

  /**
   * PaymentMapping findMany
   */
  export type PaymentMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMappings to fetch.
     */
    where?: PaymentMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMappings to fetch.
     */
    orderBy?: PaymentMappingOrderByWithRelationInput | PaymentMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMappings.
     */
    cursor?: PaymentMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMappings.
     */
    skip?: number
    distinct?: PaymentMappingScalarFieldEnum | PaymentMappingScalarFieldEnum[]
  }

  /**
   * PaymentMapping create
   */
  export type PaymentMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMapping.
     */
    data: XOR<PaymentMappingCreateInput, PaymentMappingUncheckedCreateInput>
  }

  /**
   * PaymentMapping createMany
   */
  export type PaymentMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMappings.
     */
    data: PaymentMappingCreateManyInput | PaymentMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMapping createManyAndReturn
   */
  export type PaymentMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMappings.
     */
    data: PaymentMappingCreateManyInput | PaymentMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMapping update
   */
  export type PaymentMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMapping.
     */
    data: XOR<PaymentMappingUpdateInput, PaymentMappingUncheckedUpdateInput>
    /**
     * Choose, which PaymentMapping to update.
     */
    where: PaymentMappingWhereUniqueInput
  }

  /**
   * PaymentMapping updateMany
   */
  export type PaymentMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMappings.
     */
    data: XOR<PaymentMappingUpdateManyMutationInput, PaymentMappingUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMappings to update
     */
    where?: PaymentMappingWhereInput
    /**
     * Limit how many PaymentMappings to update.
     */
    limit?: number
  }

  /**
   * PaymentMapping updateManyAndReturn
   */
  export type PaymentMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMappings.
     */
    data: XOR<PaymentMappingUpdateManyMutationInput, PaymentMappingUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMappings to update
     */
    where?: PaymentMappingWhereInput
    /**
     * Limit how many PaymentMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMapping upsert
   */
  export type PaymentMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMapping to update in case it exists.
     */
    where: PaymentMappingWhereUniqueInput
    /**
     * In case the PaymentMapping found by the `where` argument doesn't exist, create a new PaymentMapping with this data.
     */
    create: XOR<PaymentMappingCreateInput, PaymentMappingUncheckedCreateInput>
    /**
     * In case the PaymentMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMappingUpdateInput, PaymentMappingUncheckedUpdateInput>
  }

  /**
   * PaymentMapping delete
   */
  export type PaymentMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
    /**
     * Filter which PaymentMapping to delete.
     */
    where: PaymentMappingWhereUniqueInput
  }

  /**
   * PaymentMapping deleteMany
   */
  export type PaymentMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMappings to delete
     */
    where?: PaymentMappingWhereInput
    /**
     * Limit how many PaymentMappings to delete.
     */
    limit?: number
  }

  /**
   * PaymentMapping without action
   */
  export type PaymentMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMapping
     */
    select?: PaymentMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMapping
     */
    omit?: PaymentMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMappingInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderId: string | null
    userId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.TransactionStatus | null
    reference: string | null
    qrCode: string | null
    qrCodeImage: string | null
    notes: string | null
    servedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderId: string | null
    userId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    status: $Enums.TransactionStatus | null
    reference: string | null
    qrCode: string | null
    qrCodeImage: string | null
    notes: string | null
    servedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    orderId: number
    userId: number
    amount: number
    paymentMethod: number
    status: number
    reference: number
    qrCode: number
    qrCodeImage: number
    notes: number
    servedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    userId?: true
    amount?: true
    paymentMethod?: true
    status?: true
    reference?: true
    qrCode?: true
    qrCodeImage?: true
    notes?: true
    servedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    userId?: true
    amount?: true
    paymentMethod?: true
    status?: true
    reference?: true
    qrCode?: true
    qrCodeImage?: true
    notes?: true
    servedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    userId?: true
    amount?: true
    paymentMethod?: true
    status?: true
    reference?: true
    qrCode?: true
    qrCodeImage?: true
    notes?: true
    servedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    tenantId: string
    orderId: string
    userId: string
    amount: Decimal
    paymentMethod: $Enums.PaymentMethod
    status: $Enums.TransactionStatus
    reference: string | null
    qrCode: string | null
    qrCodeImage: string | null
    notes: string | null
    servedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    userId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    status?: boolean
    reference?: boolean
    qrCode?: boolean
    qrCodeImage?: boolean
    notes?: boolean
    servedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    userId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    status?: boolean
    reference?: boolean
    qrCode?: boolean
    qrCodeImage?: boolean
    notes?: boolean
    servedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    userId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    status?: boolean
    reference?: boolean
    qrCode?: boolean
    qrCodeImage?: boolean
    notes?: boolean
    servedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    userId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    status?: boolean
    reference?: boolean
    qrCode?: boolean
    qrCodeImage?: boolean
    notes?: boolean
    servedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "orderId" | "userId" | "amount" | "paymentMethod" | "status" | "reference" | "qrCode" | "qrCodeImage" | "notes" | "servedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      orderId: string
      userId: string
      amount: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      status: $Enums.TransactionStatus
      reference: string | null
      qrCode: string | null
      qrCodeImage: string | null
      notes: string | null
      servedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly tenantId: FieldRef<"Transaction", 'String'>
    readonly orderId: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly qrCode: FieldRef<"Transaction", 'String'>
    readonly qrCodeImage: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly servedBy: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerSumAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    birthday: Date | null
    loyaltyPoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    birthday: Date | null
    loyaltyPoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    phone: number
    address: number
    birthday: number
    loyaltyPoints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerSumAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birthday?: true
    loyaltyPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birthday?: true
    loyaltyPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birthday?: true
    loyaltyPoints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    birthday: Date | null
    loyaltyPoints: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthday?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthday?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthday?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthday?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "phone" | "address" | "birthday" | "loyaltyPoints" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      birthday: Date | null
      loyaltyPoints: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly tenantId: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly birthday: FieldRef<"Customer", 'DateTime'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    discountValue: Decimal | null
    loyaltyPoints: number | null
  }

  export type MemberSumAggregateOutputType = {
    discountValue: Decimal | null
    loyaltyPoints: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    memberCode: string | null
    discountType: string | null
    discountValue: Decimal | null
    isActive: boolean | null
    loyaltyPoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    memberCode: string | null
    discountType: string | null
    discountValue: Decimal | null
    isActive: boolean | null
    loyaltyPoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    phone: number
    address: number
    memberCode: number
    discountType: number
    discountValue: number
    isActive: number
    loyaltyPoints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    discountValue?: true
    loyaltyPoints?: true
  }

  export type MemberSumAggregateInputType = {
    discountValue?: true
    loyaltyPoints?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    memberCode?: true
    discountType?: true
    discountValue?: true
    isActive?: true
    loyaltyPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    memberCode?: true
    discountType?: true
    discountValue?: true
    isActive?: true
    loyaltyPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    memberCode?: true
    discountType?: true
    discountValue?: true
    isActive?: true
    loyaltyPoints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string | null
    phone: string
    address: string | null
    memberCode: string
    discountType: string | null
    discountValue: Decimal | null
    isActive: boolean
    loyaltyPoints: number
    createdAt: Date
    updatedAt: Date
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    memberCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    isActive?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Member$ordersArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    memberCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    isActive?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    memberCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    isActive?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    memberCode?: boolean
    discountType?: boolean
    discountValue?: boolean
    isActive?: boolean
    loyaltyPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "phone" | "address" | "memberCode" | "discountType" | "discountValue" | "isActive" | "loyaltyPoints" | "createdAt" | "updatedAt", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Member$ordersArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string | null
      phone: string
      address: string | null
      memberCode: string
      discountType: string | null
      discountValue: Prisma.Decimal | null
      isActive: boolean
      loyaltyPoints: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Member$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Member$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly tenantId: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly phone: FieldRef<"Member", 'String'>
    readonly address: FieldRef<"Member", 'String'>
    readonly memberCode: FieldRef<"Member", 'String'>
    readonly discountType: FieldRef<"Member", 'String'>
    readonly discountValue: FieldRef<"Member", 'Decimal'>
    readonly isActive: FieldRef<"Member", 'Boolean'>
    readonly loyaltyPoints: FieldRef<"Member", 'Int'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.orders
   */
  export type Member$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    position: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    position: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    phone: number
    position: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    position?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    position?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    position?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string
    phone: string | null
    position: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "phone" | "position" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string
      phone: string | null
      position: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly tenantId: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Outlet
   */

  export type AggregateOutlet = {
    _count: OutletCountAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  export type OutletMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    address: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutletMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    address: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutletCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    address: number
    phone: number
    isActive: number
    shiftConfig: number
    operatingHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutletMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutletMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutletCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    phone?: true
    isActive?: true
    shiftConfig?: true
    operatingHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outlet to aggregate.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Outlets
    **/
    _count?: true | OutletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletMaxAggregateInputType
  }

  export type GetOutletAggregateType<T extends OutletAggregateArgs> = {
        [P in keyof T & keyof AggregateOutlet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutlet[P]>
      : GetScalarType<T[P], AggregateOutlet[P]>
  }




  export type OutletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutletWhereInput
    orderBy?: OutletOrderByWithAggregationInput | OutletOrderByWithAggregationInput[]
    by: OutletScalarFieldEnum[] | OutletScalarFieldEnum
    having?: OutletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletCountAggregateInputType | true
    _min?: OutletMinAggregateInputType
    _max?: OutletMaxAggregateInputType
  }

  export type OutletGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    address: string | null
    phone: string | null
    isActive: boolean
    shiftConfig: JsonValue | null
    operatingHours: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OutletCountAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  type GetOutletGroupByPayload<T extends OutletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletGroupByOutputType[P]>
            : GetScalarType<T[P], OutletGroupByOutputType[P]>
        }
      >
    >


  export type OutletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    isActive?: boolean
    shiftConfig?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Outlet$ordersArgs<ExtArgs>
    storeShifts?: boolean | Outlet$storeShiftsArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    isActive?: boolean
    shiftConfig?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    isActive?: boolean
    shiftConfig?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outlet"]>

  export type OutletSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    isActive?: boolean
    shiftConfig?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "address" | "phone" | "isActive" | "shiftConfig" | "operatingHours" | "createdAt" | "updatedAt", ExtArgs["result"]["outlet"]>
  export type OutletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Outlet$ordersArgs<ExtArgs>
    storeShifts?: boolean | Outlet$storeShiftsArgs<ExtArgs>
    _count?: boolean | OutletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type OutletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $OutletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Outlet"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      storeShifts: Prisma.$StoreShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      address: string | null
      phone: string | null
      isActive: boolean
      shiftConfig: Prisma.JsonValue | null
      operatingHours: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outlet"]>
    composites: {}
  }

  type OutletGetPayload<S extends boolean | null | undefined | OutletDefaultArgs> = $Result.GetResult<Prisma.$OutletPayload, S>

  type OutletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutletCountAggregateInputType | true
    }

  export interface OutletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Outlet'], meta: { name: 'Outlet' } }
    /**
     * Find zero or one Outlet that matches the filter.
     * @param {OutletFindUniqueArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutletFindUniqueArgs>(args: SelectSubset<T, OutletFindUniqueArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Outlet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutletFindUniqueOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutletFindUniqueOrThrowArgs>(args: SelectSubset<T, OutletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outlet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindFirstArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutletFindFirstArgs>(args?: SelectSubset<T, OutletFindFirstArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outlet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindFirstOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutletFindFirstOrThrowArgs>(args?: SelectSubset<T, OutletFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Outlets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outlets
     * const outlets = await prisma.outlet.findMany()
     * 
     * // Get first 10 Outlets
     * const outlets = await prisma.outlet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletWithIdOnly = await prisma.outlet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutletFindManyArgs>(args?: SelectSubset<T, OutletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Outlet.
     * @param {OutletCreateArgs} args - Arguments to create a Outlet.
     * @example
     * // Create one Outlet
     * const Outlet = await prisma.outlet.create({
     *   data: {
     *     // ... data to create a Outlet
     *   }
     * })
     * 
     */
    create<T extends OutletCreateArgs>(args: SelectSubset<T, OutletCreateArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Outlets.
     * @param {OutletCreateManyArgs} args - Arguments to create many Outlets.
     * @example
     * // Create many Outlets
     * const outlet = await prisma.outlet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutletCreateManyArgs>(args?: SelectSubset<T, OutletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Outlets and returns the data saved in the database.
     * @param {OutletCreateManyAndReturnArgs} args - Arguments to create many Outlets.
     * @example
     * // Create many Outlets
     * const outlet = await prisma.outlet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Outlets and only return the `id`
     * const outletWithIdOnly = await prisma.outlet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutletCreateManyAndReturnArgs>(args?: SelectSubset<T, OutletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Outlet.
     * @param {OutletDeleteArgs} args - Arguments to delete one Outlet.
     * @example
     * // Delete one Outlet
     * const Outlet = await prisma.outlet.delete({
     *   where: {
     *     // ... filter to delete one Outlet
     *   }
     * })
     * 
     */
    delete<T extends OutletDeleteArgs>(args: SelectSubset<T, OutletDeleteArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Outlet.
     * @param {OutletUpdateArgs} args - Arguments to update one Outlet.
     * @example
     * // Update one Outlet
     * const outlet = await prisma.outlet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutletUpdateArgs>(args: SelectSubset<T, OutletUpdateArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Outlets.
     * @param {OutletDeleteManyArgs} args - Arguments to filter Outlets to delete.
     * @example
     * // Delete a few Outlets
     * const { count } = await prisma.outlet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutletDeleteManyArgs>(args?: SelectSubset<T, OutletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutletUpdateManyArgs>(args: SelectSubset<T, OutletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets and returns the data updated in the database.
     * @param {OutletUpdateManyAndReturnArgs} args - Arguments to update many Outlets.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Outlets and only return the `id`
     * const outletWithIdOnly = await prisma.outlet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutletUpdateManyAndReturnArgs>(args: SelectSubset<T, OutletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Outlet.
     * @param {OutletUpsertArgs} args - Arguments to update or create a Outlet.
     * @example
     * // Update or create a Outlet
     * const outlet = await prisma.outlet.upsert({
     *   create: {
     *     // ... data to create a Outlet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outlet we want to update
     *   }
     * })
     */
    upsert<T extends OutletUpsertArgs>(args: SelectSubset<T, OutletUpsertArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletCountArgs} args - Arguments to filter Outlets to count.
     * @example
     * // Count the number of Outlets
     * const count = await prisma.outlet.count({
     *   where: {
     *     // ... the filter for the Outlets we want to count
     *   }
     * })
    **/
    count<T extends OutletCountArgs>(
      args?: Subset<T, OutletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletAggregateArgs>(args: Subset<T, OutletAggregateArgs>): Prisma.PrismaPromise<GetOutletAggregateType<T>>

    /**
     * Group by Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutletGroupByArgs['orderBy'] }
        : { orderBy?: OutletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Outlet model
   */
  readonly fields: OutletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Outlet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Outlet$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storeShifts<T extends Outlet$storeShiftsArgs<ExtArgs> = {}>(args?: Subset<T, Outlet$storeShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Outlet model
   */
  interface OutletFieldRefs {
    readonly id: FieldRef<"Outlet", 'String'>
    readonly tenantId: FieldRef<"Outlet", 'String'>
    readonly name: FieldRef<"Outlet", 'String'>
    readonly address: FieldRef<"Outlet", 'String'>
    readonly phone: FieldRef<"Outlet", 'String'>
    readonly isActive: FieldRef<"Outlet", 'Boolean'>
    readonly shiftConfig: FieldRef<"Outlet", 'Json'>
    readonly operatingHours: FieldRef<"Outlet", 'Json'>
    readonly createdAt: FieldRef<"Outlet", 'DateTime'>
    readonly updatedAt: FieldRef<"Outlet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Outlet findUnique
   */
  export type OutletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet findUniqueOrThrow
   */
  export type OutletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet findFirst
   */
  export type OutletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet findFirstOrThrow
   */
  export type OutletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlet to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outlets.
     */
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet findMany
   */
  export type OutletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter, which Outlets to fetch.
     */
    where?: OutletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outlets to fetch.
     */
    orderBy?: OutletOrderByWithRelationInput | OutletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Outlets.
     */
    cursor?: OutletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outlets.
     */
    skip?: number
    distinct?: OutletScalarFieldEnum | OutletScalarFieldEnum[]
  }

  /**
   * Outlet create
   */
  export type OutletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The data needed to create a Outlet.
     */
    data: XOR<OutletCreateInput, OutletUncheckedCreateInput>
  }

  /**
   * Outlet createMany
   */
  export type OutletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Outlets.
     */
    data: OutletCreateManyInput | OutletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Outlet createManyAndReturn
   */
  export type OutletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * The data used to create many Outlets.
     */
    data: OutletCreateManyInput | OutletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outlet update
   */
  export type OutletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The data needed to update a Outlet.
     */
    data: XOR<OutletUpdateInput, OutletUncheckedUpdateInput>
    /**
     * Choose, which Outlet to update.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet updateMany
   */
  export type OutletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Outlets.
     */
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyInput>
    /**
     * Filter which Outlets to update
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to update.
     */
    limit?: number
  }

  /**
   * Outlet updateManyAndReturn
   */
  export type OutletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * The data used to update Outlets.
     */
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyInput>
    /**
     * Filter which Outlets to update
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outlet upsert
   */
  export type OutletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * The filter to search for the Outlet to update in case it exists.
     */
    where: OutletWhereUniqueInput
    /**
     * In case the Outlet found by the `where` argument doesn't exist, create a new Outlet with this data.
     */
    create: XOR<OutletCreateInput, OutletUncheckedCreateInput>
    /**
     * In case the Outlet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutletUpdateInput, OutletUncheckedUpdateInput>
  }

  /**
   * Outlet delete
   */
  export type OutletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
    /**
     * Filter which Outlet to delete.
     */
    where: OutletWhereUniqueInput
  }

  /**
   * Outlet deleteMany
   */
  export type OutletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outlets to delete
     */
    where?: OutletWhereInput
    /**
     * Limit how many Outlets to delete.
     */
    limit?: number
  }

  /**
   * Outlet.orders
   */
  export type Outlet$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Outlet.storeShifts
   */
  export type Outlet$storeShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    cursor?: StoreShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreShiftScalarFieldEnum | StoreShiftScalarFieldEnum[]
  }

  /**
   * Outlet without action
   */
  export type OutletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outlet
     */
    select?: OutletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outlet
     */
    omit?: OutletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutletInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    period: string | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    period: string | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    period: number
    data: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    period?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    period?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    period?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    tenantId: string
    type: string
    period: string
    data: JsonValue
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "type" | "period" | "data" | "createdAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: string
      period: string
      data: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly tenantId: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly period: FieldRef<"Report", 'String'>
    readonly data: FieldRef<"Report", 'Json'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model TenantAddon
   */

  export type AggregateTenantAddon = {
    _count: TenantAddonCountAggregateOutputType | null
    _avg: TenantAddonAvgAggregateOutputType | null
    _sum: TenantAddonSumAggregateOutputType | null
    _min: TenantAddonMinAggregateOutputType | null
    _max: TenantAddonMaxAggregateOutputType | null
  }

  export type TenantAddonAvgAggregateOutputType = {
    limit: number | null
    currentUsage: number | null
  }

  export type TenantAddonSumAggregateOutputType = {
    limit: number | null
    currentUsage: number | null
  }

  export type TenantAddonMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    addonId: string | null
    addonName: string | null
    addonType: string | null
    status: string | null
    limit: number | null
    currentUsage: number | null
    subscribedAt: Date | null
    expiresAt: Date | null
    purchasedBy: string | null
  }

  export type TenantAddonMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    addonId: string | null
    addonName: string | null
    addonType: string | null
    status: string | null
    limit: number | null
    currentUsage: number | null
    subscribedAt: Date | null
    expiresAt: Date | null
    purchasedBy: string | null
  }

  export type TenantAddonCountAggregateOutputType = {
    id: number
    tenantId: number
    addonId: number
    addonName: number
    addonType: number
    status: number
    limit: number
    currentUsage: number
    subscribedAt: number
    expiresAt: number
    config: number
    purchasedBy: number
    _all: number
  }


  export type TenantAddonAvgAggregateInputType = {
    limit?: true
    currentUsage?: true
  }

  export type TenantAddonSumAggregateInputType = {
    limit?: true
    currentUsage?: true
  }

  export type TenantAddonMinAggregateInputType = {
    id?: true
    tenantId?: true
    addonId?: true
    addonName?: true
    addonType?: true
    status?: true
    limit?: true
    currentUsage?: true
    subscribedAt?: true
    expiresAt?: true
    purchasedBy?: true
  }

  export type TenantAddonMaxAggregateInputType = {
    id?: true
    tenantId?: true
    addonId?: true
    addonName?: true
    addonType?: true
    status?: true
    limit?: true
    currentUsage?: true
    subscribedAt?: true
    expiresAt?: true
    purchasedBy?: true
  }

  export type TenantAddonCountAggregateInputType = {
    id?: true
    tenantId?: true
    addonId?: true
    addonName?: true
    addonType?: true
    status?: true
    limit?: true
    currentUsage?: true
    subscribedAt?: true
    expiresAt?: true
    config?: true
    purchasedBy?: true
    _all?: true
  }

  export type TenantAddonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantAddon to aggregate.
     */
    where?: TenantAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantAddons to fetch.
     */
    orderBy?: TenantAddonOrderByWithRelationInput | TenantAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantAddons
    **/
    _count?: true | TenantAddonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAddonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantAddonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantAddonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantAddonMaxAggregateInputType
  }

  export type GetTenantAddonAggregateType<T extends TenantAddonAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantAddon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantAddon[P]>
      : GetScalarType<T[P], AggregateTenantAddon[P]>
  }




  export type TenantAddonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantAddonWhereInput
    orderBy?: TenantAddonOrderByWithAggregationInput | TenantAddonOrderByWithAggregationInput[]
    by: TenantAddonScalarFieldEnum[] | TenantAddonScalarFieldEnum
    having?: TenantAddonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantAddonCountAggregateInputType | true
    _avg?: TenantAddonAvgAggregateInputType
    _sum?: TenantAddonSumAggregateInputType
    _min?: TenantAddonMinAggregateInputType
    _max?: TenantAddonMaxAggregateInputType
  }

  export type TenantAddonGroupByOutputType = {
    id: string
    tenantId: string
    addonId: string
    addonName: string
    addonType: string
    status: string
    limit: number | null
    currentUsage: number
    subscribedAt: Date
    expiresAt: Date | null
    config: JsonValue | null
    purchasedBy: string
    _count: TenantAddonCountAggregateOutputType | null
    _avg: TenantAddonAvgAggregateOutputType | null
    _sum: TenantAddonSumAggregateOutputType | null
    _min: TenantAddonMinAggregateOutputType | null
    _max: TenantAddonMaxAggregateOutputType | null
  }

  type GetTenantAddonGroupByPayload<T extends TenantAddonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantAddonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantAddonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantAddonGroupByOutputType[P]>
            : GetScalarType<T[P], TenantAddonGroupByOutputType[P]>
        }
      >
    >


  export type TenantAddonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    addonId?: boolean
    addonName?: boolean
    addonType?: boolean
    status?: boolean
    limit?: boolean
    currentUsage?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    config?: boolean
    purchasedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantAddon"]>

  export type TenantAddonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    addonId?: boolean
    addonName?: boolean
    addonType?: boolean
    status?: boolean
    limit?: boolean
    currentUsage?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    config?: boolean
    purchasedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantAddon"]>

  export type TenantAddonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    addonId?: boolean
    addonName?: boolean
    addonType?: boolean
    status?: boolean
    limit?: boolean
    currentUsage?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    config?: boolean
    purchasedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantAddon"]>

  export type TenantAddonSelectScalar = {
    id?: boolean
    tenantId?: boolean
    addonId?: boolean
    addonName?: boolean
    addonType?: boolean
    status?: boolean
    limit?: boolean
    currentUsage?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    config?: boolean
    purchasedBy?: boolean
  }

  export type TenantAddonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "addonId" | "addonName" | "addonType" | "status" | "limit" | "currentUsage" | "subscribedAt" | "expiresAt" | "config" | "purchasedBy", ExtArgs["result"]["tenantAddon"]>
  export type TenantAddonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantAddonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantAddonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantAddonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantAddon"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      addonId: string
      addonName: string
      addonType: string
      status: string
      limit: number | null
      currentUsage: number
      subscribedAt: Date
      expiresAt: Date | null
      config: Prisma.JsonValue | null
      purchasedBy: string
    }, ExtArgs["result"]["tenantAddon"]>
    composites: {}
  }

  type TenantAddonGetPayload<S extends boolean | null | undefined | TenantAddonDefaultArgs> = $Result.GetResult<Prisma.$TenantAddonPayload, S>

  type TenantAddonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantAddonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantAddonCountAggregateInputType | true
    }

  export interface TenantAddonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantAddon'], meta: { name: 'TenantAddon' } }
    /**
     * Find zero or one TenantAddon that matches the filter.
     * @param {TenantAddonFindUniqueArgs} args - Arguments to find a TenantAddon
     * @example
     * // Get one TenantAddon
     * const tenantAddon = await prisma.tenantAddon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantAddonFindUniqueArgs>(args: SelectSubset<T, TenantAddonFindUniqueArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantAddon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantAddonFindUniqueOrThrowArgs} args - Arguments to find a TenantAddon
     * @example
     * // Get one TenantAddon
     * const tenantAddon = await prisma.tenantAddon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantAddonFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantAddonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantAddon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonFindFirstArgs} args - Arguments to find a TenantAddon
     * @example
     * // Get one TenantAddon
     * const tenantAddon = await prisma.tenantAddon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantAddonFindFirstArgs>(args?: SelectSubset<T, TenantAddonFindFirstArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantAddon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonFindFirstOrThrowArgs} args - Arguments to find a TenantAddon
     * @example
     * // Get one TenantAddon
     * const tenantAddon = await prisma.tenantAddon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantAddonFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantAddonFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantAddons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantAddons
     * const tenantAddons = await prisma.tenantAddon.findMany()
     * 
     * // Get first 10 TenantAddons
     * const tenantAddons = await prisma.tenantAddon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantAddonWithIdOnly = await prisma.tenantAddon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantAddonFindManyArgs>(args?: SelectSubset<T, TenantAddonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantAddon.
     * @param {TenantAddonCreateArgs} args - Arguments to create a TenantAddon.
     * @example
     * // Create one TenantAddon
     * const TenantAddon = await prisma.tenantAddon.create({
     *   data: {
     *     // ... data to create a TenantAddon
     *   }
     * })
     * 
     */
    create<T extends TenantAddonCreateArgs>(args: SelectSubset<T, TenantAddonCreateArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantAddons.
     * @param {TenantAddonCreateManyArgs} args - Arguments to create many TenantAddons.
     * @example
     * // Create many TenantAddons
     * const tenantAddon = await prisma.tenantAddon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantAddonCreateManyArgs>(args?: SelectSubset<T, TenantAddonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantAddons and returns the data saved in the database.
     * @param {TenantAddonCreateManyAndReturnArgs} args - Arguments to create many TenantAddons.
     * @example
     * // Create many TenantAddons
     * const tenantAddon = await prisma.tenantAddon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantAddons and only return the `id`
     * const tenantAddonWithIdOnly = await prisma.tenantAddon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantAddonCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantAddonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantAddon.
     * @param {TenantAddonDeleteArgs} args - Arguments to delete one TenantAddon.
     * @example
     * // Delete one TenantAddon
     * const TenantAddon = await prisma.tenantAddon.delete({
     *   where: {
     *     // ... filter to delete one TenantAddon
     *   }
     * })
     * 
     */
    delete<T extends TenantAddonDeleteArgs>(args: SelectSubset<T, TenantAddonDeleteArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantAddon.
     * @param {TenantAddonUpdateArgs} args - Arguments to update one TenantAddon.
     * @example
     * // Update one TenantAddon
     * const tenantAddon = await prisma.tenantAddon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantAddonUpdateArgs>(args: SelectSubset<T, TenantAddonUpdateArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantAddons.
     * @param {TenantAddonDeleteManyArgs} args - Arguments to filter TenantAddons to delete.
     * @example
     * // Delete a few TenantAddons
     * const { count } = await prisma.tenantAddon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantAddonDeleteManyArgs>(args?: SelectSubset<T, TenantAddonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantAddons
     * const tenantAddon = await prisma.tenantAddon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantAddonUpdateManyArgs>(args: SelectSubset<T, TenantAddonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantAddons and returns the data updated in the database.
     * @param {TenantAddonUpdateManyAndReturnArgs} args - Arguments to update many TenantAddons.
     * @example
     * // Update many TenantAddons
     * const tenantAddon = await prisma.tenantAddon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantAddons and only return the `id`
     * const tenantAddonWithIdOnly = await prisma.tenantAddon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantAddonUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantAddonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantAddon.
     * @param {TenantAddonUpsertArgs} args - Arguments to update or create a TenantAddon.
     * @example
     * // Update or create a TenantAddon
     * const tenantAddon = await prisma.tenantAddon.upsert({
     *   create: {
     *     // ... data to create a TenantAddon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantAddon we want to update
     *   }
     * })
     */
    upsert<T extends TenantAddonUpsertArgs>(args: SelectSubset<T, TenantAddonUpsertArgs<ExtArgs>>): Prisma__TenantAddonClient<$Result.GetResult<Prisma.$TenantAddonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonCountArgs} args - Arguments to filter TenantAddons to count.
     * @example
     * // Count the number of TenantAddons
     * const count = await prisma.tenantAddon.count({
     *   where: {
     *     // ... the filter for the TenantAddons we want to count
     *   }
     * })
    **/
    count<T extends TenantAddonCountArgs>(
      args?: Subset<T, TenantAddonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantAddonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantAddon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAddonAggregateArgs>(args: Subset<T, TenantAddonAggregateArgs>): Prisma.PrismaPromise<GetTenantAddonAggregateType<T>>

    /**
     * Group by TenantAddon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAddonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantAddonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantAddonGroupByArgs['orderBy'] }
        : { orderBy?: TenantAddonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantAddonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantAddonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantAddon model
   */
  readonly fields: TenantAddonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantAddon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantAddonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantAddon model
   */
  interface TenantAddonFieldRefs {
    readonly id: FieldRef<"TenantAddon", 'String'>
    readonly tenantId: FieldRef<"TenantAddon", 'String'>
    readonly addonId: FieldRef<"TenantAddon", 'String'>
    readonly addonName: FieldRef<"TenantAddon", 'String'>
    readonly addonType: FieldRef<"TenantAddon", 'String'>
    readonly status: FieldRef<"TenantAddon", 'String'>
    readonly limit: FieldRef<"TenantAddon", 'Int'>
    readonly currentUsage: FieldRef<"TenantAddon", 'Int'>
    readonly subscribedAt: FieldRef<"TenantAddon", 'DateTime'>
    readonly expiresAt: FieldRef<"TenantAddon", 'DateTime'>
    readonly config: FieldRef<"TenantAddon", 'Json'>
    readonly purchasedBy: FieldRef<"TenantAddon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TenantAddon findUnique
   */
  export type TenantAddonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * Filter, which TenantAddon to fetch.
     */
    where: TenantAddonWhereUniqueInput
  }

  /**
   * TenantAddon findUniqueOrThrow
   */
  export type TenantAddonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * Filter, which TenantAddon to fetch.
     */
    where: TenantAddonWhereUniqueInput
  }

  /**
   * TenantAddon findFirst
   */
  export type TenantAddonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * Filter, which TenantAddon to fetch.
     */
    where?: TenantAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantAddons to fetch.
     */
    orderBy?: TenantAddonOrderByWithRelationInput | TenantAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantAddons.
     */
    cursor?: TenantAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantAddons.
     */
    distinct?: TenantAddonScalarFieldEnum | TenantAddonScalarFieldEnum[]
  }

  /**
   * TenantAddon findFirstOrThrow
   */
  export type TenantAddonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * Filter, which TenantAddon to fetch.
     */
    where?: TenantAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantAddons to fetch.
     */
    orderBy?: TenantAddonOrderByWithRelationInput | TenantAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantAddons.
     */
    cursor?: TenantAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantAddons.
     */
    distinct?: TenantAddonScalarFieldEnum | TenantAddonScalarFieldEnum[]
  }

  /**
   * TenantAddon findMany
   */
  export type TenantAddonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * Filter, which TenantAddons to fetch.
     */
    where?: TenantAddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantAddons to fetch.
     */
    orderBy?: TenantAddonOrderByWithRelationInput | TenantAddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantAddons.
     */
    cursor?: TenantAddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantAddons.
     */
    skip?: number
    distinct?: TenantAddonScalarFieldEnum | TenantAddonScalarFieldEnum[]
  }

  /**
   * TenantAddon create
   */
  export type TenantAddonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantAddon.
     */
    data: XOR<TenantAddonCreateInput, TenantAddonUncheckedCreateInput>
  }

  /**
   * TenantAddon createMany
   */
  export type TenantAddonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantAddons.
     */
    data: TenantAddonCreateManyInput | TenantAddonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantAddon createManyAndReturn
   */
  export type TenantAddonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * The data used to create many TenantAddons.
     */
    data: TenantAddonCreateManyInput | TenantAddonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantAddon update
   */
  export type TenantAddonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantAddon.
     */
    data: XOR<TenantAddonUpdateInput, TenantAddonUncheckedUpdateInput>
    /**
     * Choose, which TenantAddon to update.
     */
    where: TenantAddonWhereUniqueInput
  }

  /**
   * TenantAddon updateMany
   */
  export type TenantAddonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantAddons.
     */
    data: XOR<TenantAddonUpdateManyMutationInput, TenantAddonUncheckedUpdateManyInput>
    /**
     * Filter which TenantAddons to update
     */
    where?: TenantAddonWhereInput
    /**
     * Limit how many TenantAddons to update.
     */
    limit?: number
  }

  /**
   * TenantAddon updateManyAndReturn
   */
  export type TenantAddonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * The data used to update TenantAddons.
     */
    data: XOR<TenantAddonUpdateManyMutationInput, TenantAddonUncheckedUpdateManyInput>
    /**
     * Filter which TenantAddons to update
     */
    where?: TenantAddonWhereInput
    /**
     * Limit how many TenantAddons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantAddon upsert
   */
  export type TenantAddonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantAddon to update in case it exists.
     */
    where: TenantAddonWhereUniqueInput
    /**
     * In case the TenantAddon found by the `where` argument doesn't exist, create a new TenantAddon with this data.
     */
    create: XOR<TenantAddonCreateInput, TenantAddonUncheckedCreateInput>
    /**
     * In case the TenantAddon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantAddonUpdateInput, TenantAddonUncheckedUpdateInput>
  }

  /**
   * TenantAddon delete
   */
  export type TenantAddonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
    /**
     * Filter which TenantAddon to delete.
     */
    where: TenantAddonWhereUniqueInput
  }

  /**
   * TenantAddon deleteMany
   */
  export type TenantAddonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantAddons to delete
     */
    where?: TenantAddonWhereInput
    /**
     * Limit how many TenantAddons to delete.
     */
    limit?: number
  }

  /**
   * TenantAddon without action
   */
  export type TenantAddonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantAddon
     */
    select?: TenantAddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantAddon
     */
    omit?: TenantAddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantAddonInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SubscriptionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    plan: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    amount: Decimal | null
    temporaryUpgrade: boolean | null
    previousPlan: string | null
    purchasedBy: string | null
    createdAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    plan: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    amount: Decimal | null
    temporaryUpgrade: boolean | null
    previousPlan: string | null
    purchasedBy: string | null
    createdAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    tenantId: number
    plan: number
    startDate: number
    endDate: number
    status: number
    amount: number
    temporaryUpgrade: number
    previousPlan: number
    purchasedBy: number
    createdAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    amount?: true
  }

  export type SubscriptionSumAggregateInputType = {
    amount?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    tenantId?: true
    plan?: true
    startDate?: true
    endDate?: true
    status?: true
    amount?: true
    temporaryUpgrade?: true
    previousPlan?: true
    purchasedBy?: true
    createdAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    plan?: true
    startDate?: true
    endDate?: true
    status?: true
    amount?: true
    temporaryUpgrade?: true
    previousPlan?: true
    purchasedBy?: true
    createdAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    tenantId?: true
    plan?: true
    startDate?: true
    endDate?: true
    status?: true
    amount?: true
    temporaryUpgrade?: true
    previousPlan?: true
    purchasedBy?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    tenantId: string
    plan: string
    startDate: Date
    endDate: Date
    status: string
    amount: Decimal
    temporaryUpgrade: boolean
    previousPlan: string | null
    purchasedBy: string
    createdAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    amount?: boolean
    temporaryUpgrade?: boolean
    previousPlan?: boolean
    purchasedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    history?: boolean | Subscription$historyArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    amount?: boolean
    temporaryUpgrade?: boolean
    previousPlan?: boolean
    purchasedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    amount?: boolean
    temporaryUpgrade?: boolean
    previousPlan?: boolean
    purchasedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    plan?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    amount?: boolean
    temporaryUpgrade?: boolean
    previousPlan?: boolean
    purchasedBy?: boolean
    createdAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "plan" | "startDate" | "endDate" | "status" | "amount" | "temporaryUpgrade" | "previousPlan" | "purchasedBy" | "createdAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    history?: boolean | Subscription$historyArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      history: Prisma.$SubscriptionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      plan: string
      startDate: Date
      endDate: Date
      status: string
      amount: Prisma.Decimal
      temporaryUpgrade: boolean
      previousPlan: string | null
      purchasedBy: string
      createdAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    history<T extends Subscription$historyArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly tenantId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly amount: FieldRef<"Subscription", 'Decimal'>
    readonly temporaryUpgrade: FieldRef<"Subscription", 'Boolean'>
    readonly previousPlan: FieldRef<"Subscription", 'String'>
    readonly purchasedBy: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.history
   */
  export type Subscription$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    cursor?: SubscriptionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionHistory
   */

  export type AggregateSubscriptionHistory = {
    _count: SubscriptionHistoryCountAggregateOutputType | null
    _avg: SubscriptionHistoryAvgAggregateOutputType | null
    _sum: SubscriptionHistorySumAggregateOutputType | null
    _min: SubscriptionHistoryMinAggregateOutputType | null
    _max: SubscriptionHistoryMaxAggregateOutputType | null
  }

  export type SubscriptionHistoryAvgAggregateOutputType = {
    price: Decimal | null
    durationDays: number | null
  }

  export type SubscriptionHistorySumAggregateOutputType = {
    price: Decimal | null
    durationDays: number | null
  }

  export type SubscriptionHistoryMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    tenantId: string | null
    planType: string | null
    startDate: Date | null
    endDate: Date | null
    price: Decimal | null
    durationDays: number | null
    isTemporary: boolean | null
    reverted: boolean | null
    createdAt: Date | null
  }

  export type SubscriptionHistoryMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    tenantId: string | null
    planType: string | null
    startDate: Date | null
    endDate: Date | null
    price: Decimal | null
    durationDays: number | null
    isTemporary: boolean | null
    reverted: boolean | null
    createdAt: Date | null
  }

  export type SubscriptionHistoryCountAggregateOutputType = {
    id: number
    subscriptionId: number
    tenantId: number
    planType: number
    startDate: number
    endDate: number
    price: number
    durationDays: number
    isTemporary: number
    reverted: number
    createdAt: number
    _all: number
  }


  export type SubscriptionHistoryAvgAggregateInputType = {
    price?: true
    durationDays?: true
  }

  export type SubscriptionHistorySumAggregateInputType = {
    price?: true
    durationDays?: true
  }

  export type SubscriptionHistoryMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    tenantId?: true
    planType?: true
    startDate?: true
    endDate?: true
    price?: true
    durationDays?: true
    isTemporary?: true
    reverted?: true
    createdAt?: true
  }

  export type SubscriptionHistoryMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    tenantId?: true
    planType?: true
    startDate?: true
    endDate?: true
    price?: true
    durationDays?: true
    isTemporary?: true
    reverted?: true
    createdAt?: true
  }

  export type SubscriptionHistoryCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    tenantId?: true
    planType?: true
    startDate?: true
    endDate?: true
    price?: true
    durationDays?: true
    isTemporary?: true
    reverted?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionHistory to aggregate.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionHistories
    **/
    _count?: true | SubscriptionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionHistoryMaxAggregateInputType
  }

  export type GetSubscriptionHistoryAggregateType<T extends SubscriptionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionHistory[P]>
      : GetScalarType<T[P], AggregateSubscriptionHistory[P]>
  }




  export type SubscriptionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionHistoryWhereInput
    orderBy?: SubscriptionHistoryOrderByWithAggregationInput | SubscriptionHistoryOrderByWithAggregationInput[]
    by: SubscriptionHistoryScalarFieldEnum[] | SubscriptionHistoryScalarFieldEnum
    having?: SubscriptionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionHistoryCountAggregateInputType | true
    _avg?: SubscriptionHistoryAvgAggregateInputType
    _sum?: SubscriptionHistorySumAggregateInputType
    _min?: SubscriptionHistoryMinAggregateInputType
    _max?: SubscriptionHistoryMaxAggregateInputType
  }

  export type SubscriptionHistoryGroupByOutputType = {
    id: string
    subscriptionId: string | null
    tenantId: string
    planType: string
    startDate: Date
    endDate: Date
    price: Decimal
    durationDays: number
    isTemporary: boolean
    reverted: boolean
    createdAt: Date
    _count: SubscriptionHistoryCountAggregateOutputType | null
    _avg: SubscriptionHistoryAvgAggregateOutputType | null
    _sum: SubscriptionHistorySumAggregateOutputType | null
    _min: SubscriptionHistoryMinAggregateOutputType | null
    _max: SubscriptionHistoryMaxAggregateOutputType | null
  }

  type GetSubscriptionHistoryGroupByPayload<T extends SubscriptionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    tenantId?: boolean
    planType?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    durationDays?: boolean
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionHistory$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionHistory"]>

  export type SubscriptionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    tenantId?: boolean
    planType?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    durationDays?: boolean
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionHistory$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionHistory"]>

  export type SubscriptionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    tenantId?: boolean
    planType?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    durationDays?: boolean
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionHistory$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionHistory"]>

  export type SubscriptionHistorySelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    tenantId?: boolean
    planType?: boolean
    startDate?: boolean
    endDate?: boolean
    price?: boolean
    durationDays?: boolean
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: boolean
  }

  export type SubscriptionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "tenantId" | "planType" | "startDate" | "endDate" | "price" | "durationDays" | "isTemporary" | "reverted" | "createdAt", ExtArgs["result"]["subscriptionHistory"]>
  export type SubscriptionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionHistory$subscriptionArgs<ExtArgs>
  }
  export type SubscriptionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionHistory$subscriptionArgs<ExtArgs>
  }
  export type SubscriptionHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionHistory$subscriptionArgs<ExtArgs>
  }

  export type $SubscriptionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionHistory"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string | null
      tenantId: string
      planType: string
      startDate: Date
      endDate: Date
      price: Prisma.Decimal
      durationDays: number
      isTemporary: boolean
      reverted: boolean
      createdAt: Date
    }, ExtArgs["result"]["subscriptionHistory"]>
    composites: {}
  }

  type SubscriptionHistoryGetPayload<S extends boolean | null | undefined | SubscriptionHistoryDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionHistoryPayload, S>

  type SubscriptionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionHistoryCountAggregateInputType | true
    }

  export interface SubscriptionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionHistory'], meta: { name: 'SubscriptionHistory' } }
    /**
     * Find zero or one SubscriptionHistory that matches the filter.
     * @param {SubscriptionHistoryFindUniqueArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionHistoryFindUniqueArgs>(args: SelectSubset<T, SubscriptionHistoryFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionHistoryFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryFindFirstArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionHistoryFindFirstArgs>(args?: SelectSubset<T, SubscriptionHistoryFindFirstArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryFindFirstOrThrowArgs} args - Arguments to find a SubscriptionHistory
     * @example
     * // Get one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionHistories
     * const subscriptionHistories = await prisma.subscriptionHistory.findMany()
     * 
     * // Get first 10 SubscriptionHistories
     * const subscriptionHistories = await prisma.subscriptionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionHistoryWithIdOnly = await prisma.subscriptionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionHistoryFindManyArgs>(args?: SelectSubset<T, SubscriptionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionHistory.
     * @param {SubscriptionHistoryCreateArgs} args - Arguments to create a SubscriptionHistory.
     * @example
     * // Create one SubscriptionHistory
     * const SubscriptionHistory = await prisma.subscriptionHistory.create({
     *   data: {
     *     // ... data to create a SubscriptionHistory
     *   }
     * })
     * 
     */
    create<T extends SubscriptionHistoryCreateArgs>(args: SelectSubset<T, SubscriptionHistoryCreateArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionHistories.
     * @param {SubscriptionHistoryCreateManyArgs} args - Arguments to create many SubscriptionHistories.
     * @example
     * // Create many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionHistoryCreateManyArgs>(args?: SelectSubset<T, SubscriptionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionHistories and returns the data saved in the database.
     * @param {SubscriptionHistoryCreateManyAndReturnArgs} args - Arguments to create many SubscriptionHistories.
     * @example
     * // Create many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionHistories and only return the `id`
     * const subscriptionHistoryWithIdOnly = await prisma.subscriptionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionHistory.
     * @param {SubscriptionHistoryDeleteArgs} args - Arguments to delete one SubscriptionHistory.
     * @example
     * // Delete one SubscriptionHistory
     * const SubscriptionHistory = await prisma.subscriptionHistory.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionHistory
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionHistoryDeleteArgs>(args: SelectSubset<T, SubscriptionHistoryDeleteArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionHistory.
     * @param {SubscriptionHistoryUpdateArgs} args - Arguments to update one SubscriptionHistory.
     * @example
     * // Update one SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionHistoryUpdateArgs>(args: SelectSubset<T, SubscriptionHistoryUpdateArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionHistories.
     * @param {SubscriptionHistoryDeleteManyArgs} args - Arguments to filter SubscriptionHistories to delete.
     * @example
     * // Delete a few SubscriptionHistories
     * const { count } = await prisma.subscriptionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionHistoryDeleteManyArgs>(args?: SelectSubset<T, SubscriptionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionHistoryUpdateManyArgs>(args: SelectSubset<T, SubscriptionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionHistories and returns the data updated in the database.
     * @param {SubscriptionHistoryUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionHistories.
     * @example
     * // Update many SubscriptionHistories
     * const subscriptionHistory = await prisma.subscriptionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionHistories and only return the `id`
     * const subscriptionHistoryWithIdOnly = await prisma.subscriptionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionHistory.
     * @param {SubscriptionHistoryUpsertArgs} args - Arguments to update or create a SubscriptionHistory.
     * @example
     * // Update or create a SubscriptionHistory
     * const subscriptionHistory = await prisma.subscriptionHistory.upsert({
     *   create: {
     *     // ... data to create a SubscriptionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionHistory we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionHistoryUpsertArgs>(args: SelectSubset<T, SubscriptionHistoryUpsertArgs<ExtArgs>>): Prisma__SubscriptionHistoryClient<$Result.GetResult<Prisma.$SubscriptionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryCountArgs} args - Arguments to filter SubscriptionHistories to count.
     * @example
     * // Count the number of SubscriptionHistories
     * const count = await prisma.subscriptionHistory.count({
     *   where: {
     *     // ... the filter for the SubscriptionHistories we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionHistoryCountArgs>(
      args?: Subset<T, SubscriptionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionHistoryAggregateArgs>(args: Subset<T, SubscriptionHistoryAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionHistoryAggregateType<T>>

    /**
     * Group by SubscriptionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionHistory model
   */
  readonly fields: SubscriptionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionHistory$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionHistory$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionHistory model
   */
  interface SubscriptionHistoryFieldRefs {
    readonly id: FieldRef<"SubscriptionHistory", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionHistory", 'String'>
    readonly tenantId: FieldRef<"SubscriptionHistory", 'String'>
    readonly planType: FieldRef<"SubscriptionHistory", 'String'>
    readonly startDate: FieldRef<"SubscriptionHistory", 'DateTime'>
    readonly endDate: FieldRef<"SubscriptionHistory", 'DateTime'>
    readonly price: FieldRef<"SubscriptionHistory", 'Decimal'>
    readonly durationDays: FieldRef<"SubscriptionHistory", 'Int'>
    readonly isTemporary: FieldRef<"SubscriptionHistory", 'Boolean'>
    readonly reverted: FieldRef<"SubscriptionHistory", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionHistory findUnique
   */
  export type SubscriptionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory findUniqueOrThrow
   */
  export type SubscriptionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory findFirst
   */
  export type SubscriptionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionHistories.
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionHistories.
     */
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * SubscriptionHistory findFirstOrThrow
   */
  export type SubscriptionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistory to fetch.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionHistories.
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionHistories.
     */
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * SubscriptionHistory findMany
   */
  export type SubscriptionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionHistories to fetch.
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionHistories to fetch.
     */
    orderBy?: SubscriptionHistoryOrderByWithRelationInput | SubscriptionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionHistories.
     */
    cursor?: SubscriptionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionHistories.
     */
    skip?: number
    distinct?: SubscriptionHistoryScalarFieldEnum | SubscriptionHistoryScalarFieldEnum[]
  }

  /**
   * SubscriptionHistory create
   */
  export type SubscriptionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionHistory.
     */
    data: XOR<SubscriptionHistoryCreateInput, SubscriptionHistoryUncheckedCreateInput>
  }

  /**
   * SubscriptionHistory createMany
   */
  export type SubscriptionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionHistories.
     */
    data: SubscriptionHistoryCreateManyInput | SubscriptionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionHistory createManyAndReturn
   */
  export type SubscriptionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionHistories.
     */
    data: SubscriptionHistoryCreateManyInput | SubscriptionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionHistory update
   */
  export type SubscriptionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionHistory.
     */
    data: XOR<SubscriptionHistoryUpdateInput, SubscriptionHistoryUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionHistory to update.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory updateMany
   */
  export type SubscriptionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionHistories.
     */
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionHistories to update
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * Limit how many SubscriptionHistories to update.
     */
    limit?: number
  }

  /**
   * SubscriptionHistory updateManyAndReturn
   */
  export type SubscriptionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionHistories.
     */
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionHistories to update
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * Limit how many SubscriptionHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionHistory upsert
   */
  export type SubscriptionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionHistory to update in case it exists.
     */
    where: SubscriptionHistoryWhereUniqueInput
    /**
     * In case the SubscriptionHistory found by the `where` argument doesn't exist, create a new SubscriptionHistory with this data.
     */
    create: XOR<SubscriptionHistoryCreateInput, SubscriptionHistoryUncheckedCreateInput>
    /**
     * In case the SubscriptionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionHistoryUpdateInput, SubscriptionHistoryUncheckedUpdateInput>
  }

  /**
   * SubscriptionHistory delete
   */
  export type SubscriptionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionHistory to delete.
     */
    where: SubscriptionHistoryWhereUniqueInput
  }

  /**
   * SubscriptionHistory deleteMany
   */
  export type SubscriptionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionHistories to delete
     */
    where?: SubscriptionHistoryWhereInput
    /**
     * Limit how many SubscriptionHistories to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionHistory.subscription
   */
  export type SubscriptionHistory$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * SubscriptionHistory without action
   */
  export type SubscriptionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionHistory
     */
    select?: SubscriptionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionHistory
     */
    omit?: SubscriptionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ReceiptTemplate
   */

  export type AggregateReceiptTemplate = {
    _count: ReceiptTemplateCountAggregateOutputType | null
    _min: ReceiptTemplateMinAggregateOutputType | null
    _max: ReceiptTemplateMaxAggregateOutputType | null
  }

  export type ReceiptTemplateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    templateType: string | null
    isDefault: boolean | null
    paperSize: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptTemplateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    templateType: string | null
    isDefault: boolean | null
    paperSize: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptTemplateCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    templateType: number
    isDefault: number
    paperSize: number
    header: number
    footer: number
    fields: number
    styles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceiptTemplateMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    templateType?: true
    isDefault?: true
    paperSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptTemplateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    templateType?: true
    isDefault?: true
    paperSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptTemplateCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    templateType?: true
    isDefault?: true
    paperSize?: true
    header?: true
    footer?: true
    fields?: true
    styles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceiptTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptTemplate to aggregate.
     */
    where?: ReceiptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptTemplates to fetch.
     */
    orderBy?: ReceiptTemplateOrderByWithRelationInput | ReceiptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceiptTemplates
    **/
    _count?: true | ReceiptTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptTemplateMaxAggregateInputType
  }

  export type GetReceiptTemplateAggregateType<T extends ReceiptTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptTemplate[P]>
      : GetScalarType<T[P], AggregateReceiptTemplate[P]>
  }




  export type ReceiptTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptTemplateWhereInput
    orderBy?: ReceiptTemplateOrderByWithAggregationInput | ReceiptTemplateOrderByWithAggregationInput[]
    by: ReceiptTemplateScalarFieldEnum[] | ReceiptTemplateScalarFieldEnum
    having?: ReceiptTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptTemplateCountAggregateInputType | true
    _min?: ReceiptTemplateMinAggregateInputType
    _max?: ReceiptTemplateMaxAggregateInputType
  }

  export type ReceiptTemplateGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    templateType: string
    isDefault: boolean
    paperSize: string
    header: JsonValue | null
    footer: JsonValue | null
    fields: JsonValue | null
    styles: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ReceiptTemplateCountAggregateOutputType | null
    _min: ReceiptTemplateMinAggregateOutputType | null
    _max: ReceiptTemplateMaxAggregateOutputType | null
  }

  type GetReceiptTemplateGroupByPayload<T extends ReceiptTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    templateType?: boolean
    isDefault?: boolean
    paperSize?: boolean
    header?: boolean
    footer?: boolean
    fields?: boolean
    styles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receiptTemplate"]>

  export type ReceiptTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    templateType?: boolean
    isDefault?: boolean
    paperSize?: boolean
    header?: boolean
    footer?: boolean
    fields?: boolean
    styles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receiptTemplate"]>

  export type ReceiptTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    templateType?: boolean
    isDefault?: boolean
    paperSize?: boolean
    header?: boolean
    footer?: boolean
    fields?: boolean
    styles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receiptTemplate"]>

  export type ReceiptTemplateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    templateType?: boolean
    isDefault?: boolean
    paperSize?: boolean
    header?: boolean
    footer?: boolean
    fields?: boolean
    styles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceiptTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "templateType" | "isDefault" | "paperSize" | "header" | "footer" | "fields" | "styles" | "createdAt" | "updatedAt", ExtArgs["result"]["receiptTemplate"]>
  export type ReceiptTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ReceiptTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ReceiptTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ReceiptTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceiptTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      templateType: string
      isDefault: boolean
      paperSize: string
      header: Prisma.JsonValue | null
      footer: Prisma.JsonValue | null
      fields: Prisma.JsonValue | null
      styles: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["receiptTemplate"]>
    composites: {}
  }

  type ReceiptTemplateGetPayload<S extends boolean | null | undefined | ReceiptTemplateDefaultArgs> = $Result.GetResult<Prisma.$ReceiptTemplatePayload, S>

  type ReceiptTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceiptTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptTemplateCountAggregateInputType | true
    }

  export interface ReceiptTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceiptTemplate'], meta: { name: 'ReceiptTemplate' } }
    /**
     * Find zero or one ReceiptTemplate that matches the filter.
     * @param {ReceiptTemplateFindUniqueArgs} args - Arguments to find a ReceiptTemplate
     * @example
     * // Get one ReceiptTemplate
     * const receiptTemplate = await prisma.receiptTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptTemplateFindUniqueArgs>(args: SelectSubset<T, ReceiptTemplateFindUniqueArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReceiptTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceiptTemplateFindUniqueOrThrowArgs} args - Arguments to find a ReceiptTemplate
     * @example
     * // Get one ReceiptTemplate
     * const receiptTemplate = await prisma.receiptTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateFindFirstArgs} args - Arguments to find a ReceiptTemplate
     * @example
     * // Get one ReceiptTemplate
     * const receiptTemplate = await prisma.receiptTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptTemplateFindFirstArgs>(args?: SelectSubset<T, ReceiptTemplateFindFirstArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceiptTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateFindFirstOrThrowArgs} args - Arguments to find a ReceiptTemplate
     * @example
     * // Get one ReceiptTemplate
     * const receiptTemplate = await prisma.receiptTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReceiptTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceiptTemplates
     * const receiptTemplates = await prisma.receiptTemplate.findMany()
     * 
     * // Get first 10 ReceiptTemplates
     * const receiptTemplates = await prisma.receiptTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptTemplateWithIdOnly = await prisma.receiptTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptTemplateFindManyArgs>(args?: SelectSubset<T, ReceiptTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReceiptTemplate.
     * @param {ReceiptTemplateCreateArgs} args - Arguments to create a ReceiptTemplate.
     * @example
     * // Create one ReceiptTemplate
     * const ReceiptTemplate = await prisma.receiptTemplate.create({
     *   data: {
     *     // ... data to create a ReceiptTemplate
     *   }
     * })
     * 
     */
    create<T extends ReceiptTemplateCreateArgs>(args: SelectSubset<T, ReceiptTemplateCreateArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReceiptTemplates.
     * @param {ReceiptTemplateCreateManyArgs} args - Arguments to create many ReceiptTemplates.
     * @example
     * // Create many ReceiptTemplates
     * const receiptTemplate = await prisma.receiptTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptTemplateCreateManyArgs>(args?: SelectSubset<T, ReceiptTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceiptTemplates and returns the data saved in the database.
     * @param {ReceiptTemplateCreateManyAndReturnArgs} args - Arguments to create many ReceiptTemplates.
     * @example
     * // Create many ReceiptTemplates
     * const receiptTemplate = await prisma.receiptTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceiptTemplates and only return the `id`
     * const receiptTemplateWithIdOnly = await prisma.receiptTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReceiptTemplate.
     * @param {ReceiptTemplateDeleteArgs} args - Arguments to delete one ReceiptTemplate.
     * @example
     * // Delete one ReceiptTemplate
     * const ReceiptTemplate = await prisma.receiptTemplate.delete({
     *   where: {
     *     // ... filter to delete one ReceiptTemplate
     *   }
     * })
     * 
     */
    delete<T extends ReceiptTemplateDeleteArgs>(args: SelectSubset<T, ReceiptTemplateDeleteArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReceiptTemplate.
     * @param {ReceiptTemplateUpdateArgs} args - Arguments to update one ReceiptTemplate.
     * @example
     * // Update one ReceiptTemplate
     * const receiptTemplate = await prisma.receiptTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptTemplateUpdateArgs>(args: SelectSubset<T, ReceiptTemplateUpdateArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReceiptTemplates.
     * @param {ReceiptTemplateDeleteManyArgs} args - Arguments to filter ReceiptTemplates to delete.
     * @example
     * // Delete a few ReceiptTemplates
     * const { count } = await prisma.receiptTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptTemplateDeleteManyArgs>(args?: SelectSubset<T, ReceiptTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceiptTemplates
     * const receiptTemplate = await prisma.receiptTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptTemplateUpdateManyArgs>(args: SelectSubset<T, ReceiptTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptTemplates and returns the data updated in the database.
     * @param {ReceiptTemplateUpdateManyAndReturnArgs} args - Arguments to update many ReceiptTemplates.
     * @example
     * // Update many ReceiptTemplates
     * const receiptTemplate = await prisma.receiptTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReceiptTemplates and only return the `id`
     * const receiptTemplateWithIdOnly = await prisma.receiptTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceiptTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceiptTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReceiptTemplate.
     * @param {ReceiptTemplateUpsertArgs} args - Arguments to update or create a ReceiptTemplate.
     * @example
     * // Update or create a ReceiptTemplate
     * const receiptTemplate = await prisma.receiptTemplate.upsert({
     *   create: {
     *     // ... data to create a ReceiptTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceiptTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptTemplateUpsertArgs>(args: SelectSubset<T, ReceiptTemplateUpsertArgs<ExtArgs>>): Prisma__ReceiptTemplateClient<$Result.GetResult<Prisma.$ReceiptTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReceiptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateCountArgs} args - Arguments to filter ReceiptTemplates to count.
     * @example
     * // Count the number of ReceiptTemplates
     * const count = await prisma.receiptTemplate.count({
     *   where: {
     *     // ... the filter for the ReceiptTemplates we want to count
     *   }
     * })
    **/
    count<T extends ReceiptTemplateCountArgs>(
      args?: Subset<T, ReceiptTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceiptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptTemplateAggregateArgs>(args: Subset<T, ReceiptTemplateAggregateArgs>): Prisma.PrismaPromise<GetReceiptTemplateAggregateType<T>>

    /**
     * Group by ReceiptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceiptTemplate model
   */
  readonly fields: ReceiptTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceiptTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceiptTemplate model
   */
  interface ReceiptTemplateFieldRefs {
    readonly id: FieldRef<"ReceiptTemplate", 'String'>
    readonly tenantId: FieldRef<"ReceiptTemplate", 'String'>
    readonly name: FieldRef<"ReceiptTemplate", 'String'>
    readonly templateType: FieldRef<"ReceiptTemplate", 'String'>
    readonly isDefault: FieldRef<"ReceiptTemplate", 'Boolean'>
    readonly paperSize: FieldRef<"ReceiptTemplate", 'String'>
    readonly header: FieldRef<"ReceiptTemplate", 'Json'>
    readonly footer: FieldRef<"ReceiptTemplate", 'Json'>
    readonly fields: FieldRef<"ReceiptTemplate", 'Json'>
    readonly styles: FieldRef<"ReceiptTemplate", 'Json'>
    readonly createdAt: FieldRef<"ReceiptTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ReceiptTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReceiptTemplate findUnique
   */
  export type ReceiptTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptTemplate to fetch.
     */
    where: ReceiptTemplateWhereUniqueInput
  }

  /**
   * ReceiptTemplate findUniqueOrThrow
   */
  export type ReceiptTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptTemplate to fetch.
     */
    where: ReceiptTemplateWhereUniqueInput
  }

  /**
   * ReceiptTemplate findFirst
   */
  export type ReceiptTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptTemplate to fetch.
     */
    where?: ReceiptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptTemplates to fetch.
     */
    orderBy?: ReceiptTemplateOrderByWithRelationInput | ReceiptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptTemplates.
     */
    cursor?: ReceiptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptTemplates.
     */
    distinct?: ReceiptTemplateScalarFieldEnum | ReceiptTemplateScalarFieldEnum[]
  }

  /**
   * ReceiptTemplate findFirstOrThrow
   */
  export type ReceiptTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptTemplate to fetch.
     */
    where?: ReceiptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptTemplates to fetch.
     */
    orderBy?: ReceiptTemplateOrderByWithRelationInput | ReceiptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptTemplates.
     */
    cursor?: ReceiptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptTemplates.
     */
    distinct?: ReceiptTemplateScalarFieldEnum | ReceiptTemplateScalarFieldEnum[]
  }

  /**
   * ReceiptTemplate findMany
   */
  export type ReceiptTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReceiptTemplates to fetch.
     */
    where?: ReceiptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptTemplates to fetch.
     */
    orderBy?: ReceiptTemplateOrderByWithRelationInput | ReceiptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceiptTemplates.
     */
    cursor?: ReceiptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptTemplates.
     */
    skip?: number
    distinct?: ReceiptTemplateScalarFieldEnum | ReceiptTemplateScalarFieldEnum[]
  }

  /**
   * ReceiptTemplate create
   */
  export type ReceiptTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceiptTemplate.
     */
    data: XOR<ReceiptTemplateCreateInput, ReceiptTemplateUncheckedCreateInput>
  }

  /**
   * ReceiptTemplate createMany
   */
  export type ReceiptTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceiptTemplates.
     */
    data: ReceiptTemplateCreateManyInput | ReceiptTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceiptTemplate createManyAndReturn
   */
  export type ReceiptTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ReceiptTemplates.
     */
    data: ReceiptTemplateCreateManyInput | ReceiptTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceiptTemplate update
   */
  export type ReceiptTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceiptTemplate.
     */
    data: XOR<ReceiptTemplateUpdateInput, ReceiptTemplateUncheckedUpdateInput>
    /**
     * Choose, which ReceiptTemplate to update.
     */
    where: ReceiptTemplateWhereUniqueInput
  }

  /**
   * ReceiptTemplate updateMany
   */
  export type ReceiptTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceiptTemplates.
     */
    data: XOR<ReceiptTemplateUpdateManyMutationInput, ReceiptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptTemplates to update
     */
    where?: ReceiptTemplateWhereInput
    /**
     * Limit how many ReceiptTemplates to update.
     */
    limit?: number
  }

  /**
   * ReceiptTemplate updateManyAndReturn
   */
  export type ReceiptTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ReceiptTemplates.
     */
    data: XOR<ReceiptTemplateUpdateManyMutationInput, ReceiptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptTemplates to update
     */
    where?: ReceiptTemplateWhereInput
    /**
     * Limit how many ReceiptTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceiptTemplate upsert
   */
  export type ReceiptTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceiptTemplate to update in case it exists.
     */
    where: ReceiptTemplateWhereUniqueInput
    /**
     * In case the ReceiptTemplate found by the `where` argument doesn't exist, create a new ReceiptTemplate with this data.
     */
    create: XOR<ReceiptTemplateCreateInput, ReceiptTemplateUncheckedCreateInput>
    /**
     * In case the ReceiptTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptTemplateUpdateInput, ReceiptTemplateUncheckedUpdateInput>
  }

  /**
   * ReceiptTemplate delete
   */
  export type ReceiptTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
    /**
     * Filter which ReceiptTemplate to delete.
     */
    where: ReceiptTemplateWhereUniqueInput
  }

  /**
   * ReceiptTemplate deleteMany
   */
  export type ReceiptTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptTemplates to delete
     */
    where?: ReceiptTemplateWhereInput
    /**
     * Limit how many ReceiptTemplates to delete.
     */
    limit?: number
  }

  /**
   * ReceiptTemplate without action
   */
  export type ReceiptTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptTemplate
     */
    select?: ReceiptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceiptTemplate
     */
    omit?: ReceiptTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    discountValue: Decimal | null
    minAmount: Decimal | null
    minQuantity: number | null
  }

  export type DiscountSumAggregateOutputType = {
    discountValue: Decimal | null
    minAmount: Decimal | null
    minQuantity: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    discountType: string | null
    discountValue: Decimal | null
    discountValueType: string | null
    minAmount: Decimal | null
    minQuantity: number | null
    bundleDiscountProduct: string | null
    applicableTo: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    discountType: string | null
    discountValue: Decimal | null
    discountValueType: string | null
    minAmount: Decimal | null
    minQuantity: number | null
    bundleDiscountProduct: string | null
    applicableTo: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    discountType: number
    discountValue: number
    discountValueType: number
    minAmount: number
    minQuantity: number
    applicableProducts: number
    bundleProducts: number
    bundleDiscountProduct: number
    applicableTo: number
    isActive: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    discountValue?: true
    minAmount?: true
    minQuantity?: true
  }

  export type DiscountSumAggregateInputType = {
    discountValue?: true
    minAmount?: true
    minQuantity?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    discountType?: true
    discountValue?: true
    discountValueType?: true
    minAmount?: true
    minQuantity?: true
    bundleDiscountProduct?: true
    applicableTo?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    discountType?: true
    discountValue?: true
    discountValueType?: true
    minAmount?: true
    minQuantity?: true
    bundleDiscountProduct?: true
    applicableTo?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    discountType?: true
    discountValue?: true
    discountValueType?: true
    minAmount?: true
    minQuantity?: true
    applicableProducts?: true
    bundleProducts?: true
    bundleDiscountProduct?: true
    applicableTo?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    discountType: string
    discountValue: Decimal
    discountValueType: string
    minAmount: Decimal | null
    minQuantity: number | null
    applicableProducts: JsonValue | null
    bundleProducts: JsonValue | null
    bundleDiscountProduct: string | null
    applicableTo: string
    isActive: boolean
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    minAmount?: boolean
    minQuantity?: boolean
    applicableProducts?: boolean
    bundleProducts?: boolean
    bundleDiscountProduct?: boolean
    applicableTo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    minAmount?: boolean
    minQuantity?: boolean
    applicableProducts?: boolean
    bundleProducts?: boolean
    bundleDiscountProduct?: boolean
    applicableTo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    minAmount?: boolean
    minQuantity?: boolean
    applicableProducts?: boolean
    bundleProducts?: boolean
    bundleDiscountProduct?: boolean
    applicableTo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    minAmount?: boolean
    minQuantity?: boolean
    applicableProducts?: boolean
    bundleProducts?: boolean
    bundleDiscountProduct?: boolean
    applicableTo?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "discountType" | "discountValue" | "discountValueType" | "minAmount" | "minQuantity" | "applicableProducts" | "bundleProducts" | "bundleDiscountProduct" | "applicableTo" | "isActive" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      discountType: string
      discountValue: Prisma.Decimal
      discountValueType: string
      minAmount: Prisma.Decimal | null
      minQuantity: number | null
      applicableProducts: Prisma.JsonValue | null
      bundleProducts: Prisma.JsonValue | null
      bundleDiscountProduct: string | null
      applicableTo: string
      isActive: boolean
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {DiscountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {DiscountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly tenantId: FieldRef<"Discount", 'String'>
    readonly name: FieldRef<"Discount", 'String'>
    readonly discountType: FieldRef<"Discount", 'String'>
    readonly discountValue: FieldRef<"Discount", 'Decimal'>
    readonly discountValueType: FieldRef<"Discount", 'String'>
    readonly minAmount: FieldRef<"Discount", 'Decimal'>
    readonly minQuantity: FieldRef<"Discount", 'Int'>
    readonly applicableProducts: FieldRef<"Discount", 'Json'>
    readonly bundleProducts: FieldRef<"Discount", 'Json'>
    readonly bundleDiscountProduct: FieldRef<"Discount", 'String'>
    readonly applicableTo: FieldRef<"Discount", 'String'>
    readonly isActive: FieldRef<"Discount", 'Boolean'>
    readonly startDate: FieldRef<"Discount", 'DateTime'>
    readonly endDate: FieldRef<"Discount", 'DateTime'>
    readonly createdAt: FieldRef<"Discount", 'DateTime'>
    readonly updatedAt: FieldRef<"Discount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount createManyAndReturn
   */
  export type DiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount updateManyAndReturn
   */
  export type DiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    userEmail: string | null
    userName: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    userEmail: string | null
    userName: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    userEmail: number
    userName: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    status: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    userEmail?: true
    userName?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    userEmail?: true
    userName?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    userEmail?: true
    userName?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string | null
    userId: string | null
    userEmail: string | null
    userName: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    status: string
    errorMessage: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    userEmail?: boolean
    userName?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "userEmail" | "userName" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "status" | "errorMessage" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      userId: string | null
      userEmail: string | null
      userName: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      status: string
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends AuditLog$tenantArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userEmail: FieldRef<"AuditLog", 'String'>
    readonly userName: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly status: FieldRef<"AuditLog", 'String'>
    readonly errorMessage: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.tenant
   */
  export type AuditLog$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    retryCount: number | null
    timeout: number | null
  }

  export type WebhookSumAggregateOutputType = {
    retryCount: number | null
    timeout: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    retryCount: number | null
    timeout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    retryCount: number | null
    timeout: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    tenantId: number
    url: number
    events: number
    secret: number
    isActive: number
    retryCount: number
    timeout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    retryCount?: true
    timeout?: true
  }

  export type WebhookSumAggregateInputType = {
    retryCount?: true
    timeout?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    tenantId?: true
    url?: true
    secret?: true
    isActive?: true
    retryCount?: true
    timeout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    tenantId?: true
    url?: true
    secret?: true
    isActive?: true
    retryCount?: true
    timeout?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    tenantId?: true
    url?: true
    events?: true
    secret?: true
    isActive?: true
    retryCount?: true
    timeout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    tenantId: string
    url: string
    events: string[]
    secret: string
    isActive: boolean
    retryCount: number
    timeout: number
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    retryCount?: boolean
    timeout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    retryCount?: boolean
    timeout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    retryCount?: boolean
    timeout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    tenantId?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    isActive?: boolean
    retryCount?: boolean
    timeout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "url" | "events" | "secret" | "isActive" | "retryCount" | "timeout" | "createdAt" | "updatedAt", ExtArgs["result"]["webhook"]>
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      url: string
      events: string[]
      secret: string
      isActive: boolean
      retryCount: number
      timeout: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends Webhook$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly tenantId: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly retryCount: FieldRef<"Webhook", 'Int'>
    readonly timeout: FieldRef<"Webhook", 'Int'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook.deliveries
   */
  export type Webhook$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    responseCode: number | null
    attempts: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    responseCode: number | null
    attempts: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    webhookId: string | null
    event: string | null
    status: string | null
    responseCode: number | null
    responseBody: string | null
    attempts: number | null
    nextRetryAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    webhookId: string | null
    event: string | null
    status: string | null
    responseCode: number | null
    responseBody: string | null
    attempts: number | null
    nextRetryAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    webhookId: number
    event: number
    payload: number
    status: number
    responseCode: number
    responseBody: number
    attempts: number
    nextRetryAt: number
    deliveredAt: number
    createdAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    responseCode?: true
    attempts?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    responseCode?: true
    attempts?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    status?: true
    responseCode?: true
    responseBody?: true
    attempts?: true
    nextRetryAt?: true
    deliveredAt?: true
    createdAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    status?: true
    responseCode?: true
    responseBody?: true
    attempts?: true
    nextRetryAt?: true
    deliveredAt?: true
    createdAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    payload?: true
    status?: true
    responseCode?: true
    responseBody?: true
    attempts?: true
    nextRetryAt?: true
    deliveredAt?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    webhookId: string
    event: string
    payload: JsonValue
    status: string
    responseCode: number | null
    responseBody: string | null
    attempts: number
    nextRetryAt: Date | null
    deliveredAt: Date | null
    createdAt: Date
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    responseCode?: boolean
    responseBody?: boolean
    attempts?: boolean
    nextRetryAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    responseCode?: boolean
    responseBody?: boolean
    attempts?: boolean
    nextRetryAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    responseCode?: boolean
    responseBody?: boolean
    attempts?: boolean
    nextRetryAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    status?: boolean
    responseCode?: boolean
    responseBody?: boolean
    attempts?: boolean
    nextRetryAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
  }

  export type WebhookDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "webhookId" | "event" | "payload" | "status" | "responseCode" | "responseBody" | "attempts" | "nextRetryAt" | "deliveredAt" | "createdAt", ExtArgs["result"]["webhookDelivery"]>
  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      webhookId: string
      event: string
      payload: Prisma.JsonValue
      status: string
      responseCode: number | null
      responseBody: string | null
      attempts: number
      nextRetryAt: Date | null
      deliveredAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries and returns the data updated in the database.
     * @param {WebhookDeliveryUpdateManyAndReturnArgs} args - Arguments to update many WebhookDeliveries.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly event: FieldRef<"WebhookDelivery", 'String'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly status: FieldRef<"WebhookDelivery", 'String'>
    readonly responseCode: FieldRef<"WebhookDelivery", 'Int'>
    readonly responseBody: FieldRef<"WebhookDelivery", 'String'>
    readonly attempts: FieldRef<"WebhookDelivery", 'Int'>
    readonly nextRetryAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly deliveredAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
  }

  /**
   * WebhookDelivery updateManyAndReturn
   */
  export type WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to delete.
     */
    limit?: number
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    contactPerson: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    contactPerson: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    email: number
    phone: number
    address: number
    contactPerson: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    contactPerson?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    contactPerson?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    contactPerson?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    contactPerson: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    contactPerson?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    contactPerson?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    contactPerson?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    contactPerson?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "email" | "phone" | "address" | "contactPerson" | "notes" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      contactPerson: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly tenantId: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supplierId: string | null
    orderNumber: string | null
    status: string | null
    orderDate: Date | null
    expectedDate: Date | null
    receivedDate: Date | null
    totalAmount: Decimal | null
    notes: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supplierId: string | null
    orderNumber: string | null
    status: string | null
    orderDate: Date | null
    expectedDate: Date | null
    receivedDate: Date | null
    totalAmount: Decimal | null
    notes: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    tenantId: number
    supplierId: number
    orderNumber: number
    status: number
    orderDate: number
    expectedDate: number
    receivedDate: number
    totalAmount: number
    notes: number
    createdBy: number
    approvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    orderNumber?: true
    status?: true
    orderDate?: true
    expectedDate?: true
    receivedDate?: true
    totalAmount?: true
    notes?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    orderNumber?: true
    status?: true
    orderDate?: true
    expectedDate?: true
    receivedDate?: true
    totalAmount?: true
    notes?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    orderNumber?: true
    status?: true
    orderDate?: true
    expectedDate?: true
    receivedDate?: true
    totalAmount?: true
    notes?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    tenantId: string
    supplierId: string
    orderNumber: string
    status: string
    orderDate: Date
    expectedDate: Date | null
    receivedDate: Date | null
    totalAmount: Decimal
    notes: string | null
    createdBy: string
    approvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "supplierId" | "orderNumber" | "status" | "orderDate" | "expectedDate" | "receivedDate" | "totalAmount" | "notes" | "createdBy" | "approvedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      supplierId: string
      orderNumber: string
      status: string
      orderDate: Date
      expectedDate: Date | null
      receivedDate: Date | null
      totalAmount: Prisma.Decimal
      notes: string | null
      createdBy: string
      approvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly tenantId: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'String'>
    readonly orderNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly expectedDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly receivedDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly totalAmount: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly createdBy: FieldRef<"PurchaseOrder", 'String'>
    readonly approvedBy: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    receivedQuantity: number | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    receivedQuantity: number | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    receivedQuantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    receivedQuantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    purchaseOrderId: string
    productId: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    receivedQuantity: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "productId" | "quantity" | "unitPrice" | "totalPrice" | "receivedQuantity" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrderItem"]>
  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      productId: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      receivedQuantity: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems and returns the data updated in the database.
     * @param {PurchaseOrderItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderItems.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly productId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly quantity: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly unitPrice: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly totalPrice: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly receivedQuantity: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly notes: FieldRef<"PurchaseOrderItem", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem updateManyAndReturn
   */
  export type PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model StockTransfer
   */

  export type AggregateStockTransfer = {
    _count: StockTransferCountAggregateOutputType | null
    _min: StockTransferMinAggregateOutputType | null
    _max: StockTransferMaxAggregateOutputType | null
  }

  export type StockTransferMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    fromOutletId: string | null
    toOutletId: string | null
    transferNumber: string | null
    storeShiftId: string | null
    status: string | null
    transferDate: Date | null
    receivedDate: Date | null
    notes: string | null
    createdBy: string | null
    receivedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransferMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    fromOutletId: string | null
    toOutletId: string | null
    transferNumber: string | null
    storeShiftId: string | null
    status: string | null
    transferDate: Date | null
    receivedDate: Date | null
    notes: string | null
    createdBy: string | null
    receivedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransferCountAggregateOutputType = {
    id: number
    tenantId: number
    fromOutletId: number
    toOutletId: number
    transferNumber: number
    storeShiftId: number
    status: number
    transferDate: number
    receivedDate: number
    notes: number
    createdBy: number
    receivedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockTransferMinAggregateInputType = {
    id?: true
    tenantId?: true
    fromOutletId?: true
    toOutletId?: true
    transferNumber?: true
    storeShiftId?: true
    status?: true
    transferDate?: true
    receivedDate?: true
    notes?: true
    createdBy?: true
    receivedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransferMaxAggregateInputType = {
    id?: true
    tenantId?: true
    fromOutletId?: true
    toOutletId?: true
    transferNumber?: true
    storeShiftId?: true
    status?: true
    transferDate?: true
    receivedDate?: true
    notes?: true
    createdBy?: true
    receivedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransferCountAggregateInputType = {
    id?: true
    tenantId?: true
    fromOutletId?: true
    toOutletId?: true
    transferNumber?: true
    storeShiftId?: true
    status?: true
    transferDate?: true
    receivedDate?: true
    notes?: true
    createdBy?: true
    receivedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransfer to aggregate.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransfers
    **/
    _count?: true | StockTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransferMaxAggregateInputType
  }

  export type GetStockTransferAggregateType<T extends StockTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransfer[P]>
      : GetScalarType<T[P], AggregateStockTransfer[P]>
  }




  export type StockTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithAggregationInput | StockTransferOrderByWithAggregationInput[]
    by: StockTransferScalarFieldEnum[] | StockTransferScalarFieldEnum
    having?: StockTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransferCountAggregateInputType | true
    _min?: StockTransferMinAggregateInputType
    _max?: StockTransferMaxAggregateInputType
  }

  export type StockTransferGroupByOutputType = {
    id: string
    tenantId: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    storeShiftId: string | null
    status: string
    transferDate: Date
    receivedDate: Date | null
    notes: string | null
    createdBy: string
    receivedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: StockTransferCountAggregateOutputType | null
    _min: StockTransferMinAggregateOutputType | null
    _max: StockTransferMaxAggregateOutputType | null
  }

  type GetStockTransferGroupByPayload<T extends StockTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransferGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransferGroupByOutputType[P]>
        }
      >
    >


  export type StockTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fromOutletId?: boolean
    toOutletId?: boolean
    transferNumber?: boolean
    storeShiftId?: boolean
    status?: boolean
    transferDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdBy?: boolean
    receivedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | StockTransfer$storeShiftArgs<ExtArgs>
    items?: boolean | StockTransfer$itemsArgs<ExtArgs>
    _count?: boolean | StockTransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fromOutletId?: boolean
    toOutletId?: boolean
    transferNumber?: boolean
    storeShiftId?: boolean
    status?: boolean
    transferDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdBy?: boolean
    receivedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | StockTransfer$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fromOutletId?: boolean
    toOutletId?: boolean
    transferNumber?: boolean
    storeShiftId?: boolean
    status?: boolean
    transferDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdBy?: boolean
    receivedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | StockTransfer$storeShiftArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectScalar = {
    id?: boolean
    tenantId?: boolean
    fromOutletId?: boolean
    toOutletId?: boolean
    transferNumber?: boolean
    storeShiftId?: boolean
    status?: boolean
    transferDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdBy?: boolean
    receivedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "fromOutletId" | "toOutletId" | "transferNumber" | "storeShiftId" | "status" | "transferDate" | "receivedDate" | "notes" | "createdBy" | "receivedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["stockTransfer"]>
  export type StockTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | StockTransfer$storeShiftArgs<ExtArgs>
    items?: boolean | StockTransfer$itemsArgs<ExtArgs>
    _count?: boolean | StockTransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | StockTransfer$storeShiftArgs<ExtArgs>
  }
  export type StockTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | StockTransfer$storeShiftArgs<ExtArgs>
  }

  export type $StockTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransfer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      storeShift: Prisma.$StoreShiftPayload<ExtArgs> | null
      items: Prisma.$StockTransferItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      fromOutletId: string
      toOutletId: string
      transferNumber: string
      storeShiftId: string | null
      status: string
      transferDate: Date
      receivedDate: Date | null
      notes: string | null
      createdBy: string
      receivedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockTransfer"]>
    composites: {}
  }

  type StockTransferGetPayload<S extends boolean | null | undefined | StockTransferDefaultArgs> = $Result.GetResult<Prisma.$StockTransferPayload, S>

  type StockTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransferCountAggregateInputType | true
    }

  export interface StockTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransfer'], meta: { name: 'StockTransfer' } }
    /**
     * Find zero or one StockTransfer that matches the filter.
     * @param {StockTransferFindUniqueArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransferFindUniqueArgs>(args: SelectSubset<T, StockTransferFindUniqueArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransferFindUniqueOrThrowArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindFirstArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransferFindFirstArgs>(args?: SelectSubset<T, StockTransferFindFirstArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindFirstOrThrowArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransfers
     * const stockTransfers = await prisma.stockTransfer.findMany()
     * 
     * // Get first 10 StockTransfers
     * const stockTransfers = await prisma.stockTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransferFindManyArgs>(args?: SelectSubset<T, StockTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransfer.
     * @param {StockTransferCreateArgs} args - Arguments to create a StockTransfer.
     * @example
     * // Create one StockTransfer
     * const StockTransfer = await prisma.stockTransfer.create({
     *   data: {
     *     // ... data to create a StockTransfer
     *   }
     * })
     * 
     */
    create<T extends StockTransferCreateArgs>(args: SelectSubset<T, StockTransferCreateArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransfers.
     * @param {StockTransferCreateManyArgs} args - Arguments to create many StockTransfers.
     * @example
     * // Create many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransferCreateManyArgs>(args?: SelectSubset<T, StockTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransfers and returns the data saved in the database.
     * @param {StockTransferCreateManyAndReturnArgs} args - Arguments to create many StockTransfers.
     * @example
     * // Create many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransfers and only return the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransfer.
     * @param {StockTransferDeleteArgs} args - Arguments to delete one StockTransfer.
     * @example
     * // Delete one StockTransfer
     * const StockTransfer = await prisma.stockTransfer.delete({
     *   where: {
     *     // ... filter to delete one StockTransfer
     *   }
     * })
     * 
     */
    delete<T extends StockTransferDeleteArgs>(args: SelectSubset<T, StockTransferDeleteArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransfer.
     * @param {StockTransferUpdateArgs} args - Arguments to update one StockTransfer.
     * @example
     * // Update one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransferUpdateArgs>(args: SelectSubset<T, StockTransferUpdateArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransfers.
     * @param {StockTransferDeleteManyArgs} args - Arguments to filter StockTransfers to delete.
     * @example
     * // Delete a few StockTransfers
     * const { count } = await prisma.stockTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransferDeleteManyArgs>(args?: SelectSubset<T, StockTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransferUpdateManyArgs>(args: SelectSubset<T, StockTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransfers and returns the data updated in the database.
     * @param {StockTransferUpdateManyAndReturnArgs} args - Arguments to update many StockTransfers.
     * @example
     * // Update many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransfers and only return the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransfer.
     * @param {StockTransferUpsertArgs} args - Arguments to update or create a StockTransfer.
     * @example
     * // Update or create a StockTransfer
     * const stockTransfer = await prisma.stockTransfer.upsert({
     *   create: {
     *     // ... data to create a StockTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransfer we want to update
     *   }
     * })
     */
    upsert<T extends StockTransferUpsertArgs>(args: SelectSubset<T, StockTransferUpsertArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferCountArgs} args - Arguments to filter StockTransfers to count.
     * @example
     * // Count the number of StockTransfers
     * const count = await prisma.stockTransfer.count({
     *   where: {
     *     // ... the filter for the StockTransfers we want to count
     *   }
     * })
    **/
    count<T extends StockTransferCountArgs>(
      args?: Subset<T, StockTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransferAggregateArgs>(args: Subset<T, StockTransferAggregateArgs>): Prisma.PrismaPromise<GetStockTransferAggregateType<T>>

    /**
     * Group by StockTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransferGroupByArgs['orderBy'] }
        : { orderBy?: StockTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransfer model
   */
  readonly fields: StockTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    storeShift<T extends StockTransfer$storeShiftArgs<ExtArgs> = {}>(args?: Subset<T, StockTransfer$storeShiftArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends StockTransfer$itemsArgs<ExtArgs> = {}>(args?: Subset<T, StockTransfer$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransfer model
   */
  interface StockTransferFieldRefs {
    readonly id: FieldRef<"StockTransfer", 'String'>
    readonly tenantId: FieldRef<"StockTransfer", 'String'>
    readonly fromOutletId: FieldRef<"StockTransfer", 'String'>
    readonly toOutletId: FieldRef<"StockTransfer", 'String'>
    readonly transferNumber: FieldRef<"StockTransfer", 'String'>
    readonly storeShiftId: FieldRef<"StockTransfer", 'String'>
    readonly status: FieldRef<"StockTransfer", 'String'>
    readonly transferDate: FieldRef<"StockTransfer", 'DateTime'>
    readonly receivedDate: FieldRef<"StockTransfer", 'DateTime'>
    readonly notes: FieldRef<"StockTransfer", 'String'>
    readonly createdBy: FieldRef<"StockTransfer", 'String'>
    readonly receivedBy: FieldRef<"StockTransfer", 'String'>
    readonly createdAt: FieldRef<"StockTransfer", 'DateTime'>
    readonly updatedAt: FieldRef<"StockTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTransfer findUnique
   */
  export type StockTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer findUniqueOrThrow
   */
  export type StockTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer findFirst
   */
  export type StockTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransfers.
     */
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StockTransfer findFirstOrThrow
   */
  export type StockTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransfers.
     */
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StockTransfer findMany
   */
  export type StockTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfers to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StockTransfer create
   */
  export type StockTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransfer.
     */
    data: XOR<StockTransferCreateInput, StockTransferUncheckedCreateInput>
  }

  /**
   * StockTransfer createMany
   */
  export type StockTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransfers.
     */
    data: StockTransferCreateManyInput | StockTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTransfer createManyAndReturn
   */
  export type StockTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransfers.
     */
    data: StockTransferCreateManyInput | StockTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransfer update
   */
  export type StockTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransfer.
     */
    data: XOR<StockTransferUpdateInput, StockTransferUncheckedUpdateInput>
    /**
     * Choose, which StockTransfer to update.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer updateMany
   */
  export type StockTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransfers.
     */
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyInput>
    /**
     * Filter which StockTransfers to update
     */
    where?: StockTransferWhereInput
    /**
     * Limit how many StockTransfers to update.
     */
    limit?: number
  }

  /**
   * StockTransfer updateManyAndReturn
   */
  export type StockTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * The data used to update StockTransfers.
     */
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyInput>
    /**
     * Filter which StockTransfers to update
     */
    where?: StockTransferWhereInput
    /**
     * Limit how many StockTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransfer upsert
   */
  export type StockTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransfer to update in case it exists.
     */
    where: StockTransferWhereUniqueInput
    /**
     * In case the StockTransfer found by the `where` argument doesn't exist, create a new StockTransfer with this data.
     */
    create: XOR<StockTransferCreateInput, StockTransferUncheckedCreateInput>
    /**
     * In case the StockTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransferUpdateInput, StockTransferUncheckedUpdateInput>
  }

  /**
   * StockTransfer delete
   */
  export type StockTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter which StockTransfer to delete.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer deleteMany
   */
  export type StockTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransfers to delete
     */
    where?: StockTransferWhereInput
    /**
     * Limit how many StockTransfers to delete.
     */
    limit?: number
  }

  /**
   * StockTransfer.storeShift
   */
  export type StockTransfer$storeShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
  }

  /**
   * StockTransfer.items
   */
  export type StockTransfer$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    where?: StockTransferItemWhereInput
    orderBy?: StockTransferItemOrderByWithRelationInput | StockTransferItemOrderByWithRelationInput[]
    cursor?: StockTransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferItemScalarFieldEnum | StockTransferItemScalarFieldEnum[]
  }

  /**
   * StockTransfer without action
   */
  export type StockTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
  }


  /**
   * Model StockTransferItem
   */

  export type AggregateStockTransferItem = {
    _count: StockTransferItemCountAggregateOutputType | null
    _avg: StockTransferItemAvgAggregateOutputType | null
    _sum: StockTransferItemSumAggregateOutputType | null
    _min: StockTransferItemMinAggregateOutputType | null
    _max: StockTransferItemMaxAggregateOutputType | null
  }

  export type StockTransferItemAvgAggregateOutputType = {
    quantity: number | null
    receivedQuantity: number | null
  }

  export type StockTransferItemSumAggregateOutputType = {
    quantity: number | null
    receivedQuantity: number | null
  }

  export type StockTransferItemMinAggregateOutputType = {
    id: string | null
    stockTransferId: string | null
    productId: string | null
    quantity: number | null
    receivedQuantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransferItemMaxAggregateOutputType = {
    id: string | null
    stockTransferId: string | null
    productId: string | null
    quantity: number | null
    receivedQuantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransferItemCountAggregateOutputType = {
    id: number
    stockTransferId: number
    productId: number
    quantity: number
    receivedQuantity: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockTransferItemAvgAggregateInputType = {
    quantity?: true
    receivedQuantity?: true
  }

  export type StockTransferItemSumAggregateInputType = {
    quantity?: true
    receivedQuantity?: true
  }

  export type StockTransferItemMinAggregateInputType = {
    id?: true
    stockTransferId?: true
    productId?: true
    quantity?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransferItemMaxAggregateInputType = {
    id?: true
    stockTransferId?: true
    productId?: true
    quantity?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransferItemCountAggregateInputType = {
    id?: true
    stockTransferId?: true
    productId?: true
    quantity?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockTransferItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransferItem to aggregate.
     */
    where?: StockTransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferItems to fetch.
     */
    orderBy?: StockTransferItemOrderByWithRelationInput | StockTransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransferItems
    **/
    _count?: true | StockTransferItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransferItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransferItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransferItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransferItemMaxAggregateInputType
  }

  export type GetStockTransferItemAggregateType<T extends StockTransferItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransferItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransferItem[P]>
      : GetScalarType<T[P], AggregateStockTransferItem[P]>
  }




  export type StockTransferItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferItemWhereInput
    orderBy?: StockTransferItemOrderByWithAggregationInput | StockTransferItemOrderByWithAggregationInput[]
    by: StockTransferItemScalarFieldEnum[] | StockTransferItemScalarFieldEnum
    having?: StockTransferItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransferItemCountAggregateInputType | true
    _avg?: StockTransferItemAvgAggregateInputType
    _sum?: StockTransferItemSumAggregateInputType
    _min?: StockTransferItemMinAggregateInputType
    _max?: StockTransferItemMaxAggregateInputType
  }

  export type StockTransferItemGroupByOutputType = {
    id: string
    stockTransferId: string
    productId: string
    quantity: number
    receivedQuantity: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: StockTransferItemCountAggregateOutputType | null
    _avg: StockTransferItemAvgAggregateOutputType | null
    _sum: StockTransferItemSumAggregateOutputType | null
    _min: StockTransferItemMinAggregateOutputType | null
    _max: StockTransferItemMaxAggregateOutputType | null
  }

  type GetStockTransferItemGroupByPayload<T extends StockTransferItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransferItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransferItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransferItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransferItemGroupByOutputType[P]>
        }
      >
    >


  export type StockTransferItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockTransferId?: boolean
    productId?: boolean
    quantity?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockTransfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferItem"]>

  export type StockTransferItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockTransferId?: boolean
    productId?: boolean
    quantity?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockTransfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferItem"]>

  export type StockTransferItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockTransferId?: boolean
    productId?: boolean
    quantity?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockTransfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferItem"]>

  export type StockTransferItemSelectScalar = {
    id?: boolean
    stockTransferId?: boolean
    productId?: boolean
    quantity?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockTransferItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stockTransferId" | "productId" | "quantity" | "receivedQuantity" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["stockTransferItem"]>
  export type StockTransferItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockTransfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockTransferItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockTransfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockTransferItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockTransfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockTransferItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransferItem"
    objects: {
      stockTransfer: Prisma.$StockTransferPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stockTransferId: string
      productId: string
      quantity: number
      receivedQuantity: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockTransferItem"]>
    composites: {}
  }

  type StockTransferItemGetPayload<S extends boolean | null | undefined | StockTransferItemDefaultArgs> = $Result.GetResult<Prisma.$StockTransferItemPayload, S>

  type StockTransferItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransferItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransferItemCountAggregateInputType | true
    }

  export interface StockTransferItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransferItem'], meta: { name: 'StockTransferItem' } }
    /**
     * Find zero or one StockTransferItem that matches the filter.
     * @param {StockTransferItemFindUniqueArgs} args - Arguments to find a StockTransferItem
     * @example
     * // Get one StockTransferItem
     * const stockTransferItem = await prisma.stockTransferItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransferItemFindUniqueArgs>(args: SelectSubset<T, StockTransferItemFindUniqueArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransferItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransferItemFindUniqueOrThrowArgs} args - Arguments to find a StockTransferItem
     * @example
     * // Get one StockTransferItem
     * const stockTransferItem = await prisma.stockTransferItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransferItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransferItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransferItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemFindFirstArgs} args - Arguments to find a StockTransferItem
     * @example
     * // Get one StockTransferItem
     * const stockTransferItem = await prisma.stockTransferItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransferItemFindFirstArgs>(args?: SelectSubset<T, StockTransferItemFindFirstArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransferItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemFindFirstOrThrowArgs} args - Arguments to find a StockTransferItem
     * @example
     * // Get one StockTransferItem
     * const stockTransferItem = await prisma.stockTransferItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransferItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransferItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransferItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransferItems
     * const stockTransferItems = await prisma.stockTransferItem.findMany()
     * 
     * // Get first 10 StockTransferItems
     * const stockTransferItems = await prisma.stockTransferItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransferItemWithIdOnly = await prisma.stockTransferItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransferItemFindManyArgs>(args?: SelectSubset<T, StockTransferItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransferItem.
     * @param {StockTransferItemCreateArgs} args - Arguments to create a StockTransferItem.
     * @example
     * // Create one StockTransferItem
     * const StockTransferItem = await prisma.stockTransferItem.create({
     *   data: {
     *     // ... data to create a StockTransferItem
     *   }
     * })
     * 
     */
    create<T extends StockTransferItemCreateArgs>(args: SelectSubset<T, StockTransferItemCreateArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransferItems.
     * @param {StockTransferItemCreateManyArgs} args - Arguments to create many StockTransferItems.
     * @example
     * // Create many StockTransferItems
     * const stockTransferItem = await prisma.stockTransferItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransferItemCreateManyArgs>(args?: SelectSubset<T, StockTransferItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransferItems and returns the data saved in the database.
     * @param {StockTransferItemCreateManyAndReturnArgs} args - Arguments to create many StockTransferItems.
     * @example
     * // Create many StockTransferItems
     * const stockTransferItem = await prisma.stockTransferItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransferItems and only return the `id`
     * const stockTransferItemWithIdOnly = await prisma.stockTransferItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransferItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransferItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransferItem.
     * @param {StockTransferItemDeleteArgs} args - Arguments to delete one StockTransferItem.
     * @example
     * // Delete one StockTransferItem
     * const StockTransferItem = await prisma.stockTransferItem.delete({
     *   where: {
     *     // ... filter to delete one StockTransferItem
     *   }
     * })
     * 
     */
    delete<T extends StockTransferItemDeleteArgs>(args: SelectSubset<T, StockTransferItemDeleteArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransferItem.
     * @param {StockTransferItemUpdateArgs} args - Arguments to update one StockTransferItem.
     * @example
     * // Update one StockTransferItem
     * const stockTransferItem = await prisma.stockTransferItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransferItemUpdateArgs>(args: SelectSubset<T, StockTransferItemUpdateArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransferItems.
     * @param {StockTransferItemDeleteManyArgs} args - Arguments to filter StockTransferItems to delete.
     * @example
     * // Delete a few StockTransferItems
     * const { count } = await prisma.stockTransferItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransferItemDeleteManyArgs>(args?: SelectSubset<T, StockTransferItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransferItems
     * const stockTransferItem = await prisma.stockTransferItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransferItemUpdateManyArgs>(args: SelectSubset<T, StockTransferItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransferItems and returns the data updated in the database.
     * @param {StockTransferItemUpdateManyAndReturnArgs} args - Arguments to update many StockTransferItems.
     * @example
     * // Update many StockTransferItems
     * const stockTransferItem = await prisma.stockTransferItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransferItems and only return the `id`
     * const stockTransferItemWithIdOnly = await prisma.stockTransferItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransferItemUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransferItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransferItem.
     * @param {StockTransferItemUpsertArgs} args - Arguments to update or create a StockTransferItem.
     * @example
     * // Update or create a StockTransferItem
     * const stockTransferItem = await prisma.stockTransferItem.upsert({
     *   create: {
     *     // ... data to create a StockTransferItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransferItem we want to update
     *   }
     * })
     */
    upsert<T extends StockTransferItemUpsertArgs>(args: SelectSubset<T, StockTransferItemUpsertArgs<ExtArgs>>): Prisma__StockTransferItemClient<$Result.GetResult<Prisma.$StockTransferItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemCountArgs} args - Arguments to filter StockTransferItems to count.
     * @example
     * // Count the number of StockTransferItems
     * const count = await prisma.stockTransferItem.count({
     *   where: {
     *     // ... the filter for the StockTransferItems we want to count
     *   }
     * })
    **/
    count<T extends StockTransferItemCountArgs>(
      args?: Subset<T, StockTransferItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransferItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransferItemAggregateArgs>(args: Subset<T, StockTransferItemAggregateArgs>): Prisma.PrismaPromise<GetStockTransferItemAggregateType<T>>

    /**
     * Group by StockTransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransferItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransferItemGroupByArgs['orderBy'] }
        : { orderBy?: StockTransferItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransferItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransferItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransferItem model
   */
  readonly fields: StockTransferItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransferItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransferItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockTransfer<T extends StockTransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockTransferDefaultArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransferItem model
   */
  interface StockTransferItemFieldRefs {
    readonly id: FieldRef<"StockTransferItem", 'String'>
    readonly stockTransferId: FieldRef<"StockTransferItem", 'String'>
    readonly productId: FieldRef<"StockTransferItem", 'String'>
    readonly quantity: FieldRef<"StockTransferItem", 'Int'>
    readonly receivedQuantity: FieldRef<"StockTransferItem", 'Int'>
    readonly notes: FieldRef<"StockTransferItem", 'String'>
    readonly createdAt: FieldRef<"StockTransferItem", 'DateTime'>
    readonly updatedAt: FieldRef<"StockTransferItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTransferItem findUnique
   */
  export type StockTransferItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferItem to fetch.
     */
    where: StockTransferItemWhereUniqueInput
  }

  /**
   * StockTransferItem findUniqueOrThrow
   */
  export type StockTransferItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferItem to fetch.
     */
    where: StockTransferItemWhereUniqueInput
  }

  /**
   * StockTransferItem findFirst
   */
  export type StockTransferItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferItem to fetch.
     */
    where?: StockTransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferItems to fetch.
     */
    orderBy?: StockTransferItemOrderByWithRelationInput | StockTransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransferItems.
     */
    cursor?: StockTransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransferItems.
     */
    distinct?: StockTransferItemScalarFieldEnum | StockTransferItemScalarFieldEnum[]
  }

  /**
   * StockTransferItem findFirstOrThrow
   */
  export type StockTransferItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferItem to fetch.
     */
    where?: StockTransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferItems to fetch.
     */
    orderBy?: StockTransferItemOrderByWithRelationInput | StockTransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransferItems.
     */
    cursor?: StockTransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransferItems.
     */
    distinct?: StockTransferItemScalarFieldEnum | StockTransferItemScalarFieldEnum[]
  }

  /**
   * StockTransferItem findMany
   */
  export type StockTransferItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferItems to fetch.
     */
    where?: StockTransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferItems to fetch.
     */
    orderBy?: StockTransferItemOrderByWithRelationInput | StockTransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransferItems.
     */
    cursor?: StockTransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferItems.
     */
    skip?: number
    distinct?: StockTransferItemScalarFieldEnum | StockTransferItemScalarFieldEnum[]
  }

  /**
   * StockTransferItem create
   */
  export type StockTransferItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransferItem.
     */
    data: XOR<StockTransferItemCreateInput, StockTransferItemUncheckedCreateInput>
  }

  /**
   * StockTransferItem createMany
   */
  export type StockTransferItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransferItems.
     */
    data: StockTransferItemCreateManyInput | StockTransferItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockTransferItem createManyAndReturn
   */
  export type StockTransferItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransferItems.
     */
    data: StockTransferItemCreateManyInput | StockTransferItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransferItem update
   */
  export type StockTransferItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransferItem.
     */
    data: XOR<StockTransferItemUpdateInput, StockTransferItemUncheckedUpdateInput>
    /**
     * Choose, which StockTransferItem to update.
     */
    where: StockTransferItemWhereUniqueInput
  }

  /**
   * StockTransferItem updateMany
   */
  export type StockTransferItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransferItems.
     */
    data: XOR<StockTransferItemUpdateManyMutationInput, StockTransferItemUncheckedUpdateManyInput>
    /**
     * Filter which StockTransferItems to update
     */
    where?: StockTransferItemWhereInput
    /**
     * Limit how many StockTransferItems to update.
     */
    limit?: number
  }

  /**
   * StockTransferItem updateManyAndReturn
   */
  export type StockTransferItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * The data used to update StockTransferItems.
     */
    data: XOR<StockTransferItemUpdateManyMutationInput, StockTransferItemUncheckedUpdateManyInput>
    /**
     * Filter which StockTransferItems to update
     */
    where?: StockTransferItemWhereInput
    /**
     * Limit how many StockTransferItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransferItem upsert
   */
  export type StockTransferItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransferItem to update in case it exists.
     */
    where: StockTransferItemWhereUniqueInput
    /**
     * In case the StockTransferItem found by the `where` argument doesn't exist, create a new StockTransferItem with this data.
     */
    create: XOR<StockTransferItemCreateInput, StockTransferItemUncheckedCreateInput>
    /**
     * In case the StockTransferItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransferItemUpdateInput, StockTransferItemUncheckedUpdateInput>
  }

  /**
   * StockTransferItem delete
   */
  export type StockTransferItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
    /**
     * Filter which StockTransferItem to delete.
     */
    where: StockTransferItemWhereUniqueInput
  }

  /**
   * StockTransferItem deleteMany
   */
  export type StockTransferItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransferItems to delete
     */
    where?: StockTransferItemWhereInput
    /**
     * Limit how many StockTransferItems to delete.
     */
    limit?: number
  }

  /**
   * StockTransferItem without action
   */
  export type StockTransferItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferItem
     */
    select?: StockTransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferItem
     */
    omit?: StockTransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferItemInclude<ExtArgs> | null
  }


  /**
   * Model StockValuation
   */

  export type AggregateStockValuation = {
    _count: StockValuationCountAggregateOutputType | null
    _avg: StockValuationAvgAggregateOutputType | null
    _sum: StockValuationSumAggregateOutputType | null
    _min: StockValuationMinAggregateOutputType | null
    _max: StockValuationMaxAggregateOutputType | null
  }

  export type StockValuationAvgAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
  }

  export type StockValuationSumAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
  }

  export type StockValuationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    valuationType: string | null
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
    purchaseDate: Date | null
    purchaseOrderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockValuationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    valuationType: string | null
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
    purchaseDate: Date | null
    purchaseOrderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockValuationCountAggregateOutputType = {
    id: number
    tenantId: number
    productId: number
    valuationType: number
    quantity: number
    unitCost: number
    totalCost: number
    purchaseDate: number
    purchaseOrderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockValuationAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type StockValuationSumAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type StockValuationMinAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    valuationType?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    purchaseDate?: true
    purchaseOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockValuationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    valuationType?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    purchaseDate?: true
    purchaseOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockValuationCountAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    valuationType?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    purchaseDate?: true
    purchaseOrderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockValuationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockValuation to aggregate.
     */
    where?: StockValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockValuations to fetch.
     */
    orderBy?: StockValuationOrderByWithRelationInput | StockValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockValuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockValuations
    **/
    _count?: true | StockValuationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockValuationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockValuationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockValuationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockValuationMaxAggregateInputType
  }

  export type GetStockValuationAggregateType<T extends StockValuationAggregateArgs> = {
        [P in keyof T & keyof AggregateStockValuation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockValuation[P]>
      : GetScalarType<T[P], AggregateStockValuation[P]>
  }




  export type StockValuationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockValuationWhereInput
    orderBy?: StockValuationOrderByWithAggregationInput | StockValuationOrderByWithAggregationInput[]
    by: StockValuationScalarFieldEnum[] | StockValuationScalarFieldEnum
    having?: StockValuationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockValuationCountAggregateInputType | true
    _avg?: StockValuationAvgAggregateInputType
    _sum?: StockValuationSumAggregateInputType
    _min?: StockValuationMinAggregateInputType
    _max?: StockValuationMaxAggregateInputType
  }

  export type StockValuationGroupByOutputType = {
    id: string
    tenantId: string
    productId: string
    valuationType: string
    quantity: number
    unitCost: Decimal
    totalCost: Decimal
    purchaseDate: Date
    purchaseOrderId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StockValuationCountAggregateOutputType | null
    _avg: StockValuationAvgAggregateOutputType | null
    _sum: StockValuationSumAggregateOutputType | null
    _min: StockValuationMinAggregateOutputType | null
    _max: StockValuationMaxAggregateOutputType | null
  }

  type GetStockValuationGroupByPayload<T extends StockValuationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockValuationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockValuationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockValuationGroupByOutputType[P]>
            : GetScalarType<T[P], StockValuationGroupByOutputType[P]>
        }
      >
    >


  export type StockValuationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    valuationType?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockValuation"]>

  export type StockValuationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    valuationType?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockValuation"]>

  export type StockValuationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    valuationType?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockValuation"]>

  export type StockValuationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    valuationType?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    purchaseDate?: boolean
    purchaseOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockValuationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "productId" | "valuationType" | "quantity" | "unitCost" | "totalCost" | "purchaseDate" | "purchaseOrderId" | "createdAt" | "updatedAt", ExtArgs["result"]["stockValuation"]>
  export type StockValuationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockValuationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockValuationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockValuationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockValuation"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      productId: string
      valuationType: string
      quantity: number
      unitCost: Prisma.Decimal
      totalCost: Prisma.Decimal
      purchaseDate: Date
      purchaseOrderId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockValuation"]>
    composites: {}
  }

  type StockValuationGetPayload<S extends boolean | null | undefined | StockValuationDefaultArgs> = $Result.GetResult<Prisma.$StockValuationPayload, S>

  type StockValuationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockValuationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockValuationCountAggregateInputType | true
    }

  export interface StockValuationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockValuation'], meta: { name: 'StockValuation' } }
    /**
     * Find zero or one StockValuation that matches the filter.
     * @param {StockValuationFindUniqueArgs} args - Arguments to find a StockValuation
     * @example
     * // Get one StockValuation
     * const stockValuation = await prisma.stockValuation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockValuationFindUniqueArgs>(args: SelectSubset<T, StockValuationFindUniqueArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockValuation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockValuationFindUniqueOrThrowArgs} args - Arguments to find a StockValuation
     * @example
     * // Get one StockValuation
     * const stockValuation = await prisma.stockValuation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockValuationFindUniqueOrThrowArgs>(args: SelectSubset<T, StockValuationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockValuation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationFindFirstArgs} args - Arguments to find a StockValuation
     * @example
     * // Get one StockValuation
     * const stockValuation = await prisma.stockValuation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockValuationFindFirstArgs>(args?: SelectSubset<T, StockValuationFindFirstArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockValuation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationFindFirstOrThrowArgs} args - Arguments to find a StockValuation
     * @example
     * // Get one StockValuation
     * const stockValuation = await prisma.stockValuation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockValuationFindFirstOrThrowArgs>(args?: SelectSubset<T, StockValuationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockValuations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockValuations
     * const stockValuations = await prisma.stockValuation.findMany()
     * 
     * // Get first 10 StockValuations
     * const stockValuations = await prisma.stockValuation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockValuationWithIdOnly = await prisma.stockValuation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockValuationFindManyArgs>(args?: SelectSubset<T, StockValuationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockValuation.
     * @param {StockValuationCreateArgs} args - Arguments to create a StockValuation.
     * @example
     * // Create one StockValuation
     * const StockValuation = await prisma.stockValuation.create({
     *   data: {
     *     // ... data to create a StockValuation
     *   }
     * })
     * 
     */
    create<T extends StockValuationCreateArgs>(args: SelectSubset<T, StockValuationCreateArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockValuations.
     * @param {StockValuationCreateManyArgs} args - Arguments to create many StockValuations.
     * @example
     * // Create many StockValuations
     * const stockValuation = await prisma.stockValuation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockValuationCreateManyArgs>(args?: SelectSubset<T, StockValuationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockValuations and returns the data saved in the database.
     * @param {StockValuationCreateManyAndReturnArgs} args - Arguments to create many StockValuations.
     * @example
     * // Create many StockValuations
     * const stockValuation = await prisma.stockValuation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockValuations and only return the `id`
     * const stockValuationWithIdOnly = await prisma.stockValuation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockValuationCreateManyAndReturnArgs>(args?: SelectSubset<T, StockValuationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockValuation.
     * @param {StockValuationDeleteArgs} args - Arguments to delete one StockValuation.
     * @example
     * // Delete one StockValuation
     * const StockValuation = await prisma.stockValuation.delete({
     *   where: {
     *     // ... filter to delete one StockValuation
     *   }
     * })
     * 
     */
    delete<T extends StockValuationDeleteArgs>(args: SelectSubset<T, StockValuationDeleteArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockValuation.
     * @param {StockValuationUpdateArgs} args - Arguments to update one StockValuation.
     * @example
     * // Update one StockValuation
     * const stockValuation = await prisma.stockValuation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockValuationUpdateArgs>(args: SelectSubset<T, StockValuationUpdateArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockValuations.
     * @param {StockValuationDeleteManyArgs} args - Arguments to filter StockValuations to delete.
     * @example
     * // Delete a few StockValuations
     * const { count } = await prisma.stockValuation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockValuationDeleteManyArgs>(args?: SelectSubset<T, StockValuationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockValuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockValuations
     * const stockValuation = await prisma.stockValuation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockValuationUpdateManyArgs>(args: SelectSubset<T, StockValuationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockValuations and returns the data updated in the database.
     * @param {StockValuationUpdateManyAndReturnArgs} args - Arguments to update many StockValuations.
     * @example
     * // Update many StockValuations
     * const stockValuation = await prisma.stockValuation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockValuations and only return the `id`
     * const stockValuationWithIdOnly = await prisma.stockValuation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockValuationUpdateManyAndReturnArgs>(args: SelectSubset<T, StockValuationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockValuation.
     * @param {StockValuationUpsertArgs} args - Arguments to update or create a StockValuation.
     * @example
     * // Update or create a StockValuation
     * const stockValuation = await prisma.stockValuation.upsert({
     *   create: {
     *     // ... data to create a StockValuation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockValuation we want to update
     *   }
     * })
     */
    upsert<T extends StockValuationUpsertArgs>(args: SelectSubset<T, StockValuationUpsertArgs<ExtArgs>>): Prisma__StockValuationClient<$Result.GetResult<Prisma.$StockValuationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockValuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationCountArgs} args - Arguments to filter StockValuations to count.
     * @example
     * // Count the number of StockValuations
     * const count = await prisma.stockValuation.count({
     *   where: {
     *     // ... the filter for the StockValuations we want to count
     *   }
     * })
    **/
    count<T extends StockValuationCountArgs>(
      args?: Subset<T, StockValuationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockValuationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockValuation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockValuationAggregateArgs>(args: Subset<T, StockValuationAggregateArgs>): Prisma.PrismaPromise<GetStockValuationAggregateType<T>>

    /**
     * Group by StockValuation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockValuationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockValuationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockValuationGroupByArgs['orderBy'] }
        : { orderBy?: StockValuationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockValuationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockValuationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockValuation model
   */
  readonly fields: StockValuationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockValuation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockValuationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockValuation model
   */
  interface StockValuationFieldRefs {
    readonly id: FieldRef<"StockValuation", 'String'>
    readonly tenantId: FieldRef<"StockValuation", 'String'>
    readonly productId: FieldRef<"StockValuation", 'String'>
    readonly valuationType: FieldRef<"StockValuation", 'String'>
    readonly quantity: FieldRef<"StockValuation", 'Int'>
    readonly unitCost: FieldRef<"StockValuation", 'Decimal'>
    readonly totalCost: FieldRef<"StockValuation", 'Decimal'>
    readonly purchaseDate: FieldRef<"StockValuation", 'DateTime'>
    readonly purchaseOrderId: FieldRef<"StockValuation", 'String'>
    readonly createdAt: FieldRef<"StockValuation", 'DateTime'>
    readonly updatedAt: FieldRef<"StockValuation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockValuation findUnique
   */
  export type StockValuationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * Filter, which StockValuation to fetch.
     */
    where: StockValuationWhereUniqueInput
  }

  /**
   * StockValuation findUniqueOrThrow
   */
  export type StockValuationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * Filter, which StockValuation to fetch.
     */
    where: StockValuationWhereUniqueInput
  }

  /**
   * StockValuation findFirst
   */
  export type StockValuationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * Filter, which StockValuation to fetch.
     */
    where?: StockValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockValuations to fetch.
     */
    orderBy?: StockValuationOrderByWithRelationInput | StockValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockValuations.
     */
    cursor?: StockValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockValuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockValuations.
     */
    distinct?: StockValuationScalarFieldEnum | StockValuationScalarFieldEnum[]
  }

  /**
   * StockValuation findFirstOrThrow
   */
  export type StockValuationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * Filter, which StockValuation to fetch.
     */
    where?: StockValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockValuations to fetch.
     */
    orderBy?: StockValuationOrderByWithRelationInput | StockValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockValuations.
     */
    cursor?: StockValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockValuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockValuations.
     */
    distinct?: StockValuationScalarFieldEnum | StockValuationScalarFieldEnum[]
  }

  /**
   * StockValuation findMany
   */
  export type StockValuationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * Filter, which StockValuations to fetch.
     */
    where?: StockValuationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockValuations to fetch.
     */
    orderBy?: StockValuationOrderByWithRelationInput | StockValuationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockValuations.
     */
    cursor?: StockValuationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockValuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockValuations.
     */
    skip?: number
    distinct?: StockValuationScalarFieldEnum | StockValuationScalarFieldEnum[]
  }

  /**
   * StockValuation create
   */
  export type StockValuationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * The data needed to create a StockValuation.
     */
    data: XOR<StockValuationCreateInput, StockValuationUncheckedCreateInput>
  }

  /**
   * StockValuation createMany
   */
  export type StockValuationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockValuations.
     */
    data: StockValuationCreateManyInput | StockValuationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockValuation createManyAndReturn
   */
  export type StockValuationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * The data used to create many StockValuations.
     */
    data: StockValuationCreateManyInput | StockValuationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockValuation update
   */
  export type StockValuationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * The data needed to update a StockValuation.
     */
    data: XOR<StockValuationUpdateInput, StockValuationUncheckedUpdateInput>
    /**
     * Choose, which StockValuation to update.
     */
    where: StockValuationWhereUniqueInput
  }

  /**
   * StockValuation updateMany
   */
  export type StockValuationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockValuations.
     */
    data: XOR<StockValuationUpdateManyMutationInput, StockValuationUncheckedUpdateManyInput>
    /**
     * Filter which StockValuations to update
     */
    where?: StockValuationWhereInput
    /**
     * Limit how many StockValuations to update.
     */
    limit?: number
  }

  /**
   * StockValuation updateManyAndReturn
   */
  export type StockValuationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * The data used to update StockValuations.
     */
    data: XOR<StockValuationUpdateManyMutationInput, StockValuationUncheckedUpdateManyInput>
    /**
     * Filter which StockValuations to update
     */
    where?: StockValuationWhereInput
    /**
     * Limit how many StockValuations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockValuation upsert
   */
  export type StockValuationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * The filter to search for the StockValuation to update in case it exists.
     */
    where: StockValuationWhereUniqueInput
    /**
     * In case the StockValuation found by the `where` argument doesn't exist, create a new StockValuation with this data.
     */
    create: XOR<StockValuationCreateInput, StockValuationUncheckedCreateInput>
    /**
     * In case the StockValuation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockValuationUpdateInput, StockValuationUncheckedUpdateInput>
  }

  /**
   * StockValuation delete
   */
  export type StockValuationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
    /**
     * Filter which StockValuation to delete.
     */
    where: StockValuationWhereUniqueInput
  }

  /**
   * StockValuation deleteMany
   */
  export type StockValuationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockValuations to delete
     */
    where?: StockValuationWhereInput
    /**
     * Limit how many StockValuations to delete.
     */
    limit?: number
  }

  /**
   * StockValuation without action
   */
  export type StockValuationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockValuation
     */
    select?: StockValuationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockValuation
     */
    omit?: StockValuationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockValuationInclude<ExtArgs> | null
  }


  /**
   * Model BackupLog
   */

  export type AggregateBackupLog = {
    _count: BackupLogCountAggregateOutputType | null
    _avg: BackupLogAvgAggregateOutputType | null
    _sum: BackupLogSumAggregateOutputType | null
    _min: BackupLogMinAggregateOutputType | null
    _max: BackupLogMaxAggregateOutputType | null
  }

  export type BackupLogAvgAggregateOutputType = {
    size: number | null
  }

  export type BackupLogSumAggregateOutputType = {
    size: number | null
  }

  export type BackupLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    status: string | null
    generatedAt: Date | null
    emailSentAt: Date | null
    size: number | null
    filePath: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackupLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    status: string | null
    generatedAt: Date | null
    emailSentAt: Date | null
    size: number | null
    filePath: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackupLogCountAggregateOutputType = {
    id: number
    tenantId: number
    status: number
    generatedAt: number
    emailSentAt: number
    size: number
    filePath: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BackupLogAvgAggregateInputType = {
    size?: true
  }

  export type BackupLogSumAggregateInputType = {
    size?: true
  }

  export type BackupLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    generatedAt?: true
    emailSentAt?: true
    size?: true
    filePath?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackupLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    generatedAt?: true
    emailSentAt?: true
    size?: true
    filePath?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackupLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    generatedAt?: true
    emailSentAt?: true
    size?: true
    filePath?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BackupLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupLog to aggregate.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackupLogs
    **/
    _count?: true | BackupLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackupLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackupLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackupLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackupLogMaxAggregateInputType
  }

  export type GetBackupLogAggregateType<T extends BackupLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBackupLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackupLog[P]>
      : GetScalarType<T[P], AggregateBackupLog[P]>
  }




  export type BackupLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupLogWhereInput
    orderBy?: BackupLogOrderByWithAggregationInput | BackupLogOrderByWithAggregationInput[]
    by: BackupLogScalarFieldEnum[] | BackupLogScalarFieldEnum
    having?: BackupLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackupLogCountAggregateInputType | true
    _avg?: BackupLogAvgAggregateInputType
    _sum?: BackupLogSumAggregateInputType
    _min?: BackupLogMinAggregateInputType
    _max?: BackupLogMaxAggregateInputType
  }

  export type BackupLogGroupByOutputType = {
    id: string
    tenantId: string
    status: string
    generatedAt: Date
    emailSentAt: Date | null
    size: number | null
    filePath: string
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: BackupLogCountAggregateOutputType | null
    _avg: BackupLogAvgAggregateOutputType | null
    _sum: BackupLogSumAggregateOutputType | null
    _min: BackupLogMinAggregateOutputType | null
    _max: BackupLogMaxAggregateOutputType | null
  }

  type GetBackupLogGroupByPayload<T extends BackupLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackupLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackupLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackupLogGroupByOutputType[P]>
            : GetScalarType<T[P], BackupLogGroupByOutputType[P]>
        }
      >
    >


  export type BackupLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    generatedAt?: boolean
    emailSentAt?: boolean
    size?: boolean
    filePath?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["backupLog"]>

  export type BackupLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    generatedAt?: boolean
    emailSentAt?: boolean
    size?: boolean
    filePath?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["backupLog"]>

  export type BackupLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    generatedAt?: boolean
    emailSentAt?: boolean
    size?: boolean
    filePath?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["backupLog"]>

  export type BackupLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    status?: boolean
    generatedAt?: boolean
    emailSentAt?: boolean
    size?: boolean
    filePath?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BackupLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "status" | "generatedAt" | "emailSentAt" | "size" | "filePath" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["backupLog"]>
  export type BackupLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BackupLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BackupLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BackupLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackupLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      status: string
      generatedAt: Date
      emailSentAt: Date | null
      size: number | null
      filePath: string
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["backupLog"]>
    composites: {}
  }

  type BackupLogGetPayload<S extends boolean | null | undefined | BackupLogDefaultArgs> = $Result.GetResult<Prisma.$BackupLogPayload, S>

  type BackupLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BackupLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BackupLogCountAggregateInputType | true
    }

  export interface BackupLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackupLog'], meta: { name: 'BackupLog' } }
    /**
     * Find zero or one BackupLog that matches the filter.
     * @param {BackupLogFindUniqueArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackupLogFindUniqueArgs>(args: SelectSubset<T, BackupLogFindUniqueArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BackupLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BackupLogFindUniqueOrThrowArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackupLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BackupLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BackupLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogFindFirstArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackupLogFindFirstArgs>(args?: SelectSubset<T, BackupLogFindFirstArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BackupLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogFindFirstOrThrowArgs} args - Arguments to find a BackupLog
     * @example
     * // Get one BackupLog
     * const backupLog = await prisma.backupLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackupLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BackupLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BackupLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackupLogs
     * const backupLogs = await prisma.backupLog.findMany()
     * 
     * // Get first 10 BackupLogs
     * const backupLogs = await prisma.backupLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backupLogWithIdOnly = await prisma.backupLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackupLogFindManyArgs>(args?: SelectSubset<T, BackupLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BackupLog.
     * @param {BackupLogCreateArgs} args - Arguments to create a BackupLog.
     * @example
     * // Create one BackupLog
     * const BackupLog = await prisma.backupLog.create({
     *   data: {
     *     // ... data to create a BackupLog
     *   }
     * })
     * 
     */
    create<T extends BackupLogCreateArgs>(args: SelectSubset<T, BackupLogCreateArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BackupLogs.
     * @param {BackupLogCreateManyArgs} args - Arguments to create many BackupLogs.
     * @example
     * // Create many BackupLogs
     * const backupLog = await prisma.backupLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackupLogCreateManyArgs>(args?: SelectSubset<T, BackupLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackupLogs and returns the data saved in the database.
     * @param {BackupLogCreateManyAndReturnArgs} args - Arguments to create many BackupLogs.
     * @example
     * // Create many BackupLogs
     * const backupLog = await prisma.backupLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackupLogs and only return the `id`
     * const backupLogWithIdOnly = await prisma.backupLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackupLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BackupLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BackupLog.
     * @param {BackupLogDeleteArgs} args - Arguments to delete one BackupLog.
     * @example
     * // Delete one BackupLog
     * const BackupLog = await prisma.backupLog.delete({
     *   where: {
     *     // ... filter to delete one BackupLog
     *   }
     * })
     * 
     */
    delete<T extends BackupLogDeleteArgs>(args: SelectSubset<T, BackupLogDeleteArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BackupLog.
     * @param {BackupLogUpdateArgs} args - Arguments to update one BackupLog.
     * @example
     * // Update one BackupLog
     * const backupLog = await prisma.backupLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackupLogUpdateArgs>(args: SelectSubset<T, BackupLogUpdateArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BackupLogs.
     * @param {BackupLogDeleteManyArgs} args - Arguments to filter BackupLogs to delete.
     * @example
     * // Delete a few BackupLogs
     * const { count } = await prisma.backupLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackupLogDeleteManyArgs>(args?: SelectSubset<T, BackupLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackupLogs
     * const backupLog = await prisma.backupLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackupLogUpdateManyArgs>(args: SelectSubset<T, BackupLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupLogs and returns the data updated in the database.
     * @param {BackupLogUpdateManyAndReturnArgs} args - Arguments to update many BackupLogs.
     * @example
     * // Update many BackupLogs
     * const backupLog = await prisma.backupLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BackupLogs and only return the `id`
     * const backupLogWithIdOnly = await prisma.backupLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BackupLogUpdateManyAndReturnArgs>(args: SelectSubset<T, BackupLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BackupLog.
     * @param {BackupLogUpsertArgs} args - Arguments to update or create a BackupLog.
     * @example
     * // Update or create a BackupLog
     * const backupLog = await prisma.backupLog.upsert({
     *   create: {
     *     // ... data to create a BackupLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackupLog we want to update
     *   }
     * })
     */
    upsert<T extends BackupLogUpsertArgs>(args: SelectSubset<T, BackupLogUpsertArgs<ExtArgs>>): Prisma__BackupLogClient<$Result.GetResult<Prisma.$BackupLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BackupLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogCountArgs} args - Arguments to filter BackupLogs to count.
     * @example
     * // Count the number of BackupLogs
     * const count = await prisma.backupLog.count({
     *   where: {
     *     // ... the filter for the BackupLogs we want to count
     *   }
     * })
    **/
    count<T extends BackupLogCountArgs>(
      args?: Subset<T, BackupLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackupLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackupLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackupLogAggregateArgs>(args: Subset<T, BackupLogAggregateArgs>): Prisma.PrismaPromise<GetBackupLogAggregateType<T>>

    /**
     * Group by BackupLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackupLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackupLogGroupByArgs['orderBy'] }
        : { orderBy?: BackupLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackupLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackupLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackupLog model
   */
  readonly fields: BackupLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackupLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackupLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackupLog model
   */
  interface BackupLogFieldRefs {
    readonly id: FieldRef<"BackupLog", 'String'>
    readonly tenantId: FieldRef<"BackupLog", 'String'>
    readonly status: FieldRef<"BackupLog", 'String'>
    readonly generatedAt: FieldRef<"BackupLog", 'DateTime'>
    readonly emailSentAt: FieldRef<"BackupLog", 'DateTime'>
    readonly size: FieldRef<"BackupLog", 'Int'>
    readonly filePath: FieldRef<"BackupLog", 'String'>
    readonly errorMessage: FieldRef<"BackupLog", 'String'>
    readonly createdAt: FieldRef<"BackupLog", 'DateTime'>
    readonly updatedAt: FieldRef<"BackupLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BackupLog findUnique
   */
  export type BackupLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog findUniqueOrThrow
   */
  export type BackupLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog findFirst
   */
  export type BackupLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupLogs.
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupLogs.
     */
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * BackupLog findFirstOrThrow
   */
  export type BackupLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * Filter, which BackupLog to fetch.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupLogs.
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupLogs.
     */
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * BackupLog findMany
   */
  export type BackupLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * Filter, which BackupLogs to fetch.
     */
    where?: BackupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupLogs to fetch.
     */
    orderBy?: BackupLogOrderByWithRelationInput | BackupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackupLogs.
     */
    cursor?: BackupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupLogs.
     */
    skip?: number
    distinct?: BackupLogScalarFieldEnum | BackupLogScalarFieldEnum[]
  }

  /**
   * BackupLog create
   */
  export type BackupLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BackupLog.
     */
    data: XOR<BackupLogCreateInput, BackupLogUncheckedCreateInput>
  }

  /**
   * BackupLog createMany
   */
  export type BackupLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackupLogs.
     */
    data: BackupLogCreateManyInput | BackupLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupLog createManyAndReturn
   */
  export type BackupLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * The data used to create many BackupLogs.
     */
    data: BackupLogCreateManyInput | BackupLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BackupLog update
   */
  export type BackupLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BackupLog.
     */
    data: XOR<BackupLogUpdateInput, BackupLogUncheckedUpdateInput>
    /**
     * Choose, which BackupLog to update.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog updateMany
   */
  export type BackupLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackupLogs.
     */
    data: XOR<BackupLogUpdateManyMutationInput, BackupLogUncheckedUpdateManyInput>
    /**
     * Filter which BackupLogs to update
     */
    where?: BackupLogWhereInput
    /**
     * Limit how many BackupLogs to update.
     */
    limit?: number
  }

  /**
   * BackupLog updateManyAndReturn
   */
  export type BackupLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * The data used to update BackupLogs.
     */
    data: XOR<BackupLogUpdateManyMutationInput, BackupLogUncheckedUpdateManyInput>
    /**
     * Filter which BackupLogs to update
     */
    where?: BackupLogWhereInput
    /**
     * Limit how many BackupLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BackupLog upsert
   */
  export type BackupLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BackupLog to update in case it exists.
     */
    where: BackupLogWhereUniqueInput
    /**
     * In case the BackupLog found by the `where` argument doesn't exist, create a new BackupLog with this data.
     */
    create: XOR<BackupLogCreateInput, BackupLogUncheckedCreateInput>
    /**
     * In case the BackupLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackupLogUpdateInput, BackupLogUncheckedUpdateInput>
  }

  /**
   * BackupLog delete
   */
  export type BackupLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
    /**
     * Filter which BackupLog to delete.
     */
    where: BackupLogWhereUniqueInput
  }

  /**
   * BackupLog deleteMany
   */
  export type BackupLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupLogs to delete
     */
    where?: BackupLogWhereInput
    /**
     * Limit how many BackupLogs to delete.
     */
    limit?: number
  }

  /**
   * BackupLog without action
   */
  export type BackupLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupLog
     */
    select?: BackupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupLog
     */
    omit?: BackupLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupLogInclude<ExtArgs> | null
  }


  /**
   * Model StoreShift
   */

  export type AggregateStoreShift = {
    _count: StoreShiftCountAggregateOutputType | null
    _avg: StoreShiftAvgAggregateOutputType | null
    _sum: StoreShiftSumAggregateOutputType | null
    _min: StoreShiftMinAggregateOutputType | null
    _max: StoreShiftMaxAggregateOutputType | null
  }

  export type StoreShiftAvgAggregateOutputType = {
    modalAwal: Decimal | null
  }

  export type StoreShiftSumAggregateOutputType = {
    modalAwal: Decimal | null
  }

  export type StoreShiftMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    outletId: string | null
    shiftType: string | null
    openedBy: string | null
    openedAt: Date | null
    closedAt: Date | null
    status: string | null
    modalAwal: Decimal | null
    catatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreShiftMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    outletId: string | null
    shiftType: string | null
    openedBy: string | null
    openedAt: Date | null
    closedAt: Date | null
    status: string | null
    modalAwal: Decimal | null
    catatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreShiftCountAggregateOutputType = {
    id: number
    tenantId: number
    outletId: number
    shiftType: number
    openedBy: number
    openedAt: number
    closedAt: number
    status: number
    modalAwal: number
    catatan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreShiftAvgAggregateInputType = {
    modalAwal?: true
  }

  export type StoreShiftSumAggregateInputType = {
    modalAwal?: true
  }

  export type StoreShiftMinAggregateInputType = {
    id?: true
    tenantId?: true
    outletId?: true
    shiftType?: true
    openedBy?: true
    openedAt?: true
    closedAt?: true
    status?: true
    modalAwal?: true
    catatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreShiftMaxAggregateInputType = {
    id?: true
    tenantId?: true
    outletId?: true
    shiftType?: true
    openedBy?: true
    openedAt?: true
    closedAt?: true
    status?: true
    modalAwal?: true
    catatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreShiftCountAggregateInputType = {
    id?: true
    tenantId?: true
    outletId?: true
    shiftType?: true
    openedBy?: true
    openedAt?: true
    closedAt?: true
    status?: true
    modalAwal?: true
    catatan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreShift to aggregate.
     */
    where?: StoreShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreShifts to fetch.
     */
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreShifts
    **/
    _count?: true | StoreShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreShiftMaxAggregateInputType
  }

  export type GetStoreShiftAggregateType<T extends StoreShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreShift[P]>
      : GetScalarType<T[P], AggregateStoreShift[P]>
  }




  export type StoreShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreShiftWhereInput
    orderBy?: StoreShiftOrderByWithAggregationInput | StoreShiftOrderByWithAggregationInput[]
    by: StoreShiftScalarFieldEnum[] | StoreShiftScalarFieldEnum
    having?: StoreShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreShiftCountAggregateInputType | true
    _avg?: StoreShiftAvgAggregateInputType
    _sum?: StoreShiftSumAggregateInputType
    _min?: StoreShiftMinAggregateInputType
    _max?: StoreShiftMaxAggregateInputType
  }

  export type StoreShiftGroupByOutputType = {
    id: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt: Date
    closedAt: Date | null
    status: string
    modalAwal: Decimal | null
    catatan: string | null
    createdAt: Date
    updatedAt: Date
    _count: StoreShiftCountAggregateOutputType | null
    _avg: StoreShiftAvgAggregateOutputType | null
    _sum: StoreShiftSumAggregateOutputType | null
    _min: StoreShiftMinAggregateOutputType | null
    _max: StoreShiftMaxAggregateOutputType | null
  }

  type GetStoreShiftGroupByPayload<T extends StoreShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreShiftGroupByOutputType[P]>
            : GetScalarType<T[P], StoreShiftGroupByOutputType[P]>
        }
      >
    >


  export type StoreShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    outletId?: boolean
    shiftType?: boolean
    openedBy?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    modalAwal?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | StoreShift$ordersArgs<ExtArgs>
    cashShifts?: boolean | StoreShift$cashShiftsArgs<ExtArgs>
    productAdjustments?: boolean | StoreShift$productAdjustmentsArgs<ExtArgs>
    stockTransfers?: boolean | StoreShift$stockTransfersArgs<ExtArgs>
    _count?: boolean | StoreShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeShift"]>

  export type StoreShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    outletId?: boolean
    shiftType?: boolean
    openedBy?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    modalAwal?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeShift"]>

  export type StoreShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    outletId?: boolean
    shiftType?: boolean
    openedBy?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    modalAwal?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeShift"]>

  export type StoreShiftSelectScalar = {
    id?: boolean
    tenantId?: boolean
    outletId?: boolean
    shiftType?: boolean
    openedBy?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    modalAwal?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "outletId" | "shiftType" | "openedBy" | "openedAt" | "closedAt" | "status" | "modalAwal" | "catatan" | "createdAt" | "updatedAt", ExtArgs["result"]["storeShift"]>
  export type StoreShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | StoreShift$ordersArgs<ExtArgs>
    cashShifts?: boolean | StoreShift$cashShiftsArgs<ExtArgs>
    productAdjustments?: boolean | StoreShift$productAdjustmentsArgs<ExtArgs>
    stockTransfers?: boolean | StoreShift$stockTransfersArgs<ExtArgs>
    _count?: boolean | StoreShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoreShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    outlet?: boolean | OutletDefaultArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoreShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreShift"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      outlet: Prisma.$OutletPayload<ExtArgs>
      opener: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      cashShifts: Prisma.$CashShiftPayload<ExtArgs>[]
      productAdjustments: Prisma.$ProductAdjustmentPayload<ExtArgs>[]
      stockTransfers: Prisma.$StockTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      outletId: string
      shiftType: string
      openedBy: string
      openedAt: Date
      closedAt: Date | null
      status: string
      modalAwal: Prisma.Decimal | null
      catatan: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeShift"]>
    composites: {}
  }

  type StoreShiftGetPayload<S extends boolean | null | undefined | StoreShiftDefaultArgs> = $Result.GetResult<Prisma.$StoreShiftPayload, S>

  type StoreShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreShiftCountAggregateInputType | true
    }

  export interface StoreShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreShift'], meta: { name: 'StoreShift' } }
    /**
     * Find zero or one StoreShift that matches the filter.
     * @param {StoreShiftFindUniqueArgs} args - Arguments to find a StoreShift
     * @example
     * // Get one StoreShift
     * const storeShift = await prisma.storeShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreShiftFindUniqueArgs>(args: SelectSubset<T, StoreShiftFindUniqueArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoreShift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreShiftFindUniqueOrThrowArgs} args - Arguments to find a StoreShift
     * @example
     * // Get one StoreShift
     * const storeShift = await prisma.storeShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftFindFirstArgs} args - Arguments to find a StoreShift
     * @example
     * // Get one StoreShift
     * const storeShift = await prisma.storeShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreShiftFindFirstArgs>(args?: SelectSubset<T, StoreShiftFindFirstArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftFindFirstOrThrowArgs} args - Arguments to find a StoreShift
     * @example
     * // Get one StoreShift
     * const storeShift = await prisma.storeShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoreShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreShifts
     * const storeShifts = await prisma.storeShift.findMany()
     * 
     * // Get first 10 StoreShifts
     * const storeShifts = await prisma.storeShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeShiftWithIdOnly = await prisma.storeShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreShiftFindManyArgs>(args?: SelectSubset<T, StoreShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoreShift.
     * @param {StoreShiftCreateArgs} args - Arguments to create a StoreShift.
     * @example
     * // Create one StoreShift
     * const StoreShift = await prisma.storeShift.create({
     *   data: {
     *     // ... data to create a StoreShift
     *   }
     * })
     * 
     */
    create<T extends StoreShiftCreateArgs>(args: SelectSubset<T, StoreShiftCreateArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoreShifts.
     * @param {StoreShiftCreateManyArgs} args - Arguments to create many StoreShifts.
     * @example
     * // Create many StoreShifts
     * const storeShift = await prisma.storeShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreShiftCreateManyArgs>(args?: SelectSubset<T, StoreShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreShifts and returns the data saved in the database.
     * @param {StoreShiftCreateManyAndReturnArgs} args - Arguments to create many StoreShifts.
     * @example
     * // Create many StoreShifts
     * const storeShift = await prisma.storeShift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreShifts and only return the `id`
     * const storeShiftWithIdOnly = await prisma.storeShift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoreShift.
     * @param {StoreShiftDeleteArgs} args - Arguments to delete one StoreShift.
     * @example
     * // Delete one StoreShift
     * const StoreShift = await prisma.storeShift.delete({
     *   where: {
     *     // ... filter to delete one StoreShift
     *   }
     * })
     * 
     */
    delete<T extends StoreShiftDeleteArgs>(args: SelectSubset<T, StoreShiftDeleteArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoreShift.
     * @param {StoreShiftUpdateArgs} args - Arguments to update one StoreShift.
     * @example
     * // Update one StoreShift
     * const storeShift = await prisma.storeShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreShiftUpdateArgs>(args: SelectSubset<T, StoreShiftUpdateArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoreShifts.
     * @param {StoreShiftDeleteManyArgs} args - Arguments to filter StoreShifts to delete.
     * @example
     * // Delete a few StoreShifts
     * const { count } = await prisma.storeShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreShiftDeleteManyArgs>(args?: SelectSubset<T, StoreShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreShifts
     * const storeShift = await prisma.storeShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreShiftUpdateManyArgs>(args: SelectSubset<T, StoreShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreShifts and returns the data updated in the database.
     * @param {StoreShiftUpdateManyAndReturnArgs} args - Arguments to update many StoreShifts.
     * @example
     * // Update many StoreShifts
     * const storeShift = await prisma.storeShift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoreShifts and only return the `id`
     * const storeShiftWithIdOnly = await prisma.storeShift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoreShift.
     * @param {StoreShiftUpsertArgs} args - Arguments to update or create a StoreShift.
     * @example
     * // Update or create a StoreShift
     * const storeShift = await prisma.storeShift.upsert({
     *   create: {
     *     // ... data to create a StoreShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreShift we want to update
     *   }
     * })
     */
    upsert<T extends StoreShiftUpsertArgs>(args: SelectSubset<T, StoreShiftUpsertArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoreShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftCountArgs} args - Arguments to filter StoreShifts to count.
     * @example
     * // Count the number of StoreShifts
     * const count = await prisma.storeShift.count({
     *   where: {
     *     // ... the filter for the StoreShifts we want to count
     *   }
     * })
    **/
    count<T extends StoreShiftCountArgs>(
      args?: Subset<T, StoreShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreShiftAggregateArgs>(args: Subset<T, StoreShiftAggregateArgs>): Prisma.PrismaPromise<GetStoreShiftAggregateType<T>>

    /**
     * Group by StoreShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreShiftGroupByArgs['orderBy'] }
        : { orderBy?: StoreShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreShift model
   */
  readonly fields: StoreShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    outlet<T extends OutletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutletDefaultArgs<ExtArgs>>): Prisma__OutletClient<$Result.GetResult<Prisma.$OutletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opener<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends StoreShift$ordersArgs<ExtArgs> = {}>(args?: Subset<T, StoreShift$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashShifts<T extends StoreShift$cashShiftsArgs<ExtArgs> = {}>(args?: Subset<T, StoreShift$cashShiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productAdjustments<T extends StoreShift$productAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, StoreShift$productAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransfers<T extends StoreShift$stockTransfersArgs<ExtArgs> = {}>(args?: Subset<T, StoreShift$stockTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreShift model
   */
  interface StoreShiftFieldRefs {
    readonly id: FieldRef<"StoreShift", 'String'>
    readonly tenantId: FieldRef<"StoreShift", 'String'>
    readonly outletId: FieldRef<"StoreShift", 'String'>
    readonly shiftType: FieldRef<"StoreShift", 'String'>
    readonly openedBy: FieldRef<"StoreShift", 'String'>
    readonly openedAt: FieldRef<"StoreShift", 'DateTime'>
    readonly closedAt: FieldRef<"StoreShift", 'DateTime'>
    readonly status: FieldRef<"StoreShift", 'String'>
    readonly modalAwal: FieldRef<"StoreShift", 'Decimal'>
    readonly catatan: FieldRef<"StoreShift", 'String'>
    readonly createdAt: FieldRef<"StoreShift", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreShift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreShift findUnique
   */
  export type StoreShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * Filter, which StoreShift to fetch.
     */
    where: StoreShiftWhereUniqueInput
  }

  /**
   * StoreShift findUniqueOrThrow
   */
  export type StoreShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * Filter, which StoreShift to fetch.
     */
    where: StoreShiftWhereUniqueInput
  }

  /**
   * StoreShift findFirst
   */
  export type StoreShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * Filter, which StoreShift to fetch.
     */
    where?: StoreShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreShifts to fetch.
     */
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreShifts.
     */
    cursor?: StoreShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreShifts.
     */
    distinct?: StoreShiftScalarFieldEnum | StoreShiftScalarFieldEnum[]
  }

  /**
   * StoreShift findFirstOrThrow
   */
  export type StoreShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * Filter, which StoreShift to fetch.
     */
    where?: StoreShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreShifts to fetch.
     */
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreShifts.
     */
    cursor?: StoreShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreShifts.
     */
    distinct?: StoreShiftScalarFieldEnum | StoreShiftScalarFieldEnum[]
  }

  /**
   * StoreShift findMany
   */
  export type StoreShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * Filter, which StoreShifts to fetch.
     */
    where?: StoreShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreShifts to fetch.
     */
    orderBy?: StoreShiftOrderByWithRelationInput | StoreShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreShifts.
     */
    cursor?: StoreShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreShifts.
     */
    skip?: number
    distinct?: StoreShiftScalarFieldEnum | StoreShiftScalarFieldEnum[]
  }

  /**
   * StoreShift create
   */
  export type StoreShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreShift.
     */
    data: XOR<StoreShiftCreateInput, StoreShiftUncheckedCreateInput>
  }

  /**
   * StoreShift createMany
   */
  export type StoreShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreShifts.
     */
    data: StoreShiftCreateManyInput | StoreShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreShift createManyAndReturn
   */
  export type StoreShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * The data used to create many StoreShifts.
     */
    data: StoreShiftCreateManyInput | StoreShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreShift update
   */
  export type StoreShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreShift.
     */
    data: XOR<StoreShiftUpdateInput, StoreShiftUncheckedUpdateInput>
    /**
     * Choose, which StoreShift to update.
     */
    where: StoreShiftWhereUniqueInput
  }

  /**
   * StoreShift updateMany
   */
  export type StoreShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreShifts.
     */
    data: XOR<StoreShiftUpdateManyMutationInput, StoreShiftUncheckedUpdateManyInput>
    /**
     * Filter which StoreShifts to update
     */
    where?: StoreShiftWhereInput
    /**
     * Limit how many StoreShifts to update.
     */
    limit?: number
  }

  /**
   * StoreShift updateManyAndReturn
   */
  export type StoreShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * The data used to update StoreShifts.
     */
    data: XOR<StoreShiftUpdateManyMutationInput, StoreShiftUncheckedUpdateManyInput>
    /**
     * Filter which StoreShifts to update
     */
    where?: StoreShiftWhereInput
    /**
     * Limit how many StoreShifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreShift upsert
   */
  export type StoreShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreShift to update in case it exists.
     */
    where: StoreShiftWhereUniqueInput
    /**
     * In case the StoreShift found by the `where` argument doesn't exist, create a new StoreShift with this data.
     */
    create: XOR<StoreShiftCreateInput, StoreShiftUncheckedCreateInput>
    /**
     * In case the StoreShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreShiftUpdateInput, StoreShiftUncheckedUpdateInput>
  }

  /**
   * StoreShift delete
   */
  export type StoreShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    /**
     * Filter which StoreShift to delete.
     */
    where: StoreShiftWhereUniqueInput
  }

  /**
   * StoreShift deleteMany
   */
  export type StoreShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreShifts to delete
     */
    where?: StoreShiftWhereInput
    /**
     * Limit how many StoreShifts to delete.
     */
    limit?: number
  }

  /**
   * StoreShift.orders
   */
  export type StoreShift$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * StoreShift.cashShifts
   */
  export type StoreShift$cashShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    where?: CashShiftWhereInput
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    cursor?: CashShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashShiftScalarFieldEnum | CashShiftScalarFieldEnum[]
  }

  /**
   * StoreShift.productAdjustments
   */
  export type StoreShift$productAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAdjustment
     */
    select?: ProductAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductAdjustment
     */
    omit?: ProductAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAdjustmentInclude<ExtArgs> | null
    where?: ProductAdjustmentWhereInput
    orderBy?: ProductAdjustmentOrderByWithRelationInput | ProductAdjustmentOrderByWithRelationInput[]
    cursor?: ProductAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAdjustmentScalarFieldEnum | ProductAdjustmentScalarFieldEnum[]
  }

  /**
   * StoreShift.stockTransfers
   */
  export type StoreShift$stockTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    cursor?: StockTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StoreShift without action
   */
  export type StoreShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
  }


  /**
   * Model CashShift
   */

  export type AggregateCashShift = {
    _count: CashShiftCountAggregateOutputType | null
    _avg: CashShiftAvgAggregateOutputType | null
    _sum: CashShiftSumAggregateOutputType | null
    _min: CashShiftMinAggregateOutputType | null
    _max: CashShiftMaxAggregateOutputType | null
  }

  export type CashShiftAvgAggregateOutputType = {
    modalAwal: Decimal | null
    uangFisikTutup: Decimal | null
    saldoSeharusnya: Decimal | null
    selisih: Decimal | null
  }

  export type CashShiftSumAggregateOutputType = {
    modalAwal: Decimal | null
    uangFisikTutup: Decimal | null
    saldoSeharusnya: Decimal | null
    selisih: Decimal | null
  }

  export type CashShiftMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    storeShiftId: string | null
    kasirId: string | null
    shiftStart: Date | null
    shiftEnd: Date | null
    modalAwal: Decimal | null
    uangFisikTutup: Decimal | null
    saldoSeharusnya: Decimal | null
    selisih: Decimal | null
    status: string | null
    catatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashShiftMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    storeShiftId: string | null
    kasirId: string | null
    shiftStart: Date | null
    shiftEnd: Date | null
    modalAwal: Decimal | null
    uangFisikTutup: Decimal | null
    saldoSeharusnya: Decimal | null
    selisih: Decimal | null
    status: string | null
    catatan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashShiftCountAggregateOutputType = {
    id: number
    tenantId: number
    storeShiftId: number
    kasirId: number
    shiftStart: number
    shiftEnd: number
    modalAwal: number
    uangFisikTutup: number
    saldoSeharusnya: number
    selisih: number
    status: number
    catatan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashShiftAvgAggregateInputType = {
    modalAwal?: true
    uangFisikTutup?: true
    saldoSeharusnya?: true
    selisih?: true
  }

  export type CashShiftSumAggregateInputType = {
    modalAwal?: true
    uangFisikTutup?: true
    saldoSeharusnya?: true
    selisih?: true
  }

  export type CashShiftMinAggregateInputType = {
    id?: true
    tenantId?: true
    storeShiftId?: true
    kasirId?: true
    shiftStart?: true
    shiftEnd?: true
    modalAwal?: true
    uangFisikTutup?: true
    saldoSeharusnya?: true
    selisih?: true
    status?: true
    catatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashShiftMaxAggregateInputType = {
    id?: true
    tenantId?: true
    storeShiftId?: true
    kasirId?: true
    shiftStart?: true
    shiftEnd?: true
    modalAwal?: true
    uangFisikTutup?: true
    saldoSeharusnya?: true
    selisih?: true
    status?: true
    catatan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashShiftCountAggregateInputType = {
    id?: true
    tenantId?: true
    storeShiftId?: true
    kasirId?: true
    shiftStart?: true
    shiftEnd?: true
    modalAwal?: true
    uangFisikTutup?: true
    saldoSeharusnya?: true
    selisih?: true
    status?: true
    catatan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShift to aggregate.
     */
    where?: CashShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShifts to fetch.
     */
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashShifts
    **/
    _count?: true | CashShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashShiftMaxAggregateInputType
  }

  export type GetCashShiftAggregateType<T extends CashShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateCashShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashShift[P]>
      : GetScalarType<T[P], AggregateCashShift[P]>
  }




  export type CashShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShiftWhereInput
    orderBy?: CashShiftOrderByWithAggregationInput | CashShiftOrderByWithAggregationInput[]
    by: CashShiftScalarFieldEnum[] | CashShiftScalarFieldEnum
    having?: CashShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashShiftCountAggregateInputType | true
    _avg?: CashShiftAvgAggregateInputType
    _sum?: CashShiftSumAggregateInputType
    _min?: CashShiftMinAggregateInputType
    _max?: CashShiftMaxAggregateInputType
  }

  export type CashShiftGroupByOutputType = {
    id: string
    tenantId: string
    storeShiftId: string | null
    kasirId: string
    shiftStart: Date
    shiftEnd: Date | null
    modalAwal: Decimal
    uangFisikTutup: Decimal | null
    saldoSeharusnya: Decimal | null
    selisih: Decimal | null
    status: string
    catatan: string | null
    createdAt: Date
    updatedAt: Date
    _count: CashShiftCountAggregateOutputType | null
    _avg: CashShiftAvgAggregateOutputType | null
    _sum: CashShiftSumAggregateOutputType | null
    _min: CashShiftMinAggregateOutputType | null
    _max: CashShiftMaxAggregateOutputType | null
  }

  type GetCashShiftGroupByPayload<T extends CashShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashShiftGroupByOutputType[P]>
            : GetScalarType<T[P], CashShiftGroupByOutputType[P]>
        }
      >
    >


  export type CashShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    storeShiftId?: boolean
    kasirId?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    modalAwal?: boolean
    uangFisikTutup?: boolean
    saldoSeharusnya?: boolean
    selisih?: boolean
    status?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | CashShift$storeShiftArgs<ExtArgs>
    kasir?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashShift"]>

  export type CashShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    storeShiftId?: boolean
    kasirId?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    modalAwal?: boolean
    uangFisikTutup?: boolean
    saldoSeharusnya?: boolean
    selisih?: boolean
    status?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | CashShift$storeShiftArgs<ExtArgs>
    kasir?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashShift"]>

  export type CashShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    storeShiftId?: boolean
    kasirId?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    modalAwal?: boolean
    uangFisikTutup?: boolean
    saldoSeharusnya?: boolean
    selisih?: boolean
    status?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | CashShift$storeShiftArgs<ExtArgs>
    kasir?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashShift"]>

  export type CashShiftSelectScalar = {
    id?: boolean
    tenantId?: boolean
    storeShiftId?: boolean
    kasirId?: boolean
    shiftStart?: boolean
    shiftEnd?: boolean
    modalAwal?: boolean
    uangFisikTutup?: boolean
    saldoSeharusnya?: boolean
    selisih?: boolean
    status?: boolean
    catatan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "storeShiftId" | "kasirId" | "shiftStart" | "shiftEnd" | "modalAwal" | "uangFisikTutup" | "saldoSeharusnya" | "selisih" | "status" | "catatan" | "createdAt" | "updatedAt", ExtArgs["result"]["cashShift"]>
  export type CashShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | CashShift$storeShiftArgs<ExtArgs>
    kasir?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CashShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | CashShift$storeShiftArgs<ExtArgs>
    kasir?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CashShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    storeShift?: boolean | CashShift$storeShiftArgs<ExtArgs>
    kasir?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CashShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashShift"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      storeShift: Prisma.$StoreShiftPayload<ExtArgs> | null
      kasir: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      storeShiftId: string | null
      kasirId: string
      shiftStart: Date
      shiftEnd: Date | null
      modalAwal: Prisma.Decimal
      uangFisikTutup: Prisma.Decimal | null
      saldoSeharusnya: Prisma.Decimal | null
      selisih: Prisma.Decimal | null
      status: string
      catatan: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashShift"]>
    composites: {}
  }

  type CashShiftGetPayload<S extends boolean | null | undefined | CashShiftDefaultArgs> = $Result.GetResult<Prisma.$CashShiftPayload, S>

  type CashShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashShiftCountAggregateInputType | true
    }

  export interface CashShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashShift'], meta: { name: 'CashShift' } }
    /**
     * Find zero or one CashShift that matches the filter.
     * @param {CashShiftFindUniqueArgs} args - Arguments to find a CashShift
     * @example
     * // Get one CashShift
     * const cashShift = await prisma.cashShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashShiftFindUniqueArgs>(args: SelectSubset<T, CashShiftFindUniqueArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashShift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashShiftFindUniqueOrThrowArgs} args - Arguments to find a CashShift
     * @example
     * // Get one CashShift
     * const cashShift = await prisma.cashShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, CashShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftFindFirstArgs} args - Arguments to find a CashShift
     * @example
     * // Get one CashShift
     * const cashShift = await prisma.cashShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashShiftFindFirstArgs>(args?: SelectSubset<T, CashShiftFindFirstArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftFindFirstOrThrowArgs} args - Arguments to find a CashShift
     * @example
     * // Get one CashShift
     * const cashShift = await prisma.cashShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, CashShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashShifts
     * const cashShifts = await prisma.cashShift.findMany()
     * 
     * // Get first 10 CashShifts
     * const cashShifts = await prisma.cashShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashShiftWithIdOnly = await prisma.cashShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashShiftFindManyArgs>(args?: SelectSubset<T, CashShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashShift.
     * @param {CashShiftCreateArgs} args - Arguments to create a CashShift.
     * @example
     * // Create one CashShift
     * const CashShift = await prisma.cashShift.create({
     *   data: {
     *     // ... data to create a CashShift
     *   }
     * })
     * 
     */
    create<T extends CashShiftCreateArgs>(args: SelectSubset<T, CashShiftCreateArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashShifts.
     * @param {CashShiftCreateManyArgs} args - Arguments to create many CashShifts.
     * @example
     * // Create many CashShifts
     * const cashShift = await prisma.cashShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashShiftCreateManyArgs>(args?: SelectSubset<T, CashShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashShifts and returns the data saved in the database.
     * @param {CashShiftCreateManyAndReturnArgs} args - Arguments to create many CashShifts.
     * @example
     * // Create many CashShifts
     * const cashShift = await prisma.cashShift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashShifts and only return the `id`
     * const cashShiftWithIdOnly = await prisma.cashShift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, CashShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashShift.
     * @param {CashShiftDeleteArgs} args - Arguments to delete one CashShift.
     * @example
     * // Delete one CashShift
     * const CashShift = await prisma.cashShift.delete({
     *   where: {
     *     // ... filter to delete one CashShift
     *   }
     * })
     * 
     */
    delete<T extends CashShiftDeleteArgs>(args: SelectSubset<T, CashShiftDeleteArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashShift.
     * @param {CashShiftUpdateArgs} args - Arguments to update one CashShift.
     * @example
     * // Update one CashShift
     * const cashShift = await prisma.cashShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashShiftUpdateArgs>(args: SelectSubset<T, CashShiftUpdateArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashShifts.
     * @param {CashShiftDeleteManyArgs} args - Arguments to filter CashShifts to delete.
     * @example
     * // Delete a few CashShifts
     * const { count } = await prisma.cashShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashShiftDeleteManyArgs>(args?: SelectSubset<T, CashShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashShifts
     * const cashShift = await prisma.cashShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashShiftUpdateManyArgs>(args: SelectSubset<T, CashShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashShifts and returns the data updated in the database.
     * @param {CashShiftUpdateManyAndReturnArgs} args - Arguments to update many CashShifts.
     * @example
     * // Update many CashShifts
     * const cashShift = await prisma.cashShift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashShifts and only return the `id`
     * const cashShiftWithIdOnly = await prisma.cashShift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, CashShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashShift.
     * @param {CashShiftUpsertArgs} args - Arguments to update or create a CashShift.
     * @example
     * // Update or create a CashShift
     * const cashShift = await prisma.cashShift.upsert({
     *   create: {
     *     // ... data to create a CashShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashShift we want to update
     *   }
     * })
     */
    upsert<T extends CashShiftUpsertArgs>(args: SelectSubset<T, CashShiftUpsertArgs<ExtArgs>>): Prisma__CashShiftClient<$Result.GetResult<Prisma.$CashShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftCountArgs} args - Arguments to filter CashShifts to count.
     * @example
     * // Count the number of CashShifts
     * const count = await prisma.cashShift.count({
     *   where: {
     *     // ... the filter for the CashShifts we want to count
     *   }
     * })
    **/
    count<T extends CashShiftCountArgs>(
      args?: Subset<T, CashShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashShiftAggregateArgs>(args: Subset<T, CashShiftAggregateArgs>): Prisma.PrismaPromise<GetCashShiftAggregateType<T>>

    /**
     * Group by CashShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashShiftGroupByArgs['orderBy'] }
        : { orderBy?: CashShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashShift model
   */
  readonly fields: CashShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    storeShift<T extends CashShift$storeShiftArgs<ExtArgs> = {}>(args?: Subset<T, CashShift$storeShiftArgs<ExtArgs>>): Prisma__StoreShiftClient<$Result.GetResult<Prisma.$StoreShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    kasir<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashShift model
   */
  interface CashShiftFieldRefs {
    readonly id: FieldRef<"CashShift", 'String'>
    readonly tenantId: FieldRef<"CashShift", 'String'>
    readonly storeShiftId: FieldRef<"CashShift", 'String'>
    readonly kasirId: FieldRef<"CashShift", 'String'>
    readonly shiftStart: FieldRef<"CashShift", 'DateTime'>
    readonly shiftEnd: FieldRef<"CashShift", 'DateTime'>
    readonly modalAwal: FieldRef<"CashShift", 'Decimal'>
    readonly uangFisikTutup: FieldRef<"CashShift", 'Decimal'>
    readonly saldoSeharusnya: FieldRef<"CashShift", 'Decimal'>
    readonly selisih: FieldRef<"CashShift", 'Decimal'>
    readonly status: FieldRef<"CashShift", 'String'>
    readonly catatan: FieldRef<"CashShift", 'String'>
    readonly createdAt: FieldRef<"CashShift", 'DateTime'>
    readonly updatedAt: FieldRef<"CashShift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashShift findUnique
   */
  export type CashShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * Filter, which CashShift to fetch.
     */
    where: CashShiftWhereUniqueInput
  }

  /**
   * CashShift findUniqueOrThrow
   */
  export type CashShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * Filter, which CashShift to fetch.
     */
    where: CashShiftWhereUniqueInput
  }

  /**
   * CashShift findFirst
   */
  export type CashShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * Filter, which CashShift to fetch.
     */
    where?: CashShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShifts to fetch.
     */
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShifts.
     */
    cursor?: CashShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShifts.
     */
    distinct?: CashShiftScalarFieldEnum | CashShiftScalarFieldEnum[]
  }

  /**
   * CashShift findFirstOrThrow
   */
  export type CashShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * Filter, which CashShift to fetch.
     */
    where?: CashShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShifts to fetch.
     */
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShifts.
     */
    cursor?: CashShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShifts.
     */
    distinct?: CashShiftScalarFieldEnum | CashShiftScalarFieldEnum[]
  }

  /**
   * CashShift findMany
   */
  export type CashShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * Filter, which CashShifts to fetch.
     */
    where?: CashShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShifts to fetch.
     */
    orderBy?: CashShiftOrderByWithRelationInput | CashShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashShifts.
     */
    cursor?: CashShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShifts.
     */
    skip?: number
    distinct?: CashShiftScalarFieldEnum | CashShiftScalarFieldEnum[]
  }

  /**
   * CashShift create
   */
  export type CashShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a CashShift.
     */
    data: XOR<CashShiftCreateInput, CashShiftUncheckedCreateInput>
  }

  /**
   * CashShift createMany
   */
  export type CashShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashShifts.
     */
    data: CashShiftCreateManyInput | CashShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashShift createManyAndReturn
   */
  export type CashShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * The data used to create many CashShifts.
     */
    data: CashShiftCreateManyInput | CashShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashShift update
   */
  export type CashShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a CashShift.
     */
    data: XOR<CashShiftUpdateInput, CashShiftUncheckedUpdateInput>
    /**
     * Choose, which CashShift to update.
     */
    where: CashShiftWhereUniqueInput
  }

  /**
   * CashShift updateMany
   */
  export type CashShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashShifts.
     */
    data: XOR<CashShiftUpdateManyMutationInput, CashShiftUncheckedUpdateManyInput>
    /**
     * Filter which CashShifts to update
     */
    where?: CashShiftWhereInput
    /**
     * Limit how many CashShifts to update.
     */
    limit?: number
  }

  /**
   * CashShift updateManyAndReturn
   */
  export type CashShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * The data used to update CashShifts.
     */
    data: XOR<CashShiftUpdateManyMutationInput, CashShiftUncheckedUpdateManyInput>
    /**
     * Filter which CashShifts to update
     */
    where?: CashShiftWhereInput
    /**
     * Limit how many CashShifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashShift upsert
   */
  export type CashShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the CashShift to update in case it exists.
     */
    where: CashShiftWhereUniqueInput
    /**
     * In case the CashShift found by the `where` argument doesn't exist, create a new CashShift with this data.
     */
    create: XOR<CashShiftCreateInput, CashShiftUncheckedCreateInput>
    /**
     * In case the CashShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashShiftUpdateInput, CashShiftUncheckedUpdateInput>
  }

  /**
   * CashShift delete
   */
  export type CashShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
    /**
     * Filter which CashShift to delete.
     */
    where: CashShiftWhereUniqueInput
  }

  /**
   * CashShift deleteMany
   */
  export type CashShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShifts to delete
     */
    where?: CashShiftWhereInput
    /**
     * Limit how many CashShifts to delete.
     */
    limit?: number
  }

  /**
   * CashShift.storeShift
   */
  export type CashShift$storeShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreShift
     */
    select?: StoreShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreShift
     */
    omit?: StoreShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreShiftInclude<ExtArgs> | null
    where?: StoreShiftWhereInput
  }

  /**
   * CashShift without action
   */
  export type CashShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShift
     */
    select?: CashShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashShift
     */
    omit?: CashShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashShiftInclude<ExtArgs> | null
  }


  /**
   * Model DeviceToken
   */

  export type AggregateDeviceToken = {
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  export type DeviceTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    platform: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceToken to aggregate.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTokens
    **/
    _count?: true | DeviceTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type GetDeviceTokenAggregateType<T extends DeviceTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceToken[P]>
      : GetScalarType<T[P], AggregateDeviceToken[P]>
  }




  export type DeviceTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithAggregationInput | DeviceTokenOrderByWithAggregationInput[]
    by: DeviceTokenScalarFieldEnum[] | DeviceTokenScalarFieldEnum
    having?: DeviceTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTokenCountAggregateInputType | true
    _min?: DeviceTokenMinAggregateInputType
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type DeviceTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    platform: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  type GetDeviceTokenGroupByPayload<T extends DeviceTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "platform" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["deviceToken"]>
  export type DeviceTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      platform: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceToken"]>
    composites: {}
  }

  type DeviceTokenGetPayload<S extends boolean | null | undefined | DeviceTokenDefaultArgs> = $Result.GetResult<Prisma.$DeviceTokenPayload, S>

  type DeviceTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTokenCountAggregateInputType | true
    }

  export interface DeviceTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceToken'], meta: { name: 'DeviceToken' } }
    /**
     * Find zero or one DeviceToken that matches the filter.
     * @param {DeviceTokenFindUniqueArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTokenFindUniqueArgs>(args: SelectSubset<T, DeviceTokenFindUniqueArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTokenFindUniqueOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTokenFindFirstArgs>(args?: SelectSubset<T, DeviceTokenFindFirstArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany()
     * 
     * // Get first 10 DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTokenFindManyArgs>(args?: SelectSubset<T, DeviceTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceToken.
     * @param {DeviceTokenCreateArgs} args - Arguments to create a DeviceToken.
     * @example
     * // Create one DeviceToken
     * const DeviceToken = await prisma.deviceToken.create({
     *   data: {
     *     // ... data to create a DeviceToken
     *   }
     * })
     * 
     */
    create<T extends DeviceTokenCreateArgs>(args: SelectSubset<T, DeviceTokenCreateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTokens.
     * @param {DeviceTokenCreateManyArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTokenCreateManyArgs>(args?: SelectSubset<T, DeviceTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTokens and returns the data saved in the database.
     * @param {DeviceTokenCreateManyAndReturnArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceToken.
     * @param {DeviceTokenDeleteArgs} args - Arguments to delete one DeviceToken.
     * @example
     * // Delete one DeviceToken
     * const DeviceToken = await prisma.deviceToken.delete({
     *   where: {
     *     // ... filter to delete one DeviceToken
     *   }
     * })
     * 
     */
    delete<T extends DeviceTokenDeleteArgs>(args: SelectSubset<T, DeviceTokenDeleteArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceToken.
     * @param {DeviceTokenUpdateArgs} args - Arguments to update one DeviceToken.
     * @example
     * // Update one DeviceToken
     * const deviceToken = await prisma.deviceToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTokenUpdateArgs>(args: SelectSubset<T, DeviceTokenUpdateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTokens.
     * @param {DeviceTokenDeleteManyArgs} args - Arguments to filter DeviceTokens to delete.
     * @example
     * // Delete a few DeviceTokens
     * const { count } = await prisma.deviceToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTokenDeleteManyArgs>(args?: SelectSubset<T, DeviceTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTokenUpdateManyArgs>(args: SelectSubset<T, DeviceTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens and returns the data updated in the database.
     * @param {DeviceTokenUpdateManyAndReturnArgs} args - Arguments to update many DeviceTokens.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceToken.
     * @param {DeviceTokenUpsertArgs} args - Arguments to update or create a DeviceToken.
     * @example
     * // Update or create a DeviceToken
     * const deviceToken = await prisma.deviceToken.upsert({
     *   create: {
     *     // ... data to create a DeviceToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceToken we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTokenUpsertArgs>(args: SelectSubset<T, DeviceTokenUpsertArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenCountArgs} args - Arguments to filter DeviceTokens to count.
     * @example
     * // Count the number of DeviceTokens
     * const count = await prisma.deviceToken.count({
     *   where: {
     *     // ... the filter for the DeviceTokens we want to count
     *   }
     * })
    **/
    count<T extends DeviceTokenCountArgs>(
      args?: Subset<T, DeviceTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTokenAggregateArgs>(args: Subset<T, DeviceTokenAggregateArgs>): Prisma.PrismaPromise<GetDeviceTokenAggregateType<T>>

    /**
     * Group by DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTokenGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceToken model
   */
  readonly fields: DeviceTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceToken model
   */
  interface DeviceTokenFieldRefs {
    readonly id: FieldRef<"DeviceToken", 'String'>
    readonly userId: FieldRef<"DeviceToken", 'String'>
    readonly token: FieldRef<"DeviceToken", 'String'>
    readonly platform: FieldRef<"DeviceToken", 'String'>
    readonly isActive: FieldRef<"DeviceToken", 'Boolean'>
    readonly createdAt: FieldRef<"DeviceToken", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceToken findUnique
   */
  export type DeviceTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findUniqueOrThrow
   */
  export type DeviceTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findFirst
   */
  export type DeviceTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findFirstOrThrow
   */
  export type DeviceTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findMany
   */
  export type DeviceTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTokens to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken create
   */
  export type DeviceTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceToken.
     */
    data: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
  }

  /**
   * DeviceToken createMany
   */
  export type DeviceTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceToken createManyAndReturn
   */
  export type DeviceTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken update
   */
  export type DeviceTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceToken.
     */
    data: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
    /**
     * Choose, which DeviceToken to update.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken updateMany
   */
  export type DeviceTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
  }

  /**
   * DeviceToken updateManyAndReturn
   */
  export type DeviceTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken upsert
   */
  export type DeviceTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceToken to update in case it exists.
     */
    where: DeviceTokenWhereUniqueInput
    /**
     * In case the DeviceToken found by the `where` argument doesn't exist, create a new DeviceToken with this data.
     */
    create: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
    /**
     * In case the DeviceToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
  }

  /**
   * DeviceToken delete
   */
  export type DeviceTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter which DeviceToken to delete.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken deleteMany
   */
  export type DeviceTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTokens to delete
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to delete.
     */
    limit?: number
  }

  /**
   * DeviceToken without action
   */
  export type DeviceTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
  }


  /**
   * Model CourierConfig
   */

  export type AggregateCourierConfig = {
    _count: CourierConfigCountAggregateOutputType | null
    _min: CourierConfigMinAggregateOutputType | null
    _max: CourierConfigMaxAggregateOutputType | null
  }

  export type CourierConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    courier: string | null
    apiKey: string | null
    apiSecret: string | null
    baseUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourierConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    courier: string | null
    apiKey: string | null
    apiSecret: string | null
    baseUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourierConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    courier: number
    apiKey: number
    apiSecret: number
    baseUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourierConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    courier?: true
    apiKey?: true
    apiSecret?: true
    baseUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourierConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    courier?: true
    apiKey?: true
    apiSecret?: true
    baseUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourierConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    courier?: true
    apiKey?: true
    apiSecret?: true
    baseUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourierConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourierConfig to aggregate.
     */
    where?: CourierConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierConfigs to fetch.
     */
    orderBy?: CourierConfigOrderByWithRelationInput | CourierConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourierConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourierConfigs
    **/
    _count?: true | CourierConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourierConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourierConfigMaxAggregateInputType
  }

  export type GetCourierConfigAggregateType<T extends CourierConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateCourierConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourierConfig[P]>
      : GetScalarType<T[P], AggregateCourierConfig[P]>
  }




  export type CourierConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierConfigWhereInput
    orderBy?: CourierConfigOrderByWithAggregationInput | CourierConfigOrderByWithAggregationInput[]
    by: CourierConfigScalarFieldEnum[] | CourierConfigScalarFieldEnum
    having?: CourierConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourierConfigCountAggregateInputType | true
    _min?: CourierConfigMinAggregateInputType
    _max?: CourierConfigMaxAggregateInputType
  }

  export type CourierConfigGroupByOutputType = {
    id: string
    tenantId: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CourierConfigCountAggregateOutputType | null
    _min: CourierConfigMinAggregateOutputType | null
    _max: CourierConfigMaxAggregateOutputType | null
  }

  type GetCourierConfigGroupByPayload<T extends CourierConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourierConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourierConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourierConfigGroupByOutputType[P]>
            : GetScalarType<T[P], CourierConfigGroupByOutputType[P]>
        }
      >
    >


  export type CourierConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    courier?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    baseUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courierConfig"]>

  export type CourierConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    courier?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    baseUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courierConfig"]>

  export type CourierConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    courier?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    baseUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courierConfig"]>

  export type CourierConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    courier?: boolean
    apiKey?: boolean
    apiSecret?: boolean
    baseUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourierConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "courier" | "apiKey" | "apiSecret" | "baseUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["courierConfig"]>
  export type CourierConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CourierConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CourierConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CourierConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourierConfig"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      courier: string
      apiKey: string
      apiSecret: string
      baseUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courierConfig"]>
    composites: {}
  }

  type CourierConfigGetPayload<S extends boolean | null | undefined | CourierConfigDefaultArgs> = $Result.GetResult<Prisma.$CourierConfigPayload, S>

  type CourierConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourierConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourierConfigCountAggregateInputType | true
    }

  export interface CourierConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourierConfig'], meta: { name: 'CourierConfig' } }
    /**
     * Find zero or one CourierConfig that matches the filter.
     * @param {CourierConfigFindUniqueArgs} args - Arguments to find a CourierConfig
     * @example
     * // Get one CourierConfig
     * const courierConfig = await prisma.courierConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourierConfigFindUniqueArgs>(args: SelectSubset<T, CourierConfigFindUniqueArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourierConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourierConfigFindUniqueOrThrowArgs} args - Arguments to find a CourierConfig
     * @example
     * // Get one CourierConfig
     * const courierConfig = await prisma.courierConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourierConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, CourierConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourierConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigFindFirstArgs} args - Arguments to find a CourierConfig
     * @example
     * // Get one CourierConfig
     * const courierConfig = await prisma.courierConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourierConfigFindFirstArgs>(args?: SelectSubset<T, CourierConfigFindFirstArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourierConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigFindFirstOrThrowArgs} args - Arguments to find a CourierConfig
     * @example
     * // Get one CourierConfig
     * const courierConfig = await prisma.courierConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourierConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, CourierConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourierConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourierConfigs
     * const courierConfigs = await prisma.courierConfig.findMany()
     * 
     * // Get first 10 CourierConfigs
     * const courierConfigs = await prisma.courierConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courierConfigWithIdOnly = await prisma.courierConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourierConfigFindManyArgs>(args?: SelectSubset<T, CourierConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourierConfig.
     * @param {CourierConfigCreateArgs} args - Arguments to create a CourierConfig.
     * @example
     * // Create one CourierConfig
     * const CourierConfig = await prisma.courierConfig.create({
     *   data: {
     *     // ... data to create a CourierConfig
     *   }
     * })
     * 
     */
    create<T extends CourierConfigCreateArgs>(args: SelectSubset<T, CourierConfigCreateArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourierConfigs.
     * @param {CourierConfigCreateManyArgs} args - Arguments to create many CourierConfigs.
     * @example
     * // Create many CourierConfigs
     * const courierConfig = await prisma.courierConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourierConfigCreateManyArgs>(args?: SelectSubset<T, CourierConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourierConfigs and returns the data saved in the database.
     * @param {CourierConfigCreateManyAndReturnArgs} args - Arguments to create many CourierConfigs.
     * @example
     * // Create many CourierConfigs
     * const courierConfig = await prisma.courierConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourierConfigs and only return the `id`
     * const courierConfigWithIdOnly = await prisma.courierConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourierConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, CourierConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourierConfig.
     * @param {CourierConfigDeleteArgs} args - Arguments to delete one CourierConfig.
     * @example
     * // Delete one CourierConfig
     * const CourierConfig = await prisma.courierConfig.delete({
     *   where: {
     *     // ... filter to delete one CourierConfig
     *   }
     * })
     * 
     */
    delete<T extends CourierConfigDeleteArgs>(args: SelectSubset<T, CourierConfigDeleteArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourierConfig.
     * @param {CourierConfigUpdateArgs} args - Arguments to update one CourierConfig.
     * @example
     * // Update one CourierConfig
     * const courierConfig = await prisma.courierConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourierConfigUpdateArgs>(args: SelectSubset<T, CourierConfigUpdateArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourierConfigs.
     * @param {CourierConfigDeleteManyArgs} args - Arguments to filter CourierConfigs to delete.
     * @example
     * // Delete a few CourierConfigs
     * const { count } = await prisma.courierConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourierConfigDeleteManyArgs>(args?: SelectSubset<T, CourierConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourierConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourierConfigs
     * const courierConfig = await prisma.courierConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourierConfigUpdateManyArgs>(args: SelectSubset<T, CourierConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourierConfigs and returns the data updated in the database.
     * @param {CourierConfigUpdateManyAndReturnArgs} args - Arguments to update many CourierConfigs.
     * @example
     * // Update many CourierConfigs
     * const courierConfig = await prisma.courierConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourierConfigs and only return the `id`
     * const courierConfigWithIdOnly = await prisma.courierConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourierConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, CourierConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourierConfig.
     * @param {CourierConfigUpsertArgs} args - Arguments to update or create a CourierConfig.
     * @example
     * // Update or create a CourierConfig
     * const courierConfig = await prisma.courierConfig.upsert({
     *   create: {
     *     // ... data to create a CourierConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourierConfig we want to update
     *   }
     * })
     */
    upsert<T extends CourierConfigUpsertArgs>(args: SelectSubset<T, CourierConfigUpsertArgs<ExtArgs>>): Prisma__CourierConfigClient<$Result.GetResult<Prisma.$CourierConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourierConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigCountArgs} args - Arguments to filter CourierConfigs to count.
     * @example
     * // Count the number of CourierConfigs
     * const count = await prisma.courierConfig.count({
     *   where: {
     *     // ... the filter for the CourierConfigs we want to count
     *   }
     * })
    **/
    count<T extends CourierConfigCountArgs>(
      args?: Subset<T, CourierConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourierConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourierConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourierConfigAggregateArgs>(args: Subset<T, CourierConfigAggregateArgs>): Prisma.PrismaPromise<GetCourierConfigAggregateType<T>>

    /**
     * Group by CourierConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourierConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourierConfigGroupByArgs['orderBy'] }
        : { orderBy?: CourierConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourierConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourierConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourierConfig model
   */
  readonly fields: CourierConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourierConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourierConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourierConfig model
   */
  interface CourierConfigFieldRefs {
    readonly id: FieldRef<"CourierConfig", 'String'>
    readonly tenantId: FieldRef<"CourierConfig", 'String'>
    readonly courier: FieldRef<"CourierConfig", 'String'>
    readonly apiKey: FieldRef<"CourierConfig", 'String'>
    readonly apiSecret: FieldRef<"CourierConfig", 'String'>
    readonly baseUrl: FieldRef<"CourierConfig", 'String'>
    readonly isActive: FieldRef<"CourierConfig", 'Boolean'>
    readonly createdAt: FieldRef<"CourierConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"CourierConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourierConfig findUnique
   */
  export type CourierConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * Filter, which CourierConfig to fetch.
     */
    where: CourierConfigWhereUniqueInput
  }

  /**
   * CourierConfig findUniqueOrThrow
   */
  export type CourierConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * Filter, which CourierConfig to fetch.
     */
    where: CourierConfigWhereUniqueInput
  }

  /**
   * CourierConfig findFirst
   */
  export type CourierConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * Filter, which CourierConfig to fetch.
     */
    where?: CourierConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierConfigs to fetch.
     */
    orderBy?: CourierConfigOrderByWithRelationInput | CourierConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourierConfigs.
     */
    cursor?: CourierConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourierConfigs.
     */
    distinct?: CourierConfigScalarFieldEnum | CourierConfigScalarFieldEnum[]
  }

  /**
   * CourierConfig findFirstOrThrow
   */
  export type CourierConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * Filter, which CourierConfig to fetch.
     */
    where?: CourierConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierConfigs to fetch.
     */
    orderBy?: CourierConfigOrderByWithRelationInput | CourierConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourierConfigs.
     */
    cursor?: CourierConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourierConfigs.
     */
    distinct?: CourierConfigScalarFieldEnum | CourierConfigScalarFieldEnum[]
  }

  /**
   * CourierConfig findMany
   */
  export type CourierConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * Filter, which CourierConfigs to fetch.
     */
    where?: CourierConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourierConfigs to fetch.
     */
    orderBy?: CourierConfigOrderByWithRelationInput | CourierConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourierConfigs.
     */
    cursor?: CourierConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourierConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourierConfigs.
     */
    skip?: number
    distinct?: CourierConfigScalarFieldEnum | CourierConfigScalarFieldEnum[]
  }

  /**
   * CourierConfig create
   */
  export type CourierConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a CourierConfig.
     */
    data: XOR<CourierConfigCreateInput, CourierConfigUncheckedCreateInput>
  }

  /**
   * CourierConfig createMany
   */
  export type CourierConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourierConfigs.
     */
    data: CourierConfigCreateManyInput | CourierConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourierConfig createManyAndReturn
   */
  export type CourierConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * The data used to create many CourierConfigs.
     */
    data: CourierConfigCreateManyInput | CourierConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourierConfig update
   */
  export type CourierConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a CourierConfig.
     */
    data: XOR<CourierConfigUpdateInput, CourierConfigUncheckedUpdateInput>
    /**
     * Choose, which CourierConfig to update.
     */
    where: CourierConfigWhereUniqueInput
  }

  /**
   * CourierConfig updateMany
   */
  export type CourierConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourierConfigs.
     */
    data: XOR<CourierConfigUpdateManyMutationInput, CourierConfigUncheckedUpdateManyInput>
    /**
     * Filter which CourierConfigs to update
     */
    where?: CourierConfigWhereInput
    /**
     * Limit how many CourierConfigs to update.
     */
    limit?: number
  }

  /**
   * CourierConfig updateManyAndReturn
   */
  export type CourierConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * The data used to update CourierConfigs.
     */
    data: XOR<CourierConfigUpdateManyMutationInput, CourierConfigUncheckedUpdateManyInput>
    /**
     * Filter which CourierConfigs to update
     */
    where?: CourierConfigWhereInput
    /**
     * Limit how many CourierConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourierConfig upsert
   */
  export type CourierConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the CourierConfig to update in case it exists.
     */
    where: CourierConfigWhereUniqueInput
    /**
     * In case the CourierConfig found by the `where` argument doesn't exist, create a new CourierConfig with this data.
     */
    create: XOR<CourierConfigCreateInput, CourierConfigUncheckedCreateInput>
    /**
     * In case the CourierConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourierConfigUpdateInput, CourierConfigUncheckedUpdateInput>
  }

  /**
   * CourierConfig delete
   */
  export type CourierConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
    /**
     * Filter which CourierConfig to delete.
     */
    where: CourierConfigWhereUniqueInput
  }

  /**
   * CourierConfig deleteMany
   */
  export type CourierConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourierConfigs to delete
     */
    where?: CourierConfigWhereInput
    /**
     * Limit how many CourierConfigs to delete.
     */
    limit?: number
  }

  /**
   * CourierConfig without action
   */
  export type CourierConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourierConfig
     */
    select?: CourierConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourierConfig
     */
    omit?: CourierConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourierConfigInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsAvgAggregateOutputType = {
    maxTenants: number | null
    maxUsersPerTenant: number | null
  }

  export type SystemSettingsSumAggregateOutputType = {
    maxTenants: number | null
    maxUsersPerTenant: number | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    appName: string | null
    version: string | null
    maintenanceMode: boolean | null
    allowRegistration: boolean | null
    maxTenants: number | null
    maxUsersPerTenant: number | null
    multiOutletEnabled: boolean | null
    deliveryEnabled: boolean | null
    accountingEnabled: boolean | null
    enable2FA: boolean | null
    requireStrongPassword: boolean | null
    supportEmail: string | null
    timezone: string | null
    lastModifiedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    appName: string | null
    version: string | null
    maintenanceMode: boolean | null
    allowRegistration: boolean | null
    maxTenants: number | null
    maxUsersPerTenant: number | null
    multiOutletEnabled: boolean | null
    deliveryEnabled: boolean | null
    accountingEnabled: boolean | null
    enable2FA: boolean | null
    requireStrongPassword: boolean | null
    supportEmail: string | null
    timezone: string | null
    lastModifiedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    appName: number
    version: number
    maintenanceMode: number
    allowRegistration: number
    maxTenants: number
    maxUsersPerTenant: number
    multiOutletEnabled: number
    deliveryEnabled: number
    accountingEnabled: number
    enable2FA: number
    requireStrongPassword: number
    supportEmail: number
    timezone: number
    customSettings: number
    lastModifiedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsAvgAggregateInputType = {
    maxTenants?: true
    maxUsersPerTenant?: true
  }

  export type SystemSettingsSumAggregateInputType = {
    maxTenants?: true
    maxUsersPerTenant?: true
  }

  export type SystemSettingsMinAggregateInputType = {
    id?: true
    appName?: true
    version?: true
    maintenanceMode?: true
    allowRegistration?: true
    maxTenants?: true
    maxUsersPerTenant?: true
    multiOutletEnabled?: true
    deliveryEnabled?: true
    accountingEnabled?: true
    enable2FA?: true
    requireStrongPassword?: true
    supportEmail?: true
    timezone?: true
    lastModifiedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    appName?: true
    version?: true
    maintenanceMode?: true
    allowRegistration?: true
    maxTenants?: true
    maxUsersPerTenant?: true
    multiOutletEnabled?: true
    deliveryEnabled?: true
    accountingEnabled?: true
    enable2FA?: true
    requireStrongPassword?: true
    supportEmail?: true
    timezone?: true
    lastModifiedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    appName?: true
    version?: true
    maintenanceMode?: true
    allowRegistration?: true
    maxTenants?: true
    maxUsersPerTenant?: true
    multiOutletEnabled?: true
    deliveryEnabled?: true
    accountingEnabled?: true
    enable2FA?: true
    requireStrongPassword?: true
    supportEmail?: true
    timezone?: true
    customSettings?: true
    lastModifiedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _avg?: SystemSettingsAvgAggregateInputType
    _sum?: SystemSettingsSumAggregateInputType
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    appName: string
    version: string
    maintenanceMode: boolean
    allowRegistration: boolean
    maxTenants: number
    maxUsersPerTenant: number
    multiOutletEnabled: boolean
    deliveryEnabled: boolean
    accountingEnabled: boolean
    enable2FA: boolean
    requireStrongPassword: boolean
    supportEmail: string | null
    timezone: string
    customSettings: JsonValue | null
    lastModifiedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appName?: boolean
    version?: boolean
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: boolean
    maxUsersPerTenant?: boolean
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: boolean
    timezone?: boolean
    customSettings?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appName?: boolean
    version?: boolean
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: boolean
    maxUsersPerTenant?: boolean
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: boolean
    timezone?: boolean
    customSettings?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appName?: boolean
    version?: boolean
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: boolean
    maxUsersPerTenant?: boolean
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: boolean
    timezone?: boolean
    customSettings?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    appName?: boolean
    version?: boolean
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: boolean
    maxUsersPerTenant?: boolean
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: boolean
    timezone?: boolean
    customSettings?: boolean
    lastModifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appName" | "version" | "maintenanceMode" | "allowRegistration" | "maxTenants" | "maxUsersPerTenant" | "multiOutletEnabled" | "deliveryEnabled" | "accountingEnabled" | "enable2FA" | "requireStrongPassword" | "supportEmail" | "timezone" | "customSettings" | "lastModifiedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appName: string
      version: string
      maintenanceMode: boolean
      allowRegistration: boolean
      maxTenants: number
      maxUsersPerTenant: number
      multiOutletEnabled: boolean
      deliveryEnabled: boolean
      accountingEnabled: boolean
      enable2FA: boolean
      requireStrongPassword: boolean
      supportEmail: string | null
      timezone: string
      customSettings: Prisma.JsonValue | null
      lastModifiedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly appName: FieldRef<"SystemSettings", 'String'>
    readonly version: FieldRef<"SystemSettings", 'String'>
    readonly maintenanceMode: FieldRef<"SystemSettings", 'Boolean'>
    readonly allowRegistration: FieldRef<"SystemSettings", 'Boolean'>
    readonly maxTenants: FieldRef<"SystemSettings", 'Int'>
    readonly maxUsersPerTenant: FieldRef<"SystemSettings", 'Int'>
    readonly multiOutletEnabled: FieldRef<"SystemSettings", 'Boolean'>
    readonly deliveryEnabled: FieldRef<"SystemSettings", 'Boolean'>
    readonly accountingEnabled: FieldRef<"SystemSettings", 'Boolean'>
    readonly enable2FA: FieldRef<"SystemSettings", 'Boolean'>
    readonly requireStrongPassword: FieldRef<"SystemSettings", 'Boolean'>
    readonly supportEmail: FieldRef<"SystemSettings", 'String'>
    readonly timezone: FieldRef<"SystemSettings", 'String'>
    readonly customSettings: FieldRef<"SystemSettings", 'Json'>
    readonly lastModifiedBy: FieldRef<"SystemSettings", 'String'>
    readonly createdAt: FieldRef<"SystemSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model ContactSubmission
   */

  export type AggregateContactSubmission = {
    _count: ContactSubmissionCountAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  export type ContactSubmissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    type: string | null
    status: string | null
    isRead: boolean | null
    readAt: Date | null
    reply: string | null
    repliedAt: Date | null
    repliedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactSubmissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    type: string | null
    status: string | null
    isRead: boolean | null
    readAt: Date | null
    reply: string | null
    repliedAt: Date | null
    repliedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactSubmissionCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    type: number
    status: number
    isRead: number
    readAt: number
    reply: number
    repliedAt: number
    repliedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactSubmissionMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    type?: true
    status?: true
    isRead?: true
    readAt?: true
    reply?: true
    repliedAt?: true
    repliedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactSubmissionMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    type?: true
    status?: true
    isRead?: true
    readAt?: true
    reply?: true
    repliedAt?: true
    repliedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactSubmissionCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    type?: true
    status?: true
    isRead?: true
    readAt?: true
    reply?: true
    repliedAt?: true
    repliedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmission to aggregate.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactSubmissions
    **/
    _count?: true | ContactSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type GetContactSubmissionAggregateType<T extends ContactSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateContactSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactSubmission[P]>
      : GetScalarType<T[P], AggregateContactSubmission[P]>
  }




  export type ContactSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSubmissionWhereInput
    orderBy?: ContactSubmissionOrderByWithAggregationInput | ContactSubmissionOrderByWithAggregationInput[]
    by: ContactSubmissionScalarFieldEnum[] | ContactSubmissionScalarFieldEnum
    having?: ContactSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactSubmissionCountAggregateInputType | true
    _min?: ContactSubmissionMinAggregateInputType
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type ContactSubmissionGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    subject: string
    message: string
    type: string
    status: string
    isRead: boolean
    readAt: Date | null
    reply: string | null
    repliedAt: Date | null
    repliedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactSubmissionCountAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  type GetContactSubmissionGroupByPayload<T extends ContactSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ContactSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    status?: boolean
    isRead?: boolean
    readAt?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    status?: boolean
    isRead?: boolean
    readAt?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    status?: boolean
    isRead?: boolean
    readAt?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    status?: boolean
    isRead?: boolean
    readAt?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "subject" | "message" | "type" | "status" | "isRead" | "readAt" | "reply" | "repliedAt" | "repliedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["contactSubmission"]>

  export type $ContactSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactSubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      subject: string
      message: string
      type: string
      status: string
      isRead: boolean
      readAt: Date | null
      reply: string | null
      repliedAt: Date | null
      repliedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactSubmission"]>
    composites: {}
  }

  type ContactSubmissionGetPayload<S extends boolean | null | undefined | ContactSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ContactSubmissionPayload, S>

  type ContactSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactSubmissionCountAggregateInputType | true
    }

  export interface ContactSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactSubmission'], meta: { name: 'ContactSubmission' } }
    /**
     * Find zero or one ContactSubmission that matches the filter.
     * @param {ContactSubmissionFindUniqueArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactSubmissionFindUniqueArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactSubmissionFindFirstArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany()
     * 
     * // Get first 10 ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactSubmissionFindManyArgs>(args?: SelectSubset<T, ContactSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactSubmission.
     * @param {ContactSubmissionCreateArgs} args - Arguments to create a ContactSubmission.
     * @example
     * // Create one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.create({
     *   data: {
     *     // ... data to create a ContactSubmission
     *   }
     * })
     * 
     */
    create<T extends ContactSubmissionCreateArgs>(args: SelectSubset<T, ContactSubmissionCreateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactSubmissions.
     * @param {ContactSubmissionCreateManyArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactSubmissionCreateManyArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactSubmissions and returns the data saved in the database.
     * @param {ContactSubmissionCreateManyAndReturnArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactSubmission.
     * @param {ContactSubmissionDeleteArgs} args - Arguments to delete one ContactSubmission.
     * @example
     * // Delete one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.delete({
     *   where: {
     *     // ... filter to delete one ContactSubmission
     *   }
     * })
     * 
     */
    delete<T extends ContactSubmissionDeleteArgs>(args: SelectSubset<T, ContactSubmissionDeleteArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactSubmission.
     * @param {ContactSubmissionUpdateArgs} args - Arguments to update one ContactSubmission.
     * @example
     * // Update one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactSubmissionUpdateArgs>(args: SelectSubset<T, ContactSubmissionUpdateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactSubmissions.
     * @param {ContactSubmissionDeleteManyArgs} args - Arguments to filter ContactSubmissions to delete.
     * @example
     * // Delete a few ContactSubmissions
     * const { count } = await prisma.contactSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactSubmissionDeleteManyArgs>(args?: SelectSubset<T, ContactSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactSubmissionUpdateManyArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions and returns the data updated in the database.
     * @param {ContactSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ContactSubmissions.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactSubmission.
     * @param {ContactSubmissionUpsertArgs} args - Arguments to update or create a ContactSubmission.
     * @example
     * // Update or create a ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.upsert({
     *   create: {
     *     // ... data to create a ContactSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ContactSubmissionUpsertArgs>(args: SelectSubset<T, ContactSubmissionUpsertArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionCountArgs} args - Arguments to filter ContactSubmissions to count.
     * @example
     * // Count the number of ContactSubmissions
     * const count = await prisma.contactSubmission.count({
     *   where: {
     *     // ... the filter for the ContactSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ContactSubmissionCountArgs>(
      args?: Subset<T, ContactSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactSubmissionAggregateArgs>(args: Subset<T, ContactSubmissionAggregateArgs>): Prisma.PrismaPromise<GetContactSubmissionAggregateType<T>>

    /**
     * Group by ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ContactSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactSubmission model
   */
  readonly fields: ContactSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactSubmission model
   */
  interface ContactSubmissionFieldRefs {
    readonly id: FieldRef<"ContactSubmission", 'String'>
    readonly name: FieldRef<"ContactSubmission", 'String'>
    readonly email: FieldRef<"ContactSubmission", 'String'>
    readonly phone: FieldRef<"ContactSubmission", 'String'>
    readonly subject: FieldRef<"ContactSubmission", 'String'>
    readonly message: FieldRef<"ContactSubmission", 'String'>
    readonly type: FieldRef<"ContactSubmission", 'String'>
    readonly status: FieldRef<"ContactSubmission", 'String'>
    readonly isRead: FieldRef<"ContactSubmission", 'Boolean'>
    readonly readAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly reply: FieldRef<"ContactSubmission", 'String'>
    readonly repliedAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly repliedBy: FieldRef<"ContactSubmission", 'String'>
    readonly createdAt: FieldRef<"ContactSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactSubmission findUnique
   */
  export type ContactSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findUniqueOrThrow
   */
  export type ContactSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findFirst
   */
  export type ContactSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findFirstOrThrow
   */
  export type ContactSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findMany
   */
  export type ContactSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmissions to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission create
   */
  export type ContactSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactSubmission.
     */
    data: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
  }

  /**
   * ContactSubmission createMany
   */
  export type ContactSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission createManyAndReturn
   */
  export type ContactSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission update
   */
  export type ContactSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactSubmission.
     */
    data: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ContactSubmission to update.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission updateMany
   */
  export type ContactSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission updateManyAndReturn
   */
  export type ContactSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission upsert
   */
  export type ContactSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactSubmission to update in case it exists.
     */
    where: ContactSubmissionWhereUniqueInput
    /**
     * In case the ContactSubmission found by the `where` argument doesn't exist, create a new ContactSubmission with this data.
     */
    create: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
    /**
     * In case the ContactSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
  }

  /**
   * ContactSubmission delete
   */
  export type ContactSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter which ContactSubmission to delete.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission deleteMany
   */
  export type ContactSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmissions to delete
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ContactSubmission without action
   */
  export type ContactSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    type: string | null
    priority: string | null
    status: string | null
    reply: string | null
    repliedAt: Date | null
    repliedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    type: string | null
    priority: string | null
    status: string | null
    reply: string | null
    repliedAt: Date | null
    repliedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    name: number
    email: number
    subject: number
    message: number
    type: number
    priority: number
    status: number
    reply: number
    repliedAt: number
    repliedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    type?: true
    priority?: true
    status?: true
    reply?: true
    repliedAt?: true
    repliedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    type?: true
    priority?: true
    status?: true
    reply?: true
    repliedAt?: true
    repliedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    type?: true
    priority?: true
    status?: true
    reply?: true
    repliedAt?: true
    repliedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    tenantId: string | null
    userId: string | null
    name: string
    email: string
    subject: string
    message: string
    type: string
    priority: string
    status: string
    reply: string | null
    repliedAt: Date | null
    repliedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | SupportTicket$tenantArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | SupportTicket$tenantArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | SupportTicket$tenantArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    reply?: boolean
    repliedAt?: boolean
    repliedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "name" | "email" | "subject" | "message" | "type" | "priority" | "status" | "reply" | "repliedAt" | "repliedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | SupportTicket$tenantArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | SupportTicket$tenantArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | SupportTicket$tenantArgs<ExtArgs>
    user?: boolean | SupportTicket$userArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      userId: string | null
      name: string
      email: string
      subject: string
      message: string
      type: string
      priority: string
      status: string
      reply: string | null
      repliedAt: Date | null
      repliedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends SupportTicket$tenantArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends SupportTicket$userArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly tenantId: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly name: FieldRef<"SupportTicket", 'String'>
    readonly email: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly message: FieldRef<"SupportTicket", 'String'>
    readonly type: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly reply: FieldRef<"SupportTicket", 'String'>
    readonly repliedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly repliedBy: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.tenant
   */
  export type SupportTicket$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * SupportTicket.user
   */
  export type SupportTicket$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    email: 'email',
    phone: 'phone',
    address: 'address',
    isActive: 'isActive',
    subscriptionStart: 'subscriptionStart',
    subscriptionEnd: 'subscriptionEnd',
    subscriptionPlan: 'subscriptionPlan',
    previousPlan: 'previousPlan',
    temporaryUpgrade: 'temporaryUpgrade',
    features: 'features',
    tenantsActive: 'tenantsActive',
    tenantsLimit: 'tenantsLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    permissions: 'permissions',
    lastLogin: 'lastLogin',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    passwordHistory: 'passwordHistory',
    passwordChangedAt: 'passwordChangedAt',
    mustChangePassword: 'mustChangePassword',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    sku: 'sku',
    barcode: 'barcode',
    price: 'price',
    cost: 'cost',
    stock: 'stock',
    minStock: 'minStock',
    category: 'category',
    image: 'image',
    emoji: 'emoji',
    isActive: 'isActive',
    isConsignment: 'isConsignment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductAdjustmentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    productId: 'productId',
    userId: 'userId',
    storeShiftId: 'storeShiftId',
    type: 'type',
    quantity: 'quantity',
    reason: 'reason',
    stockBefore: 'stockBefore',
    stockAfter: 'stockAfter',
    createdAt: 'createdAt'
  };

  export type ProductAdjustmentScalarFieldEnum = (typeof ProductAdjustmentScalarFieldEnum)[keyof typeof ProductAdjustmentScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    idempotencyKey: 'idempotencyKey',
    tenantId: 'tenantId',
    orderNumber: 'orderNumber',
    userId: 'userId',
    customerId: 'customerId',
    memberId: 'memberId',
    outletId: 'outletId',
    storeShiftId: 'storeShiftId',
    total: 'total',
    discount: 'discount',
    subtotal: 'subtotal',
    status: 'status',
    sendToKitchen: 'sendToKitchen',
    kitchenStatus: 'kitchenStatus',
    temporaryCustomerName: 'temporaryCustomerName',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    cost: 'cost',
    subtotal: 'subtotal',
    profit: 'profit',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaymentMappingScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    tenantId: 'tenantId',
    itemId: 'itemId',
    itemType: 'itemType',
    itemName: 'itemName',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMappingScalarFieldEnum = (typeof PaymentMappingScalarFieldEnum)[keyof typeof PaymentMappingScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    orderId: 'orderId',
    userId: 'userId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    status: 'status',
    reference: 'reference',
    qrCode: 'qrCode',
    qrCodeImage: 'qrCodeImage',
    notes: 'notes',
    servedBy: 'servedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    birthday: 'birthday',
    loyaltyPoints: 'loyaltyPoints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    memberCode: 'memberCode',
    discountType: 'discountType',
    discountValue: 'discountValue',
    isActive: 'isActive',
    loyaltyPoints: 'loyaltyPoints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    position: 'position',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const OutletScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    address: 'address',
    phone: 'phone',
    isActive: 'isActive',
    shiftConfig: 'shiftConfig',
    operatingHours: 'operatingHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutletScalarFieldEnum = (typeof OutletScalarFieldEnum)[keyof typeof OutletScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    period: 'period',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const TenantAddonScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    addonId: 'addonId',
    addonName: 'addonName',
    addonType: 'addonType',
    status: 'status',
    limit: 'limit',
    currentUsage: 'currentUsage',
    subscribedAt: 'subscribedAt',
    expiresAt: 'expiresAt',
    config: 'config',
    purchasedBy: 'purchasedBy'
  };

  export type TenantAddonScalarFieldEnum = (typeof TenantAddonScalarFieldEnum)[keyof typeof TenantAddonScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    plan: 'plan',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    amount: 'amount',
    temporaryUpgrade: 'temporaryUpgrade',
    previousPlan: 'previousPlan',
    purchasedBy: 'purchasedBy',
    createdAt: 'createdAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SubscriptionHistoryScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    tenantId: 'tenantId',
    planType: 'planType',
    startDate: 'startDate',
    endDate: 'endDate',
    price: 'price',
    durationDays: 'durationDays',
    isTemporary: 'isTemporary',
    reverted: 'reverted',
    createdAt: 'createdAt'
  };

  export type SubscriptionHistoryScalarFieldEnum = (typeof SubscriptionHistoryScalarFieldEnum)[keyof typeof SubscriptionHistoryScalarFieldEnum]


  export const ReceiptTemplateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    templateType: 'templateType',
    isDefault: 'isDefault',
    paperSize: 'paperSize',
    header: 'header',
    footer: 'footer',
    fields: 'fields',
    styles: 'styles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceiptTemplateScalarFieldEnum = (typeof ReceiptTemplateScalarFieldEnum)[keyof typeof ReceiptTemplateScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    discountType: 'discountType',
    discountValue: 'discountValue',
    discountValueType: 'discountValueType',
    minAmount: 'minAmount',
    minQuantity: 'minQuantity',
    applicableProducts: 'applicableProducts',
    bundleProducts: 'bundleProducts',
    bundleDiscountProduct: 'bundleDiscountProduct',
    applicableTo: 'applicableTo',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    userEmail: 'userEmail',
    userName: 'userName',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    status: 'status',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    url: 'url',
    events: 'events',
    secret: 'secret',
    isActive: 'isActive',
    retryCount: 'retryCount',
    timeout: 'timeout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    event: 'event',
    payload: 'payload',
    status: 'status',
    responseCode: 'responseCode',
    responseBody: 'responseBody',
    attempts: 'attempts',
    nextRetryAt: 'nextRetryAt',
    deliveredAt: 'deliveredAt',
    createdAt: 'createdAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    contactPerson: 'contactPerson',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    supplierId: 'supplierId',
    orderNumber: 'orderNumber',
    status: 'status',
    orderDate: 'orderDate',
    expectedDate: 'expectedDate',
    receivedDate: 'receivedDate',
    totalAmount: 'totalAmount',
    notes: 'notes',
    createdBy: 'createdBy',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    receivedQuantity: 'receivedQuantity',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const StockTransferScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    fromOutletId: 'fromOutletId',
    toOutletId: 'toOutletId',
    transferNumber: 'transferNumber',
    storeShiftId: 'storeShiftId',
    status: 'status',
    transferDate: 'transferDate',
    receivedDate: 'receivedDate',
    notes: 'notes',
    createdBy: 'createdBy',
    receivedBy: 'receivedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockTransferScalarFieldEnum = (typeof StockTransferScalarFieldEnum)[keyof typeof StockTransferScalarFieldEnum]


  export const StockTransferItemScalarFieldEnum: {
    id: 'id',
    stockTransferId: 'stockTransferId',
    productId: 'productId',
    quantity: 'quantity',
    receivedQuantity: 'receivedQuantity',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockTransferItemScalarFieldEnum = (typeof StockTransferItemScalarFieldEnum)[keyof typeof StockTransferItemScalarFieldEnum]


  export const StockValuationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    productId: 'productId',
    valuationType: 'valuationType',
    quantity: 'quantity',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    purchaseDate: 'purchaseDate',
    purchaseOrderId: 'purchaseOrderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockValuationScalarFieldEnum = (typeof StockValuationScalarFieldEnum)[keyof typeof StockValuationScalarFieldEnum]


  export const BackupLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    status: 'status',
    generatedAt: 'generatedAt',
    emailSentAt: 'emailSentAt',
    size: 'size',
    filePath: 'filePath',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BackupLogScalarFieldEnum = (typeof BackupLogScalarFieldEnum)[keyof typeof BackupLogScalarFieldEnum]


  export const StoreShiftScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    outletId: 'outletId',
    shiftType: 'shiftType',
    openedBy: 'openedBy',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    status: 'status',
    modalAwal: 'modalAwal',
    catatan: 'catatan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreShiftScalarFieldEnum = (typeof StoreShiftScalarFieldEnum)[keyof typeof StoreShiftScalarFieldEnum]


  export const CashShiftScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    storeShiftId: 'storeShiftId',
    kasirId: 'kasirId',
    shiftStart: 'shiftStart',
    shiftEnd: 'shiftEnd',
    modalAwal: 'modalAwal',
    uangFisikTutup: 'uangFisikTutup',
    saldoSeharusnya: 'saldoSeharusnya',
    selisih: 'selisih',
    status: 'status',
    catatan: 'catatan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashShiftScalarFieldEnum = (typeof CashShiftScalarFieldEnum)[keyof typeof CashShiftScalarFieldEnum]


  export const DeviceTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    platform: 'platform',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceTokenScalarFieldEnum = (typeof DeviceTokenScalarFieldEnum)[keyof typeof DeviceTokenScalarFieldEnum]


  export const CourierConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    courier: 'courier',
    apiKey: 'apiKey',
    apiSecret: 'apiSecret',
    baseUrl: 'baseUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourierConfigScalarFieldEnum = (typeof CourierConfigScalarFieldEnum)[keyof typeof CourierConfigScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    appName: 'appName',
    version: 'version',
    maintenanceMode: 'maintenanceMode',
    allowRegistration: 'allowRegistration',
    maxTenants: 'maxTenants',
    maxUsersPerTenant: 'maxUsersPerTenant',
    multiOutletEnabled: 'multiOutletEnabled',
    deliveryEnabled: 'deliveryEnabled',
    accountingEnabled: 'accountingEnabled',
    enable2FA: 'enable2FA',
    requireStrongPassword: 'requireStrongPassword',
    supportEmail: 'supportEmail',
    timezone: 'timezone',
    customSettings: 'customSettings',
    lastModifiedBy: 'lastModifiedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const ContactSubmissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    type: 'type',
    status: 'status',
    isRead: 'isRead',
    readAt: 'readAt',
    reply: 'reply',
    repliedAt: 'repliedAt',
    repliedBy: 'repliedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactSubmissionScalarFieldEnum = (typeof ContactSubmissionScalarFieldEnum)[keyof typeof ContactSubmissionScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    type: 'type',
    priority: 'priority',
    status: 'status',
    reply: 'reply',
    repliedAt: 'repliedAt',
    repliedBy: 'repliedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    email?: StringFilter<"Tenant"> | string
    phone?: StringNullableFilter<"Tenant"> | string | null
    address?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    subscriptionStart?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionPlan?: StringNullableFilter<"Tenant"> | string | null
    previousPlan?: StringNullableFilter<"Tenant"> | string | null
    temporaryUpgrade?: BoolFilter<"Tenant"> | boolean
    features?: JsonNullableFilter<"Tenant">
    tenantsActive?: IntFilter<"Tenant"> | number
    tenantsLimit?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    products?: ProductListRelationFilter
    orders?: OrderListRelationFilter
    transactions?: TransactionListRelationFilter
    customers?: CustomerListRelationFilter
    members?: MemberListRelationFilter
    employees?: EmployeeListRelationFilter
    outlets?: OutletListRelationFilter
    reports?: ReportListRelationFilter
    addons?: TenantAddonListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    subscriptionHistory?: SubscriptionHistoryListRelationFilter
    receiptTemplates?: ReceiptTemplateListRelationFilter
    discounts?: DiscountListRelationFilter
    paymentMappings?: PaymentMappingListRelationFilter
    productAdjustments?: ProductAdjustmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    webhooks?: WebhookListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    stockTransfers?: StockTransferListRelationFilter
    stockValuations?: StockValuationListRelationFilter
    backupLogs?: BackupLogListRelationFilter
    cashShifts?: CashShiftListRelationFilter
    storeShifts?: StoreShiftListRelationFilter
    courierConfigs?: CourierConfigListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    subscriptionPlan?: SortOrderInput | SortOrder
    previousPlan?: SortOrderInput | SortOrder
    temporaryUpgrade?: SortOrder
    features?: SortOrderInput | SortOrder
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    outlets?: OutletOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    addons?: TenantAddonOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    subscriptionHistory?: SubscriptionHistoryOrderByRelationAggregateInput
    receiptTemplates?: ReceiptTemplateOrderByRelationAggregateInput
    discounts?: DiscountOrderByRelationAggregateInput
    paymentMappings?: PaymentMappingOrderByRelationAggregateInput
    productAdjustments?: ProductAdjustmentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    stockTransfers?: StockTransferOrderByRelationAggregateInput
    stockValuations?: StockValuationOrderByRelationAggregateInput
    backupLogs?: BackupLogOrderByRelationAggregateInput
    cashShifts?: CashShiftOrderByRelationAggregateInput
    storeShifts?: StoreShiftOrderByRelationAggregateInput
    courierConfigs?: CourierConfigOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    email?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    phone?: StringNullableFilter<"Tenant"> | string | null
    address?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    subscriptionStart?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionPlan?: StringNullableFilter<"Tenant"> | string | null
    previousPlan?: StringNullableFilter<"Tenant"> | string | null
    temporaryUpgrade?: BoolFilter<"Tenant"> | boolean
    features?: JsonNullableFilter<"Tenant">
    tenantsActive?: IntFilter<"Tenant"> | number
    tenantsLimit?: IntFilter<"Tenant"> | number
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    products?: ProductListRelationFilter
    orders?: OrderListRelationFilter
    transactions?: TransactionListRelationFilter
    customers?: CustomerListRelationFilter
    members?: MemberListRelationFilter
    employees?: EmployeeListRelationFilter
    outlets?: OutletListRelationFilter
    reports?: ReportListRelationFilter
    addons?: TenantAddonListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    subscriptionHistory?: SubscriptionHistoryListRelationFilter
    receiptTemplates?: ReceiptTemplateListRelationFilter
    discounts?: DiscountListRelationFilter
    paymentMappings?: PaymentMappingListRelationFilter
    productAdjustments?: ProductAdjustmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    webhooks?: WebhookListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    stockTransfers?: StockTransferListRelationFilter
    stockValuations?: StockValuationListRelationFilter
    backupLogs?: BackupLogListRelationFilter
    cashShifts?: CashShiftListRelationFilter
    storeShifts?: StoreShiftListRelationFilter
    courierConfigs?: CourierConfigListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }, "id" | "slug" | "email">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    subscriptionPlan?: SortOrderInput | SortOrder
    previousPlan?: SortOrderInput | SortOrder
    temporaryUpgrade?: SortOrder
    features?: SortOrderInput | SortOrder
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    email?: StringWithAggregatesFilter<"Tenant"> | string
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    subscriptionStart?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    subscriptionPlan?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    previousPlan?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    temporaryUpgrade?: BoolWithAggregatesFilter<"Tenant"> | boolean
    features?: JsonNullableWithAggregatesFilter<"Tenant">
    tenantsActive?: IntWithAggregatesFilter<"Tenant"> | number
    tenantsLimit?: IntWithAggregatesFilter<"Tenant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    permissions?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    passwordHistory?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    transactions?: TransactionListRelationFilter
    cashShifts?: CashShiftListRelationFilter
    productAdjustments?: ProductAdjustmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    storeShifts?: StoreShiftListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    passwordHistory?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    cashShifts?: CashShiftOrderByRelationAggregateInput
    productAdjustments?: ProductAdjustmentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    storeShifts?: StoreShiftOrderByRelationAggregateInput
    deviceTokens?: DeviceTokenOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    permissions?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    passwordHistory?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    transactions?: TransactionListRelationFilter
    cashShifts?: CashShiftListRelationFilter
    productAdjustments?: ProductAdjustmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    storeShifts?: StoreShiftListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }, "id" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    passwordHistory?: SortOrderInput | SortOrder
    passwordChangedAt?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    permissions?: JsonNullableWithAggregatesFilter<"User">
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHistory?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    mustChangePassword?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    tenantId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    barcode?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
    emoji?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    isConsignment?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orderItems?: OrderItemListRelationFilter
    adjustments?: ProductAdjustmentListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    stockTransferItems?: StockTransferItemListRelationFilter
    stockValuations?: StockValuationListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    category?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isConsignment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    adjustments?: ProductAdjustmentOrderByRelationAggregateInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    stockTransferItems?: StockTransferItemOrderByRelationAggregateInput
    stockValuations?: StockValuationOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    tenantId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    barcode?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
    emoji?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    isConsignment?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orderItems?: OrderItemListRelationFilter
    adjustments?: ProductAdjustmentListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    stockTransferItems?: StockTransferItemListRelationFilter
    stockValuations?: StockValuationListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    category?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isConsignment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    tenantId?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntWithAggregatesFilter<"Product"> | number
    minStock?: IntWithAggregatesFilter<"Product"> | number
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    image?: StringNullableWithAggregatesFilter<"Product"> | string | null
    emoji?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    isConsignment?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductAdjustmentWhereInput = {
    AND?: ProductAdjustmentWhereInput | ProductAdjustmentWhereInput[]
    OR?: ProductAdjustmentWhereInput[]
    NOT?: ProductAdjustmentWhereInput | ProductAdjustmentWhereInput[]
    id?: StringFilter<"ProductAdjustment"> | string
    tenantId?: StringFilter<"ProductAdjustment"> | string
    productId?: StringFilter<"ProductAdjustment"> | string
    userId?: StringFilter<"ProductAdjustment"> | string
    storeShiftId?: StringNullableFilter<"ProductAdjustment"> | string | null
    type?: StringFilter<"ProductAdjustment"> | string
    quantity?: IntFilter<"ProductAdjustment"> | number
    reason?: StringFilter<"ProductAdjustment"> | string
    stockBefore?: IntFilter<"ProductAdjustment"> | number
    stockAfter?: IntFilter<"ProductAdjustment"> | number
    createdAt?: DateTimeFilter<"ProductAdjustment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
  }

  export type ProductAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    storeShift?: StoreShiftOrderByWithRelationInput
  }

  export type ProductAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductAdjustmentWhereInput | ProductAdjustmentWhereInput[]
    OR?: ProductAdjustmentWhereInput[]
    NOT?: ProductAdjustmentWhereInput | ProductAdjustmentWhereInput[]
    tenantId?: StringFilter<"ProductAdjustment"> | string
    productId?: StringFilter<"ProductAdjustment"> | string
    userId?: StringFilter<"ProductAdjustment"> | string
    storeShiftId?: StringNullableFilter<"ProductAdjustment"> | string | null
    type?: StringFilter<"ProductAdjustment"> | string
    quantity?: IntFilter<"ProductAdjustment"> | number
    reason?: StringFilter<"ProductAdjustment"> | string
    stockBefore?: IntFilter<"ProductAdjustment"> | number
    stockAfter?: IntFilter<"ProductAdjustment"> | number
    createdAt?: DateTimeFilter<"ProductAdjustment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
  }, "id">

  export type ProductAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
    createdAt?: SortOrder
    _count?: ProductAdjustmentCountOrderByAggregateInput
    _avg?: ProductAdjustmentAvgOrderByAggregateInput
    _max?: ProductAdjustmentMaxOrderByAggregateInput
    _min?: ProductAdjustmentMinOrderByAggregateInput
    _sum?: ProductAdjustmentSumOrderByAggregateInput
  }

  export type ProductAdjustmentScalarWhereWithAggregatesInput = {
    AND?: ProductAdjustmentScalarWhereWithAggregatesInput | ProductAdjustmentScalarWhereWithAggregatesInput[]
    OR?: ProductAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: ProductAdjustmentScalarWhereWithAggregatesInput | ProductAdjustmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductAdjustment"> | string
    tenantId?: StringWithAggregatesFilter<"ProductAdjustment"> | string
    productId?: StringWithAggregatesFilter<"ProductAdjustment"> | string
    userId?: StringWithAggregatesFilter<"ProductAdjustment"> | string
    storeShiftId?: StringNullableWithAggregatesFilter<"ProductAdjustment"> | string | null
    type?: StringWithAggregatesFilter<"ProductAdjustment"> | string
    quantity?: IntWithAggregatesFilter<"ProductAdjustment"> | number
    reason?: StringWithAggregatesFilter<"ProductAdjustment"> | string
    stockBefore?: IntWithAggregatesFilter<"ProductAdjustment"> | number
    stockAfter?: IntWithAggregatesFilter<"ProductAdjustment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductAdjustment"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    idempotencyKey?: StringNullableFilter<"Order"> | string | null
    tenantId?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    memberId?: StringNullableFilter<"Order"> | string | null
    outletId?: StringNullableFilter<"Order"> | string | null
    storeShiftId?: StringNullableFilter<"Order"> | string | null
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    sendToKitchen?: BoolFilter<"Order"> | boolean
    kitchenStatus?: StringNullableFilter<"Order"> | string | null
    temporaryCustomerName?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    outlet?: XOR<OutletNullableScalarRelationFilter, OutletWhereInput> | null
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
    items?: OrderItemListRelationFilter
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    memberId?: SortOrderInput | SortOrder
    outletId?: SortOrderInput | SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    status?: SortOrder
    sendToKitchen?: SortOrder
    kitchenStatus?: SortOrderInput | SortOrder
    temporaryCustomerName?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    member?: MemberOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    storeShift?: StoreShiftOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idempotencyKey?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    tenantId?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    memberId?: StringNullableFilter<"Order"> | string | null
    outletId?: StringNullableFilter<"Order"> | string | null
    storeShiftId?: StringNullableFilter<"Order"> | string | null
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    sendToKitchen?: BoolFilter<"Order"> | boolean
    kitchenStatus?: StringNullableFilter<"Order"> | string | null
    temporaryCustomerName?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    member?: XOR<MemberNullableScalarRelationFilter, MemberWhereInput> | null
    outlet?: XOR<OutletNullableScalarRelationFilter, OutletWhereInput> | null
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
    items?: OrderItemListRelationFilter
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id" | "idempotencyKey" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    memberId?: SortOrderInput | SortOrder
    outletId?: SortOrderInput | SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    status?: SortOrder
    sendToKitchen?: SortOrder
    kitchenStatus?: SortOrderInput | SortOrder
    temporaryCustomerName?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    idempotencyKey?: StringNullableWithAggregatesFilter<"Order"> | string | null
    tenantId?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    memberId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    outletId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    storeShiftId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    total?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    sendToKitchen?: BoolWithAggregatesFilter<"Order"> | boolean
    kitchenStatus?: StringNullableWithAggregatesFilter<"Order"> | string | null
    temporaryCustomerName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    profit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    profit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type PaymentMappingWhereInput = {
    AND?: PaymentMappingWhereInput | PaymentMappingWhereInput[]
    OR?: PaymentMappingWhereInput[]
    NOT?: PaymentMappingWhereInput | PaymentMappingWhereInput[]
    id?: StringFilter<"PaymentMapping"> | string
    orderId?: StringFilter<"PaymentMapping"> | string
    tenantId?: StringFilter<"PaymentMapping"> | string
    itemId?: StringFilter<"PaymentMapping"> | string
    itemType?: StringFilter<"PaymentMapping"> | string
    itemName?: StringNullableFilter<"PaymentMapping"> | string | null
    amount?: DecimalFilter<"PaymentMapping"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PaymentMapping"> | string
    createdAt?: DateTimeFilter<"PaymentMapping"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMapping"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PaymentMappingOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    itemName?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PaymentMappingWhereInput | PaymentMappingWhereInput[]
    OR?: PaymentMappingWhereInput[]
    NOT?: PaymentMappingWhereInput | PaymentMappingWhereInput[]
    tenantId?: StringFilter<"PaymentMapping"> | string
    itemId?: StringFilter<"PaymentMapping"> | string
    itemType?: StringFilter<"PaymentMapping"> | string
    itemName?: StringNullableFilter<"PaymentMapping"> | string | null
    amount?: DecimalFilter<"PaymentMapping"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PaymentMapping"> | string
    createdAt?: DateTimeFilter<"PaymentMapping"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMapping"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "orderId">

  export type PaymentMappingOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    itemName?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMappingCountOrderByAggregateInput
    _avg?: PaymentMappingAvgOrderByAggregateInput
    _max?: PaymentMappingMaxOrderByAggregateInput
    _min?: PaymentMappingMinOrderByAggregateInput
    _sum?: PaymentMappingSumOrderByAggregateInput
  }

  export type PaymentMappingScalarWhereWithAggregatesInput = {
    AND?: PaymentMappingScalarWhereWithAggregatesInput | PaymentMappingScalarWhereWithAggregatesInput[]
    OR?: PaymentMappingScalarWhereWithAggregatesInput[]
    NOT?: PaymentMappingScalarWhereWithAggregatesInput | PaymentMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMapping"> | string
    orderId?: StringWithAggregatesFilter<"PaymentMapping"> | string
    tenantId?: StringWithAggregatesFilter<"PaymentMapping"> | string
    itemId?: StringWithAggregatesFilter<"PaymentMapping"> | string
    itemType?: StringWithAggregatesFilter<"PaymentMapping"> | string
    itemName?: StringNullableWithAggregatesFilter<"PaymentMapping"> | string | null
    amount?: DecimalWithAggregatesFilter<"PaymentMapping"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"PaymentMapping"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMapping"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    orderId?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    reference?: StringNullableFilter<"Transaction"> | string | null
    qrCode?: StringNullableFilter<"Transaction"> | string | null
    qrCodeImage?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    servedBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    qrCodeImage?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    servedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    tenantId?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    reference?: StringNullableFilter<"Transaction"> | string | null
    qrCode?: StringNullableFilter<"Transaction"> | string | null
    qrCodeImage?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    servedBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    qrCodeImage?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    servedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    tenantId?: StringWithAggregatesFilter<"Transaction"> | string
    orderId?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    reference?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    qrCodeImage?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    servedBy?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    tenantId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    birthday?: DateTimeNullableFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    tenantId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    birthday?: DateTimeNullableFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    tenantId?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    tenantId?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    phone?: StringFilter<"Member"> | string
    address?: StringNullableFilter<"Member"> | string | null
    memberCode?: StringFilter<"Member"> | string
    discountType?: StringNullableFilter<"Member"> | string | null
    discountValue?: DecimalNullableFilter<"Member"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Member"> | boolean
    loyaltyPoints?: IntFilter<"Member"> | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    memberCode?: SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberCode?: string
    tenantId_phone?: MemberTenantIdPhoneCompoundUniqueInput
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    tenantId?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    phone?: StringFilter<"Member"> | string
    address?: StringNullableFilter<"Member"> | string | null
    discountType?: StringNullableFilter<"Member"> | string | null
    discountValue?: DecimalNullableFilter<"Member"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Member"> | boolean
    loyaltyPoints?: IntFilter<"Member"> | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
  }, "id" | "memberCode" | "tenantId_phone">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    memberCode?: SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    isActive?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    tenantId?: StringWithAggregatesFilter<"Member"> | string
    name?: StringWithAggregatesFilter<"Member"> | string
    email?: StringNullableWithAggregatesFilter<"Member"> | string | null
    phone?: StringWithAggregatesFilter<"Member"> | string
    address?: StringNullableWithAggregatesFilter<"Member"> | string | null
    memberCode?: StringWithAggregatesFilter<"Member"> | string
    discountType?: StringNullableWithAggregatesFilter<"Member"> | string | null
    discountValue?: DecimalNullableWithAggregatesFilter<"Member"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Member"> | boolean
    loyaltyPoints?: IntWithAggregatesFilter<"Member"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    tenantId?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    position?: StringFilter<"Employee"> | string
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: EmployeeTenantIdEmailCompoundUniqueInput
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    tenantId?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    position?: StringFilter<"Employee"> | string
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_email">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    tenantId?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringWithAggregatesFilter<"Employee"> | string
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringWithAggregatesFilter<"Employee"> | string
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type OutletWhereInput = {
    AND?: OutletWhereInput | OutletWhereInput[]
    OR?: OutletWhereInput[]
    NOT?: OutletWhereInput | OutletWhereInput[]
    id?: StringFilter<"Outlet"> | string
    tenantId?: StringFilter<"Outlet"> | string
    name?: StringFilter<"Outlet"> | string
    address?: StringNullableFilter<"Outlet"> | string | null
    phone?: StringNullableFilter<"Outlet"> | string | null
    isActive?: BoolFilter<"Outlet"> | boolean
    shiftConfig?: JsonNullableFilter<"Outlet">
    operatingHours?: JsonNullableFilter<"Outlet">
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    storeShifts?: StoreShiftListRelationFilter
  }

  export type OutletOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    shiftConfig?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    storeShifts?: StoreShiftOrderByRelationAggregateInput
  }

  export type OutletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutletWhereInput | OutletWhereInput[]
    OR?: OutletWhereInput[]
    NOT?: OutletWhereInput | OutletWhereInput[]
    tenantId?: StringFilter<"Outlet"> | string
    name?: StringFilter<"Outlet"> | string
    address?: StringNullableFilter<"Outlet"> | string | null
    phone?: StringNullableFilter<"Outlet"> | string | null
    isActive?: BoolFilter<"Outlet"> | boolean
    shiftConfig?: JsonNullableFilter<"Outlet">
    operatingHours?: JsonNullableFilter<"Outlet">
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    storeShifts?: StoreShiftListRelationFilter
  }, "id">

  export type OutletOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    shiftConfig?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutletCountOrderByAggregateInput
    _max?: OutletMaxOrderByAggregateInput
    _min?: OutletMinOrderByAggregateInput
  }

  export type OutletScalarWhereWithAggregatesInput = {
    AND?: OutletScalarWhereWithAggregatesInput | OutletScalarWhereWithAggregatesInput[]
    OR?: OutletScalarWhereWithAggregatesInput[]
    NOT?: OutletScalarWhereWithAggregatesInput | OutletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Outlet"> | string
    tenantId?: StringWithAggregatesFilter<"Outlet"> | string
    name?: StringWithAggregatesFilter<"Outlet"> | string
    address?: StringNullableWithAggregatesFilter<"Outlet"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Outlet"> | string | null
    isActive?: BoolWithAggregatesFilter<"Outlet"> | boolean
    shiftConfig?: JsonNullableWithAggregatesFilter<"Outlet">
    operatingHours?: JsonNullableWithAggregatesFilter<"Outlet">
    createdAt?: DateTimeWithAggregatesFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Outlet"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    tenantId?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    period?: StringFilter<"Report"> | string
    data?: JsonFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    tenantId?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    period?: StringFilter<"Report"> | string
    data?: JsonFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    tenantId?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    period?: StringWithAggregatesFilter<"Report"> | string
    data?: JsonWithAggregatesFilter<"Report">
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type TenantAddonWhereInput = {
    AND?: TenantAddonWhereInput | TenantAddonWhereInput[]
    OR?: TenantAddonWhereInput[]
    NOT?: TenantAddonWhereInput | TenantAddonWhereInput[]
    id?: StringFilter<"TenantAddon"> | string
    tenantId?: StringFilter<"TenantAddon"> | string
    addonId?: StringFilter<"TenantAddon"> | string
    addonName?: StringFilter<"TenantAddon"> | string
    addonType?: StringFilter<"TenantAddon"> | string
    status?: StringFilter<"TenantAddon"> | string
    limit?: IntNullableFilter<"TenantAddon"> | number | null
    currentUsage?: IntFilter<"TenantAddon"> | number
    subscribedAt?: DateTimeFilter<"TenantAddon"> | Date | string
    expiresAt?: DateTimeNullableFilter<"TenantAddon"> | Date | string | null
    config?: JsonNullableFilter<"TenantAddon">
    purchasedBy?: StringFilter<"TenantAddon"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantAddonOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    addonId?: SortOrder
    addonName?: SortOrder
    addonType?: SortOrder
    status?: SortOrder
    limit?: SortOrderInput | SortOrder
    currentUsage?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    purchasedBy?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantAddonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_addonId?: TenantAddonTenantIdAddonIdCompoundUniqueInput
    AND?: TenantAddonWhereInput | TenantAddonWhereInput[]
    OR?: TenantAddonWhereInput[]
    NOT?: TenantAddonWhereInput | TenantAddonWhereInput[]
    tenantId?: StringFilter<"TenantAddon"> | string
    addonId?: StringFilter<"TenantAddon"> | string
    addonName?: StringFilter<"TenantAddon"> | string
    addonType?: StringFilter<"TenantAddon"> | string
    status?: StringFilter<"TenantAddon"> | string
    limit?: IntNullableFilter<"TenantAddon"> | number | null
    currentUsage?: IntFilter<"TenantAddon"> | number
    subscribedAt?: DateTimeFilter<"TenantAddon"> | Date | string
    expiresAt?: DateTimeNullableFilter<"TenantAddon"> | Date | string | null
    config?: JsonNullableFilter<"TenantAddon">
    purchasedBy?: StringFilter<"TenantAddon"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_addonId">

  export type TenantAddonOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    addonId?: SortOrder
    addonName?: SortOrder
    addonType?: SortOrder
    status?: SortOrder
    limit?: SortOrderInput | SortOrder
    currentUsage?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    purchasedBy?: SortOrder
    _count?: TenantAddonCountOrderByAggregateInput
    _avg?: TenantAddonAvgOrderByAggregateInput
    _max?: TenantAddonMaxOrderByAggregateInput
    _min?: TenantAddonMinOrderByAggregateInput
    _sum?: TenantAddonSumOrderByAggregateInput
  }

  export type TenantAddonScalarWhereWithAggregatesInput = {
    AND?: TenantAddonScalarWhereWithAggregatesInput | TenantAddonScalarWhereWithAggregatesInput[]
    OR?: TenantAddonScalarWhereWithAggregatesInput[]
    NOT?: TenantAddonScalarWhereWithAggregatesInput | TenantAddonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantAddon"> | string
    tenantId?: StringWithAggregatesFilter<"TenantAddon"> | string
    addonId?: StringWithAggregatesFilter<"TenantAddon"> | string
    addonName?: StringWithAggregatesFilter<"TenantAddon"> | string
    addonType?: StringWithAggregatesFilter<"TenantAddon"> | string
    status?: StringWithAggregatesFilter<"TenantAddon"> | string
    limit?: IntNullableWithAggregatesFilter<"TenantAddon"> | number | null
    currentUsage?: IntWithAggregatesFilter<"TenantAddon"> | number
    subscribedAt?: DateTimeWithAggregatesFilter<"TenantAddon"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TenantAddon"> | Date | string | null
    config?: JsonNullableWithAggregatesFilter<"TenantAddon">
    purchasedBy?: StringWithAggregatesFilter<"TenantAddon"> | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    tenantId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    status?: StringFilter<"Subscription"> | string
    amount?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFilter<"Subscription"> | boolean
    previousPlan?: StringNullableFilter<"Subscription"> | string | null
    purchasedBy?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    history?: SubscriptionHistoryListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    temporaryUpgrade?: SortOrder
    previousPlan?: SortOrderInput | SortOrder
    purchasedBy?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    history?: SubscriptionHistoryOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tenantId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    status?: StringFilter<"Subscription"> | string
    amount?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFilter<"Subscription"> | boolean
    previousPlan?: StringNullableFilter<"Subscription"> | string | null
    purchasedBy?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    history?: SubscriptionHistoryListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    temporaryUpgrade?: SortOrder
    previousPlan?: SortOrderInput | SortOrder
    purchasedBy?: SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    tenantId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    status?: StringWithAggregatesFilter<"Subscription"> | string
    amount?: DecimalWithAggregatesFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolWithAggregatesFilter<"Subscription"> | boolean
    previousPlan?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    purchasedBy?: StringWithAggregatesFilter<"Subscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type SubscriptionHistoryWhereInput = {
    AND?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    OR?: SubscriptionHistoryWhereInput[]
    NOT?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    id?: StringFilter<"SubscriptionHistory"> | string
    subscriptionId?: StringNullableFilter<"SubscriptionHistory"> | string | null
    tenantId?: StringFilter<"SubscriptionHistory"> | string
    planType?: StringFilter<"SubscriptionHistory"> | string
    startDate?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    endDate?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    price?: DecimalFilter<"SubscriptionHistory"> | Decimal | DecimalJsLike | number | string
    durationDays?: IntFilter<"SubscriptionHistory"> | number
    isTemporary?: BoolFilter<"SubscriptionHistory"> | boolean
    reverted?: BoolFilter<"SubscriptionHistory"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }

  export type SubscriptionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    planType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    isTemporary?: SortOrder
    reverted?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type SubscriptionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    OR?: SubscriptionHistoryWhereInput[]
    NOT?: SubscriptionHistoryWhereInput | SubscriptionHistoryWhereInput[]
    subscriptionId?: StringNullableFilter<"SubscriptionHistory"> | string | null
    tenantId?: StringFilter<"SubscriptionHistory"> | string
    planType?: StringFilter<"SubscriptionHistory"> | string
    startDate?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    endDate?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    price?: DecimalFilter<"SubscriptionHistory"> | Decimal | DecimalJsLike | number | string
    durationDays?: IntFilter<"SubscriptionHistory"> | number
    isTemporary?: BoolFilter<"SubscriptionHistory"> | boolean
    reverted?: BoolFilter<"SubscriptionHistory"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
  }, "id">

  export type SubscriptionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    planType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    isTemporary?: SortOrder
    reverted?: SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionHistoryCountOrderByAggregateInput
    _avg?: SubscriptionHistoryAvgOrderByAggregateInput
    _max?: SubscriptionHistoryMaxOrderByAggregateInput
    _min?: SubscriptionHistoryMinOrderByAggregateInput
    _sum?: SubscriptionHistorySumOrderByAggregateInput
  }

  export type SubscriptionHistoryScalarWhereWithAggregatesInput = {
    AND?: SubscriptionHistoryScalarWhereWithAggregatesInput | SubscriptionHistoryScalarWhereWithAggregatesInput[]
    OR?: SubscriptionHistoryScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionHistoryScalarWhereWithAggregatesInput | SubscriptionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionHistory"> | string
    subscriptionId?: StringNullableWithAggregatesFilter<"SubscriptionHistory"> | string | null
    tenantId?: StringWithAggregatesFilter<"SubscriptionHistory"> | string
    planType?: StringWithAggregatesFilter<"SubscriptionHistory"> | string
    startDate?: DateTimeWithAggregatesFilter<"SubscriptionHistory"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"SubscriptionHistory"> | Date | string
    price?: DecimalWithAggregatesFilter<"SubscriptionHistory"> | Decimal | DecimalJsLike | number | string
    durationDays?: IntWithAggregatesFilter<"SubscriptionHistory"> | number
    isTemporary?: BoolWithAggregatesFilter<"SubscriptionHistory"> | boolean
    reverted?: BoolWithAggregatesFilter<"SubscriptionHistory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionHistory"> | Date | string
  }

  export type ReceiptTemplateWhereInput = {
    AND?: ReceiptTemplateWhereInput | ReceiptTemplateWhereInput[]
    OR?: ReceiptTemplateWhereInput[]
    NOT?: ReceiptTemplateWhereInput | ReceiptTemplateWhereInput[]
    id?: StringFilter<"ReceiptTemplate"> | string
    tenantId?: StringFilter<"ReceiptTemplate"> | string
    name?: StringFilter<"ReceiptTemplate"> | string
    templateType?: StringFilter<"ReceiptTemplate"> | string
    isDefault?: BoolFilter<"ReceiptTemplate"> | boolean
    paperSize?: StringFilter<"ReceiptTemplate"> | string
    header?: JsonNullableFilter<"ReceiptTemplate">
    footer?: JsonNullableFilter<"ReceiptTemplate">
    fields?: JsonNullableFilter<"ReceiptTemplate">
    styles?: JsonNullableFilter<"ReceiptTemplate">
    createdAt?: DateTimeFilter<"ReceiptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReceiptTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type ReceiptTemplateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    templateType?: SortOrder
    isDefault?: SortOrder
    paperSize?: SortOrder
    header?: SortOrderInput | SortOrder
    footer?: SortOrderInput | SortOrder
    fields?: SortOrderInput | SortOrder
    styles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type ReceiptTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceiptTemplateWhereInput | ReceiptTemplateWhereInput[]
    OR?: ReceiptTemplateWhereInput[]
    NOT?: ReceiptTemplateWhereInput | ReceiptTemplateWhereInput[]
    tenantId?: StringFilter<"ReceiptTemplate"> | string
    name?: StringFilter<"ReceiptTemplate"> | string
    templateType?: StringFilter<"ReceiptTemplate"> | string
    isDefault?: BoolFilter<"ReceiptTemplate"> | boolean
    paperSize?: StringFilter<"ReceiptTemplate"> | string
    header?: JsonNullableFilter<"ReceiptTemplate">
    footer?: JsonNullableFilter<"ReceiptTemplate">
    fields?: JsonNullableFilter<"ReceiptTemplate">
    styles?: JsonNullableFilter<"ReceiptTemplate">
    createdAt?: DateTimeFilter<"ReceiptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReceiptTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type ReceiptTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    templateType?: SortOrder
    isDefault?: SortOrder
    paperSize?: SortOrder
    header?: SortOrderInput | SortOrder
    footer?: SortOrderInput | SortOrder
    fields?: SortOrderInput | SortOrder
    styles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceiptTemplateCountOrderByAggregateInput
    _max?: ReceiptTemplateMaxOrderByAggregateInput
    _min?: ReceiptTemplateMinOrderByAggregateInput
  }

  export type ReceiptTemplateScalarWhereWithAggregatesInput = {
    AND?: ReceiptTemplateScalarWhereWithAggregatesInput | ReceiptTemplateScalarWhereWithAggregatesInput[]
    OR?: ReceiptTemplateScalarWhereWithAggregatesInput[]
    NOT?: ReceiptTemplateScalarWhereWithAggregatesInput | ReceiptTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReceiptTemplate"> | string
    tenantId?: StringWithAggregatesFilter<"ReceiptTemplate"> | string
    name?: StringWithAggregatesFilter<"ReceiptTemplate"> | string
    templateType?: StringWithAggregatesFilter<"ReceiptTemplate"> | string
    isDefault?: BoolWithAggregatesFilter<"ReceiptTemplate"> | boolean
    paperSize?: StringWithAggregatesFilter<"ReceiptTemplate"> | string
    header?: JsonNullableWithAggregatesFilter<"ReceiptTemplate">
    footer?: JsonNullableWithAggregatesFilter<"ReceiptTemplate">
    fields?: JsonNullableWithAggregatesFilter<"ReceiptTemplate">
    styles?: JsonNullableWithAggregatesFilter<"ReceiptTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"ReceiptTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReceiptTemplate"> | Date | string
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    tenantId?: StringFilter<"Discount"> | string
    name?: StringFilter<"Discount"> | string
    discountType?: StringFilter<"Discount"> | string
    discountValue?: DecimalFilter<"Discount"> | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFilter<"Discount"> | string
    minAmount?: DecimalNullableFilter<"Discount"> | Decimal | DecimalJsLike | number | string | null
    minQuantity?: IntNullableFilter<"Discount"> | number | null
    applicableProducts?: JsonNullableFilter<"Discount">
    bundleProducts?: JsonNullableFilter<"Discount">
    bundleDiscountProduct?: StringNullableFilter<"Discount"> | string | null
    applicableTo?: StringFilter<"Discount"> | string
    isActive?: BoolFilter<"Discount"> | boolean
    startDate?: DateTimeNullableFilter<"Discount"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Discount"> | Date | string | null
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    minQuantity?: SortOrderInput | SortOrder
    applicableProducts?: SortOrderInput | SortOrder
    bundleProducts?: SortOrderInput | SortOrder
    bundleDiscountProduct?: SortOrderInput | SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    tenantId?: StringFilter<"Discount"> | string
    name?: StringFilter<"Discount"> | string
    discountType?: StringFilter<"Discount"> | string
    discountValue?: DecimalFilter<"Discount"> | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFilter<"Discount"> | string
    minAmount?: DecimalNullableFilter<"Discount"> | Decimal | DecimalJsLike | number | string | null
    minQuantity?: IntNullableFilter<"Discount"> | number | null
    applicableProducts?: JsonNullableFilter<"Discount">
    bundleProducts?: JsonNullableFilter<"Discount">
    bundleDiscountProduct?: StringNullableFilter<"Discount"> | string | null
    applicableTo?: StringFilter<"Discount"> | string
    isActive?: BoolFilter<"Discount"> | boolean
    startDate?: DateTimeNullableFilter<"Discount"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Discount"> | Date | string | null
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    minQuantity?: SortOrderInput | SortOrder
    applicableProducts?: SortOrderInput | SortOrder
    bundleProducts?: SortOrderInput | SortOrder
    bundleDiscountProduct?: SortOrderInput | SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    tenantId?: StringWithAggregatesFilter<"Discount"> | string
    name?: StringWithAggregatesFilter<"Discount"> | string
    discountType?: StringWithAggregatesFilter<"Discount"> | string
    discountValue?: DecimalWithAggregatesFilter<"Discount"> | Decimal | DecimalJsLike | number | string
    discountValueType?: StringWithAggregatesFilter<"Discount"> | string
    minAmount?: DecimalNullableWithAggregatesFilter<"Discount"> | Decimal | DecimalJsLike | number | string | null
    minQuantity?: IntNullableWithAggregatesFilter<"Discount"> | number | null
    applicableProducts?: JsonNullableWithAggregatesFilter<"Discount">
    bundleProducts?: JsonNullableWithAggregatesFilter<"Discount">
    bundleDiscountProduct?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    applicableTo?: StringWithAggregatesFilter<"Discount"> | string
    isActive?: BoolWithAggregatesFilter<"Discount"> | boolean
    startDate?: DateTimeNullableWithAggregatesFilter<"Discount"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Discount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userEmail?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userEmail?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    status?: StringWithAggregatesFilter<"AuditLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    tenantId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    retryCount?: IntFilter<"Webhook"> | number
    timeout?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    tenantId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    retryCount?: IntFilter<"Webhook"> | number
    timeout?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    tenantId?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    retryCount?: IntWithAggregatesFilter<"Webhook"> | number
    timeout?: IntWithAggregatesFilter<"Webhook"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    status?: StringFilter<"WebhookDelivery"> | string
    responseCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    attempts?: IntFilter<"WebhookDelivery"> | number
    nextRetryAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    responseCode?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    attempts?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    webhookId?: StringFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    status?: StringFilter<"WebhookDelivery"> | string
    responseCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    attempts?: IntFilter<"WebhookDelivery"> | number
    nextRetryAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    responseCode?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    attempts?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    webhookId?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    event?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    status?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    responseCode?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    attempts?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    tenantId?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    tenantId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdBy?: StringFilter<"PurchaseOrder"> | string
    approvedBy?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    tenantId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdBy?: StringFilter<"PurchaseOrder"> | string
    approvedBy?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }, "id" | "orderNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    tenantId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    totalAmount?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdBy?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
  }

  export type StockTransferWhereInput = {
    AND?: StockTransferWhereInput | StockTransferWhereInput[]
    OR?: StockTransferWhereInput[]
    NOT?: StockTransferWhereInput | StockTransferWhereInput[]
    id?: StringFilter<"StockTransfer"> | string
    tenantId?: StringFilter<"StockTransfer"> | string
    fromOutletId?: StringFilter<"StockTransfer"> | string
    toOutletId?: StringFilter<"StockTransfer"> | string
    transferNumber?: StringFilter<"StockTransfer"> | string
    storeShiftId?: StringNullableFilter<"StockTransfer"> | string | null
    status?: StringFilter<"StockTransfer"> | string
    transferDate?: DateTimeFilter<"StockTransfer"> | Date | string
    receivedDate?: DateTimeNullableFilter<"StockTransfer"> | Date | string | null
    notes?: StringNullableFilter<"StockTransfer"> | string | null
    createdBy?: StringFilter<"StockTransfer"> | string
    receivedBy?: StringNullableFilter<"StockTransfer"> | string | null
    createdAt?: DateTimeFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransfer"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
    items?: StockTransferItemListRelationFilter
  }

  export type StockTransferOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fromOutletId?: SortOrder
    toOutletId?: SortOrder
    transferNumber?: SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    receivedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    storeShift?: StoreShiftOrderByWithRelationInput
    items?: StockTransferItemOrderByRelationAggregateInput
  }

  export type StockTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transferNumber?: string
    AND?: StockTransferWhereInput | StockTransferWhereInput[]
    OR?: StockTransferWhereInput[]
    NOT?: StockTransferWhereInput | StockTransferWhereInput[]
    tenantId?: StringFilter<"StockTransfer"> | string
    fromOutletId?: StringFilter<"StockTransfer"> | string
    toOutletId?: StringFilter<"StockTransfer"> | string
    storeShiftId?: StringNullableFilter<"StockTransfer"> | string | null
    status?: StringFilter<"StockTransfer"> | string
    transferDate?: DateTimeFilter<"StockTransfer"> | Date | string
    receivedDate?: DateTimeNullableFilter<"StockTransfer"> | Date | string | null
    notes?: StringNullableFilter<"StockTransfer"> | string | null
    createdBy?: StringFilter<"StockTransfer"> | string
    receivedBy?: StringNullableFilter<"StockTransfer"> | string | null
    createdAt?: DateTimeFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransfer"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
    items?: StockTransferItemListRelationFilter
  }, "id" | "transferNumber">

  export type StockTransferOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fromOutletId?: SortOrder
    toOutletId?: SortOrder
    transferNumber?: SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    receivedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockTransferCountOrderByAggregateInput
    _max?: StockTransferMaxOrderByAggregateInput
    _min?: StockTransferMinOrderByAggregateInput
  }

  export type StockTransferScalarWhereWithAggregatesInput = {
    AND?: StockTransferScalarWhereWithAggregatesInput | StockTransferScalarWhereWithAggregatesInput[]
    OR?: StockTransferScalarWhereWithAggregatesInput[]
    NOT?: StockTransferScalarWhereWithAggregatesInput | StockTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTransfer"> | string
    tenantId?: StringWithAggregatesFilter<"StockTransfer"> | string
    fromOutletId?: StringWithAggregatesFilter<"StockTransfer"> | string
    toOutletId?: StringWithAggregatesFilter<"StockTransfer"> | string
    transferNumber?: StringWithAggregatesFilter<"StockTransfer"> | string
    storeShiftId?: StringNullableWithAggregatesFilter<"StockTransfer"> | string | null
    status?: StringWithAggregatesFilter<"StockTransfer"> | string
    transferDate?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
    receivedDate?: DateTimeNullableWithAggregatesFilter<"StockTransfer"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"StockTransfer"> | string | null
    createdBy?: StringWithAggregatesFilter<"StockTransfer"> | string
    receivedBy?: StringNullableWithAggregatesFilter<"StockTransfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
  }

  export type StockTransferItemWhereInput = {
    AND?: StockTransferItemWhereInput | StockTransferItemWhereInput[]
    OR?: StockTransferItemWhereInput[]
    NOT?: StockTransferItemWhereInput | StockTransferItemWhereInput[]
    id?: StringFilter<"StockTransferItem"> | string
    stockTransferId?: StringFilter<"StockTransferItem"> | string
    productId?: StringFilter<"StockTransferItem"> | string
    quantity?: IntFilter<"StockTransferItem"> | number
    receivedQuantity?: IntFilter<"StockTransferItem"> | number
    notes?: StringNullableFilter<"StockTransferItem"> | string | null
    createdAt?: DateTimeFilter<"StockTransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransferItem"> | Date | string
    stockTransfer?: XOR<StockTransferScalarRelationFilter, StockTransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type StockTransferItemOrderByWithRelationInput = {
    id?: SortOrder
    stockTransferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockTransfer?: StockTransferOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type StockTransferItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockTransferItemWhereInput | StockTransferItemWhereInput[]
    OR?: StockTransferItemWhereInput[]
    NOT?: StockTransferItemWhereInput | StockTransferItemWhereInput[]
    stockTransferId?: StringFilter<"StockTransferItem"> | string
    productId?: StringFilter<"StockTransferItem"> | string
    quantity?: IntFilter<"StockTransferItem"> | number
    receivedQuantity?: IntFilter<"StockTransferItem"> | number
    notes?: StringNullableFilter<"StockTransferItem"> | string | null
    createdAt?: DateTimeFilter<"StockTransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransferItem"> | Date | string
    stockTransfer?: XOR<StockTransferScalarRelationFilter, StockTransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type StockTransferItemOrderByWithAggregationInput = {
    id?: SortOrder
    stockTransferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockTransferItemCountOrderByAggregateInput
    _avg?: StockTransferItemAvgOrderByAggregateInput
    _max?: StockTransferItemMaxOrderByAggregateInput
    _min?: StockTransferItemMinOrderByAggregateInput
    _sum?: StockTransferItemSumOrderByAggregateInput
  }

  export type StockTransferItemScalarWhereWithAggregatesInput = {
    AND?: StockTransferItemScalarWhereWithAggregatesInput | StockTransferItemScalarWhereWithAggregatesInput[]
    OR?: StockTransferItemScalarWhereWithAggregatesInput[]
    NOT?: StockTransferItemScalarWhereWithAggregatesInput | StockTransferItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTransferItem"> | string
    stockTransferId?: StringWithAggregatesFilter<"StockTransferItem"> | string
    productId?: StringWithAggregatesFilter<"StockTransferItem"> | string
    quantity?: IntWithAggregatesFilter<"StockTransferItem"> | number
    receivedQuantity?: IntWithAggregatesFilter<"StockTransferItem"> | number
    notes?: StringNullableWithAggregatesFilter<"StockTransferItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockTransferItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockTransferItem"> | Date | string
  }

  export type StockValuationWhereInput = {
    AND?: StockValuationWhereInput | StockValuationWhereInput[]
    OR?: StockValuationWhereInput[]
    NOT?: StockValuationWhereInput | StockValuationWhereInput[]
    id?: StringFilter<"StockValuation"> | string
    tenantId?: StringFilter<"StockValuation"> | string
    productId?: StringFilter<"StockValuation"> | string
    valuationType?: StringFilter<"StockValuation"> | string
    quantity?: IntFilter<"StockValuation"> | number
    unitCost?: DecimalFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFilter<"StockValuation"> | Date | string
    purchaseOrderId?: StringNullableFilter<"StockValuation"> | string | null
    createdAt?: DateTimeFilter<"StockValuation"> | Date | string
    updatedAt?: DateTimeFilter<"StockValuation"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type StockValuationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    valuationType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type StockValuationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockValuationWhereInput | StockValuationWhereInput[]
    OR?: StockValuationWhereInput[]
    NOT?: StockValuationWhereInput | StockValuationWhereInput[]
    tenantId?: StringFilter<"StockValuation"> | string
    productId?: StringFilter<"StockValuation"> | string
    valuationType?: StringFilter<"StockValuation"> | string
    quantity?: IntFilter<"StockValuation"> | number
    unitCost?: DecimalFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFilter<"StockValuation"> | Date | string
    purchaseOrderId?: StringNullableFilter<"StockValuation"> | string | null
    createdAt?: DateTimeFilter<"StockValuation"> | Date | string
    updatedAt?: DateTimeFilter<"StockValuation"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type StockValuationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    valuationType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockValuationCountOrderByAggregateInput
    _avg?: StockValuationAvgOrderByAggregateInput
    _max?: StockValuationMaxOrderByAggregateInput
    _min?: StockValuationMinOrderByAggregateInput
    _sum?: StockValuationSumOrderByAggregateInput
  }

  export type StockValuationScalarWhereWithAggregatesInput = {
    AND?: StockValuationScalarWhereWithAggregatesInput | StockValuationScalarWhereWithAggregatesInput[]
    OR?: StockValuationScalarWhereWithAggregatesInput[]
    NOT?: StockValuationScalarWhereWithAggregatesInput | StockValuationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockValuation"> | string
    tenantId?: StringWithAggregatesFilter<"StockValuation"> | string
    productId?: StringWithAggregatesFilter<"StockValuation"> | string
    valuationType?: StringWithAggregatesFilter<"StockValuation"> | string
    quantity?: IntWithAggregatesFilter<"StockValuation"> | number
    unitCost?: DecimalWithAggregatesFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalWithAggregatesFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeWithAggregatesFilter<"StockValuation"> | Date | string
    purchaseOrderId?: StringNullableWithAggregatesFilter<"StockValuation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockValuation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockValuation"> | Date | string
  }

  export type BackupLogWhereInput = {
    AND?: BackupLogWhereInput | BackupLogWhereInput[]
    OR?: BackupLogWhereInput[]
    NOT?: BackupLogWhereInput | BackupLogWhereInput[]
    id?: StringFilter<"BackupLog"> | string
    tenantId?: StringFilter<"BackupLog"> | string
    status?: StringFilter<"BackupLog"> | string
    generatedAt?: DateTimeFilter<"BackupLog"> | Date | string
    emailSentAt?: DateTimeNullableFilter<"BackupLog"> | Date | string | null
    size?: IntNullableFilter<"BackupLog"> | number | null
    filePath?: StringFilter<"BackupLog"> | string
    errorMessage?: StringNullableFilter<"BackupLog"> | string | null
    createdAt?: DateTimeFilter<"BackupLog"> | Date | string
    updatedAt?: DateTimeFilter<"BackupLog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type BackupLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    filePath?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type BackupLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackupLogWhereInput | BackupLogWhereInput[]
    OR?: BackupLogWhereInput[]
    NOT?: BackupLogWhereInput | BackupLogWhereInput[]
    tenantId?: StringFilter<"BackupLog"> | string
    status?: StringFilter<"BackupLog"> | string
    generatedAt?: DateTimeFilter<"BackupLog"> | Date | string
    emailSentAt?: DateTimeNullableFilter<"BackupLog"> | Date | string | null
    size?: IntNullableFilter<"BackupLog"> | number | null
    filePath?: StringFilter<"BackupLog"> | string
    errorMessage?: StringNullableFilter<"BackupLog"> | string | null
    createdAt?: DateTimeFilter<"BackupLog"> | Date | string
    updatedAt?: DateTimeFilter<"BackupLog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type BackupLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    filePath?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BackupLogCountOrderByAggregateInput
    _avg?: BackupLogAvgOrderByAggregateInput
    _max?: BackupLogMaxOrderByAggregateInput
    _min?: BackupLogMinOrderByAggregateInput
    _sum?: BackupLogSumOrderByAggregateInput
  }

  export type BackupLogScalarWhereWithAggregatesInput = {
    AND?: BackupLogScalarWhereWithAggregatesInput | BackupLogScalarWhereWithAggregatesInput[]
    OR?: BackupLogScalarWhereWithAggregatesInput[]
    NOT?: BackupLogScalarWhereWithAggregatesInput | BackupLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackupLog"> | string
    tenantId?: StringWithAggregatesFilter<"BackupLog"> | string
    status?: StringWithAggregatesFilter<"BackupLog"> | string
    generatedAt?: DateTimeWithAggregatesFilter<"BackupLog"> | Date | string
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"BackupLog"> | Date | string | null
    size?: IntNullableWithAggregatesFilter<"BackupLog"> | number | null
    filePath?: StringWithAggregatesFilter<"BackupLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"BackupLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BackupLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BackupLog"> | Date | string
  }

  export type StoreShiftWhereInput = {
    AND?: StoreShiftWhereInput | StoreShiftWhereInput[]
    OR?: StoreShiftWhereInput[]
    NOT?: StoreShiftWhereInput | StoreShiftWhereInput[]
    id?: StringFilter<"StoreShift"> | string
    tenantId?: StringFilter<"StoreShift"> | string
    outletId?: StringFilter<"StoreShift"> | string
    shiftType?: StringFilter<"StoreShift"> | string
    openedBy?: StringFilter<"StoreShift"> | string
    openedAt?: DateTimeFilter<"StoreShift"> | Date | string
    closedAt?: DateTimeNullableFilter<"StoreShift"> | Date | string | null
    status?: StringFilter<"StoreShift"> | string
    modalAwal?: DecimalNullableFilter<"StoreShift"> | Decimal | DecimalJsLike | number | string | null
    catatan?: StringNullableFilter<"StoreShift"> | string | null
    createdAt?: DateTimeFilter<"StoreShift"> | Date | string
    updatedAt?: DateTimeFilter<"StoreShift"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    opener?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    cashShifts?: CashShiftListRelationFilter
    productAdjustments?: ProductAdjustmentListRelationFilter
    stockTransfers?: StockTransferListRelationFilter
  }

  export type StoreShiftOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    outletId?: SortOrder
    shiftType?: SortOrder
    openedBy?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    modalAwal?: SortOrderInput | SortOrder
    catatan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    outlet?: OutletOrderByWithRelationInput
    opener?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    cashShifts?: CashShiftOrderByRelationAggregateInput
    productAdjustments?: ProductAdjustmentOrderByRelationAggregateInput
    stockTransfers?: StockTransferOrderByRelationAggregateInput
  }

  export type StoreShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreShiftWhereInput | StoreShiftWhereInput[]
    OR?: StoreShiftWhereInput[]
    NOT?: StoreShiftWhereInput | StoreShiftWhereInput[]
    tenantId?: StringFilter<"StoreShift"> | string
    outletId?: StringFilter<"StoreShift"> | string
    shiftType?: StringFilter<"StoreShift"> | string
    openedBy?: StringFilter<"StoreShift"> | string
    openedAt?: DateTimeFilter<"StoreShift"> | Date | string
    closedAt?: DateTimeNullableFilter<"StoreShift"> | Date | string | null
    status?: StringFilter<"StoreShift"> | string
    modalAwal?: DecimalNullableFilter<"StoreShift"> | Decimal | DecimalJsLike | number | string | null
    catatan?: StringNullableFilter<"StoreShift"> | string | null
    createdAt?: DateTimeFilter<"StoreShift"> | Date | string
    updatedAt?: DateTimeFilter<"StoreShift"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    outlet?: XOR<OutletScalarRelationFilter, OutletWhereInput>
    opener?: XOR<UserScalarRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    cashShifts?: CashShiftListRelationFilter
    productAdjustments?: ProductAdjustmentListRelationFilter
    stockTransfers?: StockTransferListRelationFilter
  }, "id">

  export type StoreShiftOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    outletId?: SortOrder
    shiftType?: SortOrder
    openedBy?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    modalAwal?: SortOrderInput | SortOrder
    catatan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreShiftCountOrderByAggregateInput
    _avg?: StoreShiftAvgOrderByAggregateInput
    _max?: StoreShiftMaxOrderByAggregateInput
    _min?: StoreShiftMinOrderByAggregateInput
    _sum?: StoreShiftSumOrderByAggregateInput
  }

  export type StoreShiftScalarWhereWithAggregatesInput = {
    AND?: StoreShiftScalarWhereWithAggregatesInput | StoreShiftScalarWhereWithAggregatesInput[]
    OR?: StoreShiftScalarWhereWithAggregatesInput[]
    NOT?: StoreShiftScalarWhereWithAggregatesInput | StoreShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreShift"> | string
    tenantId?: StringWithAggregatesFilter<"StoreShift"> | string
    outletId?: StringWithAggregatesFilter<"StoreShift"> | string
    shiftType?: StringWithAggregatesFilter<"StoreShift"> | string
    openedBy?: StringWithAggregatesFilter<"StoreShift"> | string
    openedAt?: DateTimeWithAggregatesFilter<"StoreShift"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"StoreShift"> | Date | string | null
    status?: StringWithAggregatesFilter<"StoreShift"> | string
    modalAwal?: DecimalNullableWithAggregatesFilter<"StoreShift"> | Decimal | DecimalJsLike | number | string | null
    catatan?: StringNullableWithAggregatesFilter<"StoreShift"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StoreShift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreShift"> | Date | string
  }

  export type CashShiftWhereInput = {
    AND?: CashShiftWhereInput | CashShiftWhereInput[]
    OR?: CashShiftWhereInput[]
    NOT?: CashShiftWhereInput | CashShiftWhereInput[]
    id?: StringFilter<"CashShift"> | string
    tenantId?: StringFilter<"CashShift"> | string
    storeShiftId?: StringNullableFilter<"CashShift"> | string | null
    kasirId?: StringFilter<"CashShift"> | string
    shiftStart?: DateTimeFilter<"CashShift"> | Date | string
    shiftEnd?: DateTimeNullableFilter<"CashShift"> | Date | string | null
    modalAwal?: DecimalFilter<"CashShift"> | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    selisih?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"CashShift"> | string
    catatan?: StringNullableFilter<"CashShift"> | string | null
    createdAt?: DateTimeFilter<"CashShift"> | Date | string
    updatedAt?: DateTimeFilter<"CashShift"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
    kasir?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CashShiftOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    kasirId?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrderInput | SortOrder
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrderInput | SortOrder
    saldoSeharusnya?: SortOrderInput | SortOrder
    selisih?: SortOrderInput | SortOrder
    status?: SortOrder
    catatan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    storeShift?: StoreShiftOrderByWithRelationInput
    kasir?: UserOrderByWithRelationInput
  }

  export type CashShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashShiftWhereInput | CashShiftWhereInput[]
    OR?: CashShiftWhereInput[]
    NOT?: CashShiftWhereInput | CashShiftWhereInput[]
    tenantId?: StringFilter<"CashShift"> | string
    storeShiftId?: StringNullableFilter<"CashShift"> | string | null
    kasirId?: StringFilter<"CashShift"> | string
    shiftStart?: DateTimeFilter<"CashShift"> | Date | string
    shiftEnd?: DateTimeNullableFilter<"CashShift"> | Date | string | null
    modalAwal?: DecimalFilter<"CashShift"> | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    selisih?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"CashShift"> | string
    catatan?: StringNullableFilter<"CashShift"> | string | null
    createdAt?: DateTimeFilter<"CashShift"> | Date | string
    updatedAt?: DateTimeFilter<"CashShift"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    storeShift?: XOR<StoreShiftNullableScalarRelationFilter, StoreShiftWhereInput> | null
    kasir?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CashShiftOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    storeShiftId?: SortOrderInput | SortOrder
    kasirId?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrderInput | SortOrder
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrderInput | SortOrder
    saldoSeharusnya?: SortOrderInput | SortOrder
    selisih?: SortOrderInput | SortOrder
    status?: SortOrder
    catatan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashShiftCountOrderByAggregateInput
    _avg?: CashShiftAvgOrderByAggregateInput
    _max?: CashShiftMaxOrderByAggregateInput
    _min?: CashShiftMinOrderByAggregateInput
    _sum?: CashShiftSumOrderByAggregateInput
  }

  export type CashShiftScalarWhereWithAggregatesInput = {
    AND?: CashShiftScalarWhereWithAggregatesInput | CashShiftScalarWhereWithAggregatesInput[]
    OR?: CashShiftScalarWhereWithAggregatesInput[]
    NOT?: CashShiftScalarWhereWithAggregatesInput | CashShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashShift"> | string
    tenantId?: StringWithAggregatesFilter<"CashShift"> | string
    storeShiftId?: StringNullableWithAggregatesFilter<"CashShift"> | string | null
    kasirId?: StringWithAggregatesFilter<"CashShift"> | string
    shiftStart?: DateTimeWithAggregatesFilter<"CashShift"> | Date | string
    shiftEnd?: DateTimeNullableWithAggregatesFilter<"CashShift"> | Date | string | null
    modalAwal?: DecimalWithAggregatesFilter<"CashShift"> | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: DecimalNullableWithAggregatesFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: DecimalNullableWithAggregatesFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    selisih?: DecimalNullableWithAggregatesFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"CashShift"> | string
    catatan?: StringNullableWithAggregatesFilter<"CashShift"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CashShift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashShift"> | Date | string
  }

  export type DeviceTokenWhereInput = {
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    isActive?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    userId?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    isActive?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type DeviceTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceTokenCountOrderByAggregateInput
    _max?: DeviceTokenMaxOrderByAggregateInput
    _min?: DeviceTokenMinOrderByAggregateInput
  }

  export type DeviceTokenScalarWhereWithAggregatesInput = {
    AND?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    OR?: DeviceTokenScalarWhereWithAggregatesInput[]
    NOT?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceToken"> | string
    userId?: StringWithAggregatesFilter<"DeviceToken"> | string
    token?: StringWithAggregatesFilter<"DeviceToken"> | string
    platform?: StringWithAggregatesFilter<"DeviceToken"> | string
    isActive?: BoolWithAggregatesFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
  }

  export type CourierConfigWhereInput = {
    AND?: CourierConfigWhereInput | CourierConfigWhereInput[]
    OR?: CourierConfigWhereInput[]
    NOT?: CourierConfigWhereInput | CourierConfigWhereInput[]
    id?: StringFilter<"CourierConfig"> | string
    tenantId?: StringFilter<"CourierConfig"> | string
    courier?: StringFilter<"CourierConfig"> | string
    apiKey?: StringFilter<"CourierConfig"> | string
    apiSecret?: StringFilter<"CourierConfig"> | string
    baseUrl?: StringNullableFilter<"CourierConfig"> | string | null
    isActive?: BoolFilter<"CourierConfig"> | boolean
    createdAt?: DateTimeFilter<"CourierConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CourierConfig"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CourierConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    courier?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    baseUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type CourierConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_courier?: CourierConfigTenantIdCourierCompoundUniqueInput
    AND?: CourierConfigWhereInput | CourierConfigWhereInput[]
    OR?: CourierConfigWhereInput[]
    NOT?: CourierConfigWhereInput | CourierConfigWhereInput[]
    tenantId?: StringFilter<"CourierConfig"> | string
    courier?: StringFilter<"CourierConfig"> | string
    apiKey?: StringFilter<"CourierConfig"> | string
    apiSecret?: StringFilter<"CourierConfig"> | string
    baseUrl?: StringNullableFilter<"CourierConfig"> | string | null
    isActive?: BoolFilter<"CourierConfig"> | boolean
    createdAt?: DateTimeFilter<"CourierConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CourierConfig"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_courier">

  export type CourierConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    courier?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    baseUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourierConfigCountOrderByAggregateInput
    _max?: CourierConfigMaxOrderByAggregateInput
    _min?: CourierConfigMinOrderByAggregateInput
  }

  export type CourierConfigScalarWhereWithAggregatesInput = {
    AND?: CourierConfigScalarWhereWithAggregatesInput | CourierConfigScalarWhereWithAggregatesInput[]
    OR?: CourierConfigScalarWhereWithAggregatesInput[]
    NOT?: CourierConfigScalarWhereWithAggregatesInput | CourierConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourierConfig"> | string
    tenantId?: StringWithAggregatesFilter<"CourierConfig"> | string
    courier?: StringWithAggregatesFilter<"CourierConfig"> | string
    apiKey?: StringWithAggregatesFilter<"CourierConfig"> | string
    apiSecret?: StringWithAggregatesFilter<"CourierConfig"> | string
    baseUrl?: StringNullableWithAggregatesFilter<"CourierConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"CourierConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CourierConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourierConfig"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    appName?: StringFilter<"SystemSettings"> | string
    version?: StringFilter<"SystemSettings"> | string
    maintenanceMode?: BoolFilter<"SystemSettings"> | boolean
    allowRegistration?: BoolFilter<"SystemSettings"> | boolean
    maxTenants?: IntFilter<"SystemSettings"> | number
    maxUsersPerTenant?: IntFilter<"SystemSettings"> | number
    multiOutletEnabled?: BoolFilter<"SystemSettings"> | boolean
    deliveryEnabled?: BoolFilter<"SystemSettings"> | boolean
    accountingEnabled?: BoolFilter<"SystemSettings"> | boolean
    enable2FA?: BoolFilter<"SystemSettings"> | boolean
    requireStrongPassword?: BoolFilter<"SystemSettings"> | boolean
    supportEmail?: StringNullableFilter<"SystemSettings"> | string | null
    timezone?: StringFilter<"SystemSettings"> | string
    customSettings?: JsonNullableFilter<"SystemSettings">
    lastModifiedBy?: StringNullableFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    appName?: SortOrder
    version?: SortOrder
    maintenanceMode?: SortOrder
    allowRegistration?: SortOrder
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
    multiOutletEnabled?: SortOrder
    deliveryEnabled?: SortOrder
    accountingEnabled?: SortOrder
    enable2FA?: SortOrder
    requireStrongPassword?: SortOrder
    supportEmail?: SortOrderInput | SortOrder
    timezone?: SortOrder
    customSettings?: SortOrderInput | SortOrder
    lastModifiedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    appName?: StringFilter<"SystemSettings"> | string
    version?: StringFilter<"SystemSettings"> | string
    maintenanceMode?: BoolFilter<"SystemSettings"> | boolean
    allowRegistration?: BoolFilter<"SystemSettings"> | boolean
    maxTenants?: IntFilter<"SystemSettings"> | number
    maxUsersPerTenant?: IntFilter<"SystemSettings"> | number
    multiOutletEnabled?: BoolFilter<"SystemSettings"> | boolean
    deliveryEnabled?: BoolFilter<"SystemSettings"> | boolean
    accountingEnabled?: BoolFilter<"SystemSettings"> | boolean
    enable2FA?: BoolFilter<"SystemSettings"> | boolean
    requireStrongPassword?: BoolFilter<"SystemSettings"> | boolean
    supportEmail?: StringNullableFilter<"SystemSettings"> | string | null
    timezone?: StringFilter<"SystemSettings"> | string
    customSettings?: JsonNullableFilter<"SystemSettings">
    lastModifiedBy?: StringNullableFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    appName?: SortOrder
    version?: SortOrder
    maintenanceMode?: SortOrder
    allowRegistration?: SortOrder
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
    multiOutletEnabled?: SortOrder
    deliveryEnabled?: SortOrder
    accountingEnabled?: SortOrder
    enable2FA?: SortOrder
    requireStrongPassword?: SortOrder
    supportEmail?: SortOrderInput | SortOrder
    timezone?: SortOrder
    customSettings?: SortOrderInput | SortOrder
    lastModifiedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _avg?: SystemSettingsAvgOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
    _sum?: SystemSettingsSumOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    appName?: StringWithAggregatesFilter<"SystemSettings"> | string
    version?: StringWithAggregatesFilter<"SystemSettings"> | string
    maintenanceMode?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    allowRegistration?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    maxTenants?: IntWithAggregatesFilter<"SystemSettings"> | number
    maxUsersPerTenant?: IntWithAggregatesFilter<"SystemSettings"> | number
    multiOutletEnabled?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    deliveryEnabled?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    accountingEnabled?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    enable2FA?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    requireStrongPassword?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    supportEmail?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    timezone?: StringWithAggregatesFilter<"SystemSettings"> | string
    customSettings?: JsonNullableWithAggregatesFilter<"SystemSettings">
    lastModifiedBy?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type ContactSubmissionWhereInput = {
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    id?: StringFilter<"ContactSubmission"> | string
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    phone?: StringNullableFilter<"ContactSubmission"> | string | null
    subject?: StringFilter<"ContactSubmission"> | string
    message?: StringFilter<"ContactSubmission"> | string
    type?: StringFilter<"ContactSubmission"> | string
    status?: StringFilter<"ContactSubmission"> | string
    isRead?: BoolFilter<"ContactSubmission"> | boolean
    readAt?: DateTimeNullableFilter<"ContactSubmission"> | Date | string | null
    reply?: StringNullableFilter<"ContactSubmission"> | string | null
    repliedAt?: DateTimeNullableFilter<"ContactSubmission"> | Date | string | null
    repliedBy?: StringNullableFilter<"ContactSubmission"> | string | null
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }

  export type ContactSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    reply?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    repliedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    phone?: StringNullableFilter<"ContactSubmission"> | string | null
    subject?: StringFilter<"ContactSubmission"> | string
    message?: StringFilter<"ContactSubmission"> | string
    type?: StringFilter<"ContactSubmission"> | string
    status?: StringFilter<"ContactSubmission"> | string
    isRead?: BoolFilter<"ContactSubmission"> | boolean
    readAt?: DateTimeNullableFilter<"ContactSubmission"> | Date | string | null
    reply?: StringNullableFilter<"ContactSubmission"> | string | null
    repliedAt?: DateTimeNullableFilter<"ContactSubmission"> | Date | string | null
    repliedBy?: StringNullableFilter<"ContactSubmission"> | string | null
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }, "id">

  export type ContactSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    reply?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    repliedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactSubmissionCountOrderByAggregateInput
    _max?: ContactSubmissionMaxOrderByAggregateInput
    _min?: ContactSubmissionMinOrderByAggregateInput
  }

  export type ContactSubmissionScalarWhereWithAggregatesInput = {
    AND?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    OR?: ContactSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactSubmission"> | string
    name?: StringWithAggregatesFilter<"ContactSubmission"> | string
    email?: StringWithAggregatesFilter<"ContactSubmission"> | string
    phone?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    subject?: StringWithAggregatesFilter<"ContactSubmission"> | string
    message?: StringWithAggregatesFilter<"ContactSubmission"> | string
    type?: StringWithAggregatesFilter<"ContactSubmission"> | string
    status?: StringWithAggregatesFilter<"ContactSubmission"> | string
    isRead?: BoolWithAggregatesFilter<"ContactSubmission"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"ContactSubmission"> | Date | string | null
    reply?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    repliedAt?: DateTimeNullableWithAggregatesFilter<"ContactSubmission"> | Date | string | null
    repliedBy?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    tenantId?: StringNullableFilter<"SupportTicket"> | string | null
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    name?: StringFilter<"SupportTicket"> | string
    email?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    type?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    reply?: StringNullableFilter<"SupportTicket"> | string | null
    repliedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    repliedBy?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reply?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    repliedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    tenantId?: StringNullableFilter<"SupportTicket"> | string | null
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    name?: StringFilter<"SupportTicket"> | string
    email?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    type?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    reply?: StringNullableFilter<"SupportTicket"> | string | null
    repliedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    repliedBy?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reply?: SortOrderInput | SortOrder
    repliedAt?: SortOrderInput | SortOrder
    repliedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    tenantId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    userId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    name?: StringWithAggregatesFilter<"SupportTicket"> | string
    email?: StringWithAggregatesFilter<"SupportTicket"> | string
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    message?: StringWithAggregatesFilter<"SupportTicket"> | string
    type?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    reply?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    repliedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    repliedBy?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemUncheckedCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUncheckedUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentCreateInput = {
    id?: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductAdjustmentsInput
    product: ProductCreateNestedOneWithoutAdjustmentsInput
    user: UserCreateNestedOneWithoutProductAdjustmentsInput
    storeShift?: StoreShiftCreateNestedOneWithoutProductAdjustmentsInput
  }

  export type ProductAdjustmentUncheckedCreateInput = {
    id?: string
    tenantId: string
    productId: string
    userId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type ProductAdjustmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    product?: ProductUpdateOneRequiredWithoutAdjustmentsNestedInput
    user?: UserUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    storeShift?: StoreShiftUpdateOneWithoutProductAdjustmentsNestedInput
  }

  export type ProductAdjustmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentCreateManyInput = {
    id?: string
    tenantId: string
    productId: string
    userId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type ProductAdjustmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMappingCreateInput = {
    id?: string
    orderId: string
    itemId: string
    itemType: string
    itemName?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentMappingsInput
  }

  export type PaymentMappingUncheckedCreateInput = {
    id?: string
    orderId: string
    tenantId: string
    itemId: string
    itemType: string
    itemName?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentMappingsNestedInput
  }

  export type PaymentMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMappingCreateManyInput = {
    id?: string
    orderId: string
    tenantId: string
    itemId: string
    itemType: string
    itemName?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    order: OrderCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    tenantId: string
    orderId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    order?: OrderUpdateOneRequiredWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    tenantId: string
    orderId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMembersInput
    orders?: OrderCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMembersNestedInput
    orders?: OrderUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    position: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    position: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email: string
    phone?: string | null
    position: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutletCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOutletsInput
    orders?: OrderCreateNestedManyWithoutOutletInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOutletInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOutletsNestedInput
    orders?: OrderUpdateManyWithoutOutletNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOutletNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type OutletCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    type: string
    period: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: string
    period: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    tenantId: string
    type: string
    period: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantAddonCreateInput = {
    id?: string
    addonId: string
    addonName: string
    addonType: string
    status?: string
    limit?: number | null
    currentUsage?: number
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: string
    tenant: TenantCreateNestedOneWithoutAddonsInput
  }

  export type TenantAddonUncheckedCreateInput = {
    id?: string
    tenantId: string
    addonId: string
    addonName: string
    addonType: string
    status?: string
    limit?: number | null
    currentUsage?: number
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: string
  }

  export type TenantAddonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutAddonsNestedInput
  }

  export type TenantAddonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TenantAddonCreateManyInput = {
    id?: string
    tenantId: string
    addonId: string
    addonName: string
    addonType: string
    status?: string
    limit?: number | null
    currentUsage?: number
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: string
  }

  export type TenantAddonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TenantAddonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSubscriptionsInput
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    tenantId: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionsNestedInput
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    tenantId: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryCreateInput = {
    id?: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSubscriptionHistoryInput
    subscription?: SubscriptionCreateNestedOneWithoutHistoryInput
  }

  export type SubscriptionHistoryUncheckedCreateInput = {
    id?: string
    subscriptionId?: string | null
    tenantId: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionHistoryNestedInput
    subscription?: SubscriptionUpdateOneWithoutHistoryNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryCreateManyInput = {
    id?: string
    subscriptionId?: string | null
    tenantId: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptTemplateCreateInput = {
    id?: string
    name: string
    templateType: string
    isDefault?: boolean
    paperSize?: string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReceiptTemplatesInput
  }

  export type ReceiptTemplateUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    templateType: string
    isDefault?: boolean
    paperSize?: string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReceiptTemplatesNestedInput
  }

  export type ReceiptTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptTemplateCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    templateType: string
    isDefault?: boolean
    paperSize?: string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateInput = {
    id?: string
    name: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    discountValueType: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    minQuantity?: number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: string | null
    applicableTo?: string
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    discountValueType: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    minQuantity?: number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: string | null
    applicableTo?: string
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    discountValueType: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    minQuantity?: number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: string | null
    applicableTo?: string
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    tenantId: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    tenantId: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    responseCode?: number | null
    responseBody?: string | null
    attempts?: number
    nextRetryAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    webhook: WebhookCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    webhookId: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    responseCode?: number | null
    responseBody?: string | null
    attempts?: number
    nextRetryAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook?: WebhookUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    webhookId: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    responseCode?: number | null
    responseBody?: string | null
    attempts?: number
    nextRetryAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    tenantId: string
    supplierId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    tenantId: string
    supplierId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferCreateInput = {
    id?: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockTransfersInput
    storeShift?: StoreShiftCreateNestedOneWithoutStockTransfersInput
    items?: StockTransferItemCreateNestedManyWithoutStockTransferInput
  }

  export type StockTransferUncheckedCreateInput = {
    id?: string
    tenantId: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    storeShiftId?: string | null
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockTransferItemUncheckedCreateNestedManyWithoutStockTransferInput
  }

  export type StockTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockTransfersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutStockTransfersNestedInput
    items?: StockTransferItemUpdateManyWithoutStockTransferNestedInput
  }

  export type StockTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockTransferItemUncheckedUpdateManyWithoutStockTransferNestedInput
  }

  export type StockTransferCreateManyInput = {
    id?: string
    tenantId: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    storeShiftId?: string | null
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemCreateInput = {
    id?: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockTransfer: StockTransferCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutStockTransferItemsInput
  }

  export type StockTransferItemUncheckedCreateInput = {
    id?: string
    stockTransferId: string
    productId: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTransfer?: StockTransferUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockTransferItemsNestedInput
  }

  export type StockTransferItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTransferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemCreateManyInput = {
    id?: string
    stockTransferId: string
    productId: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTransferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationCreateInput = {
    id?: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockValuationsInput
    product: ProductCreateNestedOneWithoutStockValuationsInput
  }

  export type StockValuationUncheckedCreateInput = {
    id?: string
    tenantId: string
    productId: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockValuationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockValuationsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockValuationsNestedInput
  }

  export type StockValuationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationCreateManyInput = {
    id?: string
    tenantId: string
    productId: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockValuationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogCreateInput = {
    id?: string
    status: string
    generatedAt?: Date | string
    emailSentAt?: Date | string | null
    size?: number | null
    filePath: string
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBackupLogsInput
  }

  export type BackupLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    status: string
    generatedAt?: Date | string
    emailSentAt?: Date | string | null
    size?: number | null
    filePath: string
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBackupLogsNestedInput
  }

  export type BackupLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogCreateManyInput = {
    id?: string
    tenantId: string
    status: string
    generatedAt?: Date | string
    emailSentAt?: Date | string | null
    size?: number | null
    filePath: string
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreShiftCreateInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftCreateManyInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftCreateInput = {
    id?: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashShiftsInput
    storeShift?: StoreShiftCreateNestedOneWithoutCashShiftsInput
    kasir: UserCreateNestedOneWithoutCashShiftsInput
  }

  export type CashShiftUncheckedCreateInput = {
    id?: string
    tenantId: string
    storeShiftId?: string | null
    kasirId: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashShiftsNestedInput
    storeShift?: StoreShiftUpdateOneWithoutCashShiftsNestedInput
    kasir?: UserUpdateOneRequiredWithoutCashShiftsNestedInput
  }

  export type CashShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    kasirId?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftCreateManyInput = {
    id?: string
    tenantId: string
    storeShiftId?: string | null
    kasirId: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    kasirId?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateInput = {
    id?: string
    token: string
    platform: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeviceTokensInput
  }

  export type DeviceTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    platform: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeviceTokensNestedInput
  }

  export type DeviceTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    platform: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierConfigCreateInput = {
    id?: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCourierConfigsInput
  }

  export type CourierConfigUncheckedCreateInput = {
    id?: string
    tenantId: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCourierConfigsNestedInput
  }

  export type CourierConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierConfigCreateManyInput = {
    id?: string
    tenantId: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    id?: string
    appName?: string
    version?: string
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: number
    maxUsersPerTenant?: number
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: string | null
    timezone?: string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    appName?: string
    version?: string
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: number
    maxUsersPerTenant?: number
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: string | null
    timezone?: string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    allowRegistration?: BoolFieldUpdateOperationsInput | boolean
    maxTenants?: IntFieldUpdateOperationsInput | number
    maxUsersPerTenant?: IntFieldUpdateOperationsInput | number
    multiOutletEnabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryEnabled?: BoolFieldUpdateOperationsInput | boolean
    accountingEnabled?: BoolFieldUpdateOperationsInput | boolean
    enable2FA?: BoolFieldUpdateOperationsInput | boolean
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    allowRegistration?: BoolFieldUpdateOperationsInput | boolean
    maxTenants?: IntFieldUpdateOperationsInput | number
    maxUsersPerTenant?: IntFieldUpdateOperationsInput | number
    multiOutletEnabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryEnabled?: BoolFieldUpdateOperationsInput | boolean
    accountingEnabled?: BoolFieldUpdateOperationsInput | boolean
    enable2FA?: BoolFieldUpdateOperationsInput | boolean
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    appName?: string
    version?: string
    maintenanceMode?: boolean
    allowRegistration?: boolean
    maxTenants?: number
    maxUsersPerTenant?: number
    multiOutletEnabled?: boolean
    deliveryEnabled?: boolean
    accountingEnabled?: boolean
    enable2FA?: boolean
    requireStrongPassword?: boolean
    supportEmail?: string | null
    timezone?: string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    allowRegistration?: BoolFieldUpdateOperationsInput | boolean
    maxTenants?: IntFieldUpdateOperationsInput | number
    maxUsersPerTenant?: IntFieldUpdateOperationsInput | number
    multiOutletEnabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryEnabled?: BoolFieldUpdateOperationsInput | boolean
    accountingEnabled?: BoolFieldUpdateOperationsInput | boolean
    enable2FA?: BoolFieldUpdateOperationsInput | boolean
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    allowRegistration?: BoolFieldUpdateOperationsInput | boolean
    maxTenants?: IntFieldUpdateOperationsInput | number
    maxUsersPerTenant?: IntFieldUpdateOperationsInput | number
    multiOutletEnabled?: BoolFieldUpdateOperationsInput | boolean
    deliveryEnabled?: BoolFieldUpdateOperationsInput | boolean
    accountingEnabled?: BoolFieldUpdateOperationsInput | boolean
    enable2FA?: BoolFieldUpdateOperationsInput | boolean
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    supportEmail?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    customSettings?: NullableJsonNullValueInput | InputJsonValue
    lastModifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    type?: string
    status?: string
    isRead?: boolean
    readAt?: Date | string | null
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    type?: string
    status?: string
    isRead?: boolean
    readAt?: Date | string | null
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    type?: string
    status?: string
    isRead?: boolean
    readAt?: Date | string | null
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutSupportTicketsInput
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutSupportTicketsNestedInput
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type OutletListRelationFilter = {
    every?: OutletWhereInput
    some?: OutletWhereInput
    none?: OutletWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type TenantAddonListRelationFilter = {
    every?: TenantAddonWhereInput
    some?: TenantAddonWhereInput
    none?: TenantAddonWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SubscriptionHistoryListRelationFilter = {
    every?: SubscriptionHistoryWhereInput
    some?: SubscriptionHistoryWhereInput
    none?: SubscriptionHistoryWhereInput
  }

  export type ReceiptTemplateListRelationFilter = {
    every?: ReceiptTemplateWhereInput
    some?: ReceiptTemplateWhereInput
    none?: ReceiptTemplateWhereInput
  }

  export type DiscountListRelationFilter = {
    every?: DiscountWhereInput
    some?: DiscountWhereInput
    none?: DiscountWhereInput
  }

  export type PaymentMappingListRelationFilter = {
    every?: PaymentMappingWhereInput
    some?: PaymentMappingWhereInput
    none?: PaymentMappingWhereInput
  }

  export type ProductAdjustmentListRelationFilter = {
    every?: ProductAdjustmentWhereInput
    some?: ProductAdjustmentWhereInput
    none?: ProductAdjustmentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type StockTransferListRelationFilter = {
    every?: StockTransferWhereInput
    some?: StockTransferWhereInput
    none?: StockTransferWhereInput
  }

  export type StockValuationListRelationFilter = {
    every?: StockValuationWhereInput
    some?: StockValuationWhereInput
    none?: StockValuationWhereInput
  }

  export type BackupLogListRelationFilter = {
    every?: BackupLogWhereInput
    some?: BackupLogWhereInput
    none?: BackupLogWhereInput
  }

  export type CashShiftListRelationFilter = {
    every?: CashShiftWhereInput
    some?: CashShiftWhereInput
    none?: CashShiftWhereInput
  }

  export type StoreShiftListRelationFilter = {
    every?: StoreShiftWhereInput
    some?: StoreShiftWhereInput
    none?: StoreShiftWhereInput
  }

  export type CourierConfigListRelationFilter = {
    every?: CourierConfigWhereInput
    some?: CourierConfigWhereInput
    none?: CourierConfigWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantAddonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceiptTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockValuationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BackupLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourierConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    subscriptionPlan?: SortOrder
    previousPlan?: SortOrder
    temporaryUpgrade?: SortOrder
    features?: SortOrder
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    subscriptionPlan?: SortOrder
    previousPlan?: SortOrder
    temporaryUpgrade?: SortOrder
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    subscriptionPlan?: SortOrder
    previousPlan?: SortOrder
    temporaryUpgrade?: SortOrder
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    tenantsActive?: SortOrder
    tenantsLimit?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type DeviceTokenListRelationFilter = {
    every?: DeviceTokenWhereInput
    some?: DeviceTokenWhereInput
    none?: DeviceTokenWhereInput
  }

  export type DeviceTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    lastLogin?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    passwordHistory?: SortOrder
    passwordChangedAt?: SortOrder
    mustChangePassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    passwordHistory?: SortOrder
    passwordChangedAt?: SortOrder
    mustChangePassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorBackupCodes?: SortOrder
    passwordHistory?: SortOrder
    passwordChangedAt?: SortOrder
    mustChangePassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type StockTransferItemListRelationFilter = {
    every?: StockTransferItemWhereInput
    some?: StockTransferItemWhereInput
    none?: StockTransferItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransferItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    category?: SortOrder
    image?: SortOrder
    emoji?: SortOrder
    isActive?: SortOrder
    isConsignment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    category?: SortOrder
    image?: SortOrder
    emoji?: SortOrder
    isActive?: SortOrder
    isConsignment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    category?: SortOrder
    image?: SortOrder
    emoji?: SortOrder
    isActive?: SortOrder
    isConsignment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StoreShiftNullableScalarRelationFilter = {
    is?: StoreShiftWhereInput | null
    isNot?: StoreShiftWhereInput | null
  }

  export type ProductAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    storeShiftId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAdjustmentAvgOrderByAggregateInput = {
    quantity?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
  }

  export type ProductAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    storeShiftId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    storeShiftId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAdjustmentSumOrderByAggregateInput = {
    quantity?: SortOrder
    stockBefore?: SortOrder
    stockAfter?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type MemberNullableScalarRelationFilter = {
    is?: MemberWhereInput | null
    isNot?: MemberWhereInput | null
  }

  export type OutletNullableScalarRelationFilter = {
    is?: OutletWhereInput | null
    isNot?: OutletWhereInput | null
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    idempotencyKey?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    memberId?: SortOrder
    outletId?: SortOrder
    storeShiftId?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    status?: SortOrder
    sendToKitchen?: SortOrder
    kitchenStatus?: SortOrder
    temporaryCustomerName?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    idempotencyKey?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    memberId?: SortOrder
    outletId?: SortOrder
    storeShiftId?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    status?: SortOrder
    sendToKitchen?: SortOrder
    kitchenStatus?: SortOrder
    temporaryCustomerName?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    idempotencyKey?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    memberId?: SortOrder
    outletId?: SortOrder
    storeShiftId?: SortOrder
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
    status?: SortOrder
    sendToKitchen?: SortOrder
    kitchenStatus?: SortOrder
    temporaryCustomerName?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    total?: SortOrder
    discount?: SortOrder
    subtotal?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    subtotal?: SortOrder
    profit?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    subtotal?: SortOrder
    profit?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    subtotal?: SortOrder
    profit?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    subtotal?: SortOrder
    profit?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    subtotal?: SortOrder
    profit?: SortOrder
  }

  export type PaymentMappingCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    itemName?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMappingAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    itemName?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMappingMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    itemName?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMappingSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    qrCode?: SortOrder
    qrCodeImage?: SortOrder
    notes?: SortOrder
    servedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    qrCode?: SortOrder
    qrCodeImage?: SortOrder
    notes?: SortOrder
    servedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    qrCode?: SortOrder
    qrCodeImage?: SortOrder
    notes?: SortOrder
    servedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birthday?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type MemberTenantIdPhoneCompoundUniqueInput = {
    tenantId: string
    phone: string
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    memberCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    isActive?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    loyaltyPoints?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    memberCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    isActive?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    memberCode?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    isActive?: SortOrder
    loyaltyPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    discountValue?: SortOrder
    loyaltyPoints?: SortOrder
  }

  export type EmployeeTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutletCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    shiftConfig?: SortOrder
    operatingHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutletMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutletMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    period?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TenantAddonTenantIdAddonIdCompoundUniqueInput = {
    tenantId: string
    addonId: string
  }

  export type TenantAddonCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    addonId?: SortOrder
    addonName?: SortOrder
    addonType?: SortOrder
    status?: SortOrder
    limit?: SortOrder
    currentUsage?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrder
    config?: SortOrder
    purchasedBy?: SortOrder
  }

  export type TenantAddonAvgOrderByAggregateInput = {
    limit?: SortOrder
    currentUsage?: SortOrder
  }

  export type TenantAddonMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    addonId?: SortOrder
    addonName?: SortOrder
    addonType?: SortOrder
    status?: SortOrder
    limit?: SortOrder
    currentUsage?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrder
    purchasedBy?: SortOrder
  }

  export type TenantAddonMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    addonId?: SortOrder
    addonName?: SortOrder
    addonType?: SortOrder
    status?: SortOrder
    limit?: SortOrder
    currentUsage?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrder
    purchasedBy?: SortOrder
  }

  export type TenantAddonSumOrderByAggregateInput = {
    limit?: SortOrder
    currentUsage?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    temporaryUpgrade?: SortOrder
    previousPlan?: SortOrder
    purchasedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    temporaryUpgrade?: SortOrder
    previousPlan?: SortOrder
    purchasedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    plan?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    temporaryUpgrade?: SortOrder
    previousPlan?: SortOrder
    purchasedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type SubscriptionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tenantId?: SortOrder
    planType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    isTemporary?: SortOrder
    reverted?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
    durationDays?: SortOrder
  }

  export type SubscriptionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tenantId?: SortOrder
    planType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    isTemporary?: SortOrder
    reverted?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    tenantId?: SortOrder
    planType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    isTemporary?: SortOrder
    reverted?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionHistorySumOrderByAggregateInput = {
    price?: SortOrder
    durationDays?: SortOrder
  }

  export type ReceiptTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    templateType?: SortOrder
    isDefault?: SortOrder
    paperSize?: SortOrder
    header?: SortOrder
    footer?: SortOrder
    fields?: SortOrder
    styles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    templateType?: SortOrder
    isDefault?: SortOrder
    paperSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    templateType?: SortOrder
    isDefault?: SortOrder
    paperSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    minAmount?: SortOrder
    minQuantity?: SortOrder
    applicableProducts?: SortOrder
    bundleProducts?: SortOrder
    bundleDiscountProduct?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    minAmount?: SortOrder
    minQuantity?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    minAmount?: SortOrder
    minQuantity?: SortOrder
    bundleDiscountProduct?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    minAmount?: SortOrder
    minQuantity?: SortOrder
    bundleDiscountProduct?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    discountValue?: SortOrder
    minAmount?: SortOrder
    minQuantity?: SortOrder
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    userName?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    retryCount?: SortOrder
    timeout?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    retryCount?: SortOrder
    timeout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    retryCount?: SortOrder
    timeout?: SortOrder
  }

  export type WebhookScalarRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    responseCode?: SortOrder
    responseBody?: SortOrder
    attempts?: SortOrder
    nextRetryAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    responseCode?: SortOrder
    attempts?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    status?: SortOrder
    responseCode?: SortOrder
    responseBody?: SortOrder
    attempts?: SortOrder
    nextRetryAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    status?: SortOrder
    responseCode?: SortOrder
    responseBody?: SortOrder
    attempts?: SortOrder
    nextRetryAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    responseCode?: SortOrder
    attempts?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type StockTransferCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fromOutletId?: SortOrder
    toOutletId?: SortOrder
    transferNumber?: SortOrder
    storeShiftId?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    receivedDate?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    receivedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fromOutletId?: SortOrder
    toOutletId?: SortOrder
    transferNumber?: SortOrder
    storeShiftId?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    receivedDate?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    receivedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fromOutletId?: SortOrder
    toOutletId?: SortOrder
    transferNumber?: SortOrder
    storeShiftId?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    receivedDate?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    receivedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferScalarRelationFilter = {
    is?: StockTransferWhereInput
    isNot?: StockTransferWhereInput
  }

  export type StockTransferItemCountOrderByAggregateInput = {
    id?: SortOrder
    stockTransferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type StockTransferItemMaxOrderByAggregateInput = {
    id?: SortOrder
    stockTransferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferItemMinOrderByAggregateInput = {
    id?: SortOrder
    stockTransferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type StockValuationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    valuationType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    purchaseOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockValuationAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type StockValuationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    valuationType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    purchaseOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockValuationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    valuationType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    purchaseDate?: SortOrder
    purchaseOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockValuationSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type BackupLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    emailSentAt?: SortOrder
    size?: SortOrder
    filePath?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackupLogAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BackupLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    emailSentAt?: SortOrder
    size?: SortOrder
    filePath?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackupLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    emailSentAt?: SortOrder
    size?: SortOrder
    filePath?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackupLogSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type OutletScalarRelationFilter = {
    is?: OutletWhereInput
    isNot?: OutletWhereInput
  }

  export type StoreShiftCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    outletId?: SortOrder
    shiftType?: SortOrder
    openedBy?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    modalAwal?: SortOrder
    catatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreShiftAvgOrderByAggregateInput = {
    modalAwal?: SortOrder
  }

  export type StoreShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    outletId?: SortOrder
    shiftType?: SortOrder
    openedBy?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    modalAwal?: SortOrder
    catatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreShiftMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    outletId?: SortOrder
    shiftType?: SortOrder
    openedBy?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    modalAwal?: SortOrder
    catatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreShiftSumOrderByAggregateInput = {
    modalAwal?: SortOrder
  }

  export type CashShiftCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    storeShiftId?: SortOrder
    kasirId?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrder
    saldoSeharusnya?: SortOrder
    selisih?: SortOrder
    status?: SortOrder
    catatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashShiftAvgOrderByAggregateInput = {
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrder
    saldoSeharusnya?: SortOrder
    selisih?: SortOrder
  }

  export type CashShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    storeShiftId?: SortOrder
    kasirId?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrder
    saldoSeharusnya?: SortOrder
    selisih?: SortOrder
    status?: SortOrder
    catatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashShiftMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    storeShiftId?: SortOrder
    kasirId?: SortOrder
    shiftStart?: SortOrder
    shiftEnd?: SortOrder
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrder
    saldoSeharusnya?: SortOrder
    selisih?: SortOrder
    status?: SortOrder
    catatan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashShiftSumOrderByAggregateInput = {
    modalAwal?: SortOrder
    uangFisikTutup?: SortOrder
    saldoSeharusnya?: SortOrder
    selisih?: SortOrder
  }

  export type DeviceTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourierConfigTenantIdCourierCompoundUniqueInput = {
    tenantId: string
    courier: string
  }

  export type CourierConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    courier?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    baseUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourierConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    courier?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    baseUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourierConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    courier?: SortOrder
    apiKey?: SortOrder
    apiSecret?: SortOrder
    baseUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    appName?: SortOrder
    version?: SortOrder
    maintenanceMode?: SortOrder
    allowRegistration?: SortOrder
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
    multiOutletEnabled?: SortOrder
    deliveryEnabled?: SortOrder
    accountingEnabled?: SortOrder
    enable2FA?: SortOrder
    requireStrongPassword?: SortOrder
    supportEmail?: SortOrder
    timezone?: SortOrder
    customSettings?: SortOrder
    lastModifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsAvgOrderByAggregateInput = {
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    appName?: SortOrder
    version?: SortOrder
    maintenanceMode?: SortOrder
    allowRegistration?: SortOrder
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
    multiOutletEnabled?: SortOrder
    deliveryEnabled?: SortOrder
    accountingEnabled?: SortOrder
    enable2FA?: SortOrder
    requireStrongPassword?: SortOrder
    supportEmail?: SortOrder
    timezone?: SortOrder
    lastModifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    appName?: SortOrder
    version?: SortOrder
    maintenanceMode?: SortOrder
    allowRegistration?: SortOrder
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
    multiOutletEnabled?: SortOrder
    deliveryEnabled?: SortOrder
    accountingEnabled?: SortOrder
    enable2FA?: SortOrder
    requireStrongPassword?: SortOrder
    supportEmail?: SortOrder
    timezone?: SortOrder
    lastModifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsSumOrderByAggregateInput = {
    maxTenants?: SortOrder
    maxUsersPerTenant?: SortOrder
  }

  export type ContactSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    reply?: SortOrder
    repliedAt?: SortOrder
    repliedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    reply?: SortOrder
    repliedAt?: SortOrder
    repliedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    reply?: SortOrder
    repliedAt?: SortOrder
    repliedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reply?: SortOrder
    repliedAt?: SortOrder
    repliedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reply?: SortOrder
    repliedAt?: SortOrder
    repliedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reply?: SortOrder
    repliedAt?: SortOrder
    repliedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutTenantInput = {
    create?: XOR<MemberCreateWithoutTenantInput, MemberUncheckedCreateWithoutTenantInput> | MemberCreateWithoutTenantInput[] | MemberUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutTenantInput | MemberCreateOrConnectWithoutTenantInput[]
    createMany?: MemberCreateManyTenantInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type OutletCreateNestedManyWithoutTenantInput = {
    create?: XOR<OutletCreateWithoutTenantInput, OutletUncheckedCreateWithoutTenantInput> | OutletCreateWithoutTenantInput[] | OutletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OutletCreateOrConnectWithoutTenantInput | OutletCreateOrConnectWithoutTenantInput[]
    createMany?: OutletCreateManyTenantInputEnvelope
    connect?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReportCreateWithoutTenantInput, ReportUncheckedCreateWithoutTenantInput> | ReportCreateWithoutTenantInput[] | ReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTenantInput | ReportCreateOrConnectWithoutTenantInput[]
    createMany?: ReportCreateManyTenantInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TenantAddonCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantAddonCreateWithoutTenantInput, TenantAddonUncheckedCreateWithoutTenantInput> | TenantAddonCreateWithoutTenantInput[] | TenantAddonUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantAddonCreateOrConnectWithoutTenantInput | TenantAddonCreateOrConnectWithoutTenantInput[]
    createMany?: TenantAddonCreateManyTenantInputEnvelope
    connect?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutTenantInput = {
    create?: XOR<SubscriptionCreateWithoutTenantInput, SubscriptionUncheckedCreateWithoutTenantInput> | SubscriptionCreateWithoutTenantInput[] | SubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTenantInput | SubscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: SubscriptionCreateManyTenantInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionHistoryCreateNestedManyWithoutTenantInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutTenantInput, SubscriptionHistoryUncheckedCreateWithoutTenantInput> | SubscriptionHistoryCreateWithoutTenantInput[] | SubscriptionHistoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutTenantInput | SubscriptionHistoryCreateOrConnectWithoutTenantInput[]
    createMany?: SubscriptionHistoryCreateManyTenantInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type ReceiptTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReceiptTemplateCreateWithoutTenantInput, ReceiptTemplateUncheckedCreateWithoutTenantInput> | ReceiptTemplateCreateWithoutTenantInput[] | ReceiptTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReceiptTemplateCreateOrConnectWithoutTenantInput | ReceiptTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ReceiptTemplateCreateManyTenantInputEnvelope
    connect?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
  }

  export type DiscountCreateNestedManyWithoutTenantInput = {
    create?: XOR<DiscountCreateWithoutTenantInput, DiscountUncheckedCreateWithoutTenantInput> | DiscountCreateWithoutTenantInput[] | DiscountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutTenantInput | DiscountCreateOrConnectWithoutTenantInput[]
    createMany?: DiscountCreateManyTenantInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type PaymentMappingCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentMappingCreateWithoutTenantInput, PaymentMappingUncheckedCreateWithoutTenantInput> | PaymentMappingCreateWithoutTenantInput[] | PaymentMappingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMappingCreateOrConnectWithoutTenantInput | PaymentMappingCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentMappingCreateManyTenantInputEnvelope
    connect?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
  }

  export type ProductAdjustmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductAdjustmentCreateWithoutTenantInput, ProductAdjustmentUncheckedCreateWithoutTenantInput> | ProductAdjustmentCreateWithoutTenantInput[] | ProductAdjustmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutTenantInput | ProductAdjustmentCreateOrConnectWithoutTenantInput[]
    createMany?: ProductAdjustmentCreateManyTenantInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutTenantInput = {
    create?: XOR<WebhookCreateWithoutTenantInput, WebhookUncheckedCreateWithoutTenantInput> | WebhookCreateWithoutTenantInput[] | WebhookUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTenantInput | WebhookCreateOrConnectWithoutTenantInput[]
    createMany?: WebhookCreateManyTenantInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type StockTransferCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockTransferCreateWithoutTenantInput, StockTransferUncheckedCreateWithoutTenantInput> | StockTransferCreateWithoutTenantInput[] | StockTransferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutTenantInput | StockTransferCreateOrConnectWithoutTenantInput[]
    createMany?: StockTransferCreateManyTenantInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type StockValuationCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockValuationCreateWithoutTenantInput, StockValuationUncheckedCreateWithoutTenantInput> | StockValuationCreateWithoutTenantInput[] | StockValuationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutTenantInput | StockValuationCreateOrConnectWithoutTenantInput[]
    createMany?: StockValuationCreateManyTenantInputEnvelope
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
  }

  export type BackupLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<BackupLogCreateWithoutTenantInput, BackupLogUncheckedCreateWithoutTenantInput> | BackupLogCreateWithoutTenantInput[] | BackupLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BackupLogCreateOrConnectWithoutTenantInput | BackupLogCreateOrConnectWithoutTenantInput[]
    createMany?: BackupLogCreateManyTenantInputEnvelope
    connect?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
  }

  export type CashShiftCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashShiftCreateWithoutTenantInput, CashShiftUncheckedCreateWithoutTenantInput> | CashShiftCreateWithoutTenantInput[] | CashShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutTenantInput | CashShiftCreateOrConnectWithoutTenantInput[]
    createMany?: CashShiftCreateManyTenantInputEnvelope
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
  }

  export type StoreShiftCreateNestedManyWithoutTenantInput = {
    create?: XOR<StoreShiftCreateWithoutTenantInput, StoreShiftUncheckedCreateWithoutTenantInput> | StoreShiftCreateWithoutTenantInput[] | StoreShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutTenantInput | StoreShiftCreateOrConnectWithoutTenantInput[]
    createMany?: StoreShiftCreateManyTenantInputEnvelope
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
  }

  export type CourierConfigCreateNestedManyWithoutTenantInput = {
    create?: XOR<CourierConfigCreateWithoutTenantInput, CourierConfigUncheckedCreateWithoutTenantInput> | CourierConfigCreateWithoutTenantInput[] | CourierConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CourierConfigCreateOrConnectWithoutTenantInput | CourierConfigCreateOrConnectWithoutTenantInput[]
    createMany?: CourierConfigCreateManyTenantInputEnvelope
    connect?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MemberCreateWithoutTenantInput, MemberUncheckedCreateWithoutTenantInput> | MemberCreateWithoutTenantInput[] | MemberUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutTenantInput | MemberCreateOrConnectWithoutTenantInput[]
    createMany?: MemberCreateManyTenantInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type OutletUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OutletCreateWithoutTenantInput, OutletUncheckedCreateWithoutTenantInput> | OutletCreateWithoutTenantInput[] | OutletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OutletCreateOrConnectWithoutTenantInput | OutletCreateOrConnectWithoutTenantInput[]
    createMany?: OutletCreateManyTenantInputEnvelope
    connect?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReportCreateWithoutTenantInput, ReportUncheckedCreateWithoutTenantInput> | ReportCreateWithoutTenantInput[] | ReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTenantInput | ReportCreateOrConnectWithoutTenantInput[]
    createMany?: ReportCreateManyTenantInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TenantAddonUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantAddonCreateWithoutTenantInput, TenantAddonUncheckedCreateWithoutTenantInput> | TenantAddonCreateWithoutTenantInput[] | TenantAddonUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantAddonCreateOrConnectWithoutTenantInput | TenantAddonCreateOrConnectWithoutTenantInput[]
    createMany?: TenantAddonCreateManyTenantInputEnvelope
    connect?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SubscriptionCreateWithoutTenantInput, SubscriptionUncheckedCreateWithoutTenantInput> | SubscriptionCreateWithoutTenantInput[] | SubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTenantInput | SubscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: SubscriptionCreateManyTenantInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutTenantInput, SubscriptionHistoryUncheckedCreateWithoutTenantInput> | SubscriptionHistoryCreateWithoutTenantInput[] | SubscriptionHistoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutTenantInput | SubscriptionHistoryCreateOrConnectWithoutTenantInput[]
    createMany?: SubscriptionHistoryCreateManyTenantInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReceiptTemplateCreateWithoutTenantInput, ReceiptTemplateUncheckedCreateWithoutTenantInput> | ReceiptTemplateCreateWithoutTenantInput[] | ReceiptTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReceiptTemplateCreateOrConnectWithoutTenantInput | ReceiptTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ReceiptTemplateCreateManyTenantInputEnvelope
    connect?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
  }

  export type DiscountUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DiscountCreateWithoutTenantInput, DiscountUncheckedCreateWithoutTenantInput> | DiscountCreateWithoutTenantInput[] | DiscountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutTenantInput | DiscountCreateOrConnectWithoutTenantInput[]
    createMany?: DiscountCreateManyTenantInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type PaymentMappingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentMappingCreateWithoutTenantInput, PaymentMappingUncheckedCreateWithoutTenantInput> | PaymentMappingCreateWithoutTenantInput[] | PaymentMappingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMappingCreateOrConnectWithoutTenantInput | PaymentMappingCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentMappingCreateManyTenantInputEnvelope
    connect?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
  }

  export type ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductAdjustmentCreateWithoutTenantInput, ProductAdjustmentUncheckedCreateWithoutTenantInput> | ProductAdjustmentCreateWithoutTenantInput[] | ProductAdjustmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutTenantInput | ProductAdjustmentCreateOrConnectWithoutTenantInput[]
    createMany?: ProductAdjustmentCreateManyTenantInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WebhookCreateWithoutTenantInput, WebhookUncheckedCreateWithoutTenantInput> | WebhookCreateWithoutTenantInput[] | WebhookUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTenantInput | WebhookCreateOrConnectWithoutTenantInput[]
    createMany?: WebhookCreateManyTenantInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type StockTransferUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockTransferCreateWithoutTenantInput, StockTransferUncheckedCreateWithoutTenantInput> | StockTransferCreateWithoutTenantInput[] | StockTransferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutTenantInput | StockTransferCreateOrConnectWithoutTenantInput[]
    createMany?: StockTransferCreateManyTenantInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type StockValuationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockValuationCreateWithoutTenantInput, StockValuationUncheckedCreateWithoutTenantInput> | StockValuationCreateWithoutTenantInput[] | StockValuationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutTenantInput | StockValuationCreateOrConnectWithoutTenantInput[]
    createMany?: StockValuationCreateManyTenantInputEnvelope
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
  }

  export type BackupLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BackupLogCreateWithoutTenantInput, BackupLogUncheckedCreateWithoutTenantInput> | BackupLogCreateWithoutTenantInput[] | BackupLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BackupLogCreateOrConnectWithoutTenantInput | BackupLogCreateOrConnectWithoutTenantInput[]
    createMany?: BackupLogCreateManyTenantInputEnvelope
    connect?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
  }

  export type CashShiftUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashShiftCreateWithoutTenantInput, CashShiftUncheckedCreateWithoutTenantInput> | CashShiftCreateWithoutTenantInput[] | CashShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutTenantInput | CashShiftCreateOrConnectWithoutTenantInput[]
    createMany?: CashShiftCreateManyTenantInputEnvelope
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
  }

  export type StoreShiftUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StoreShiftCreateWithoutTenantInput, StoreShiftUncheckedCreateWithoutTenantInput> | StoreShiftCreateWithoutTenantInput[] | StoreShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutTenantInput | StoreShiftCreateOrConnectWithoutTenantInput[]
    createMany?: StoreShiftCreateManyTenantInputEnvelope
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
  }

  export type CourierConfigUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CourierConfigCreateWithoutTenantInput, CourierConfigUncheckedCreateWithoutTenantInput> | CourierConfigCreateWithoutTenantInput[] | CourierConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CourierConfigCreateOrConnectWithoutTenantInput | CourierConfigCreateOrConnectWithoutTenantInput[]
    createMany?: CourierConfigCreateManyTenantInputEnvelope
    connect?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTenantInput | OrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTenantInput | OrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTenantInput | OrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MemberCreateWithoutTenantInput, MemberUncheckedCreateWithoutTenantInput> | MemberCreateWithoutTenantInput[] | MemberUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutTenantInput | MemberCreateOrConnectWithoutTenantInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutTenantInput | MemberUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MemberCreateManyTenantInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutTenantInput | MemberUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutTenantInput | MemberUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type OutletUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OutletCreateWithoutTenantInput, OutletUncheckedCreateWithoutTenantInput> | OutletCreateWithoutTenantInput[] | OutletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OutletCreateOrConnectWithoutTenantInput | OutletCreateOrConnectWithoutTenantInput[]
    upsert?: OutletUpsertWithWhereUniqueWithoutTenantInput | OutletUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OutletCreateManyTenantInputEnvelope
    set?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    disconnect?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    delete?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    connect?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    update?: OutletUpdateWithWhereUniqueWithoutTenantInput | OutletUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OutletUpdateManyWithWhereWithoutTenantInput | OutletUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OutletScalarWhereInput | OutletScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReportCreateWithoutTenantInput, ReportUncheckedCreateWithoutTenantInput> | ReportCreateWithoutTenantInput[] | ReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTenantInput | ReportCreateOrConnectWithoutTenantInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTenantInput | ReportUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReportCreateManyTenantInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTenantInput | ReportUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTenantInput | ReportUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TenantAddonUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantAddonCreateWithoutTenantInput, TenantAddonUncheckedCreateWithoutTenantInput> | TenantAddonCreateWithoutTenantInput[] | TenantAddonUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantAddonCreateOrConnectWithoutTenantInput | TenantAddonCreateOrConnectWithoutTenantInput[]
    upsert?: TenantAddonUpsertWithWhereUniqueWithoutTenantInput | TenantAddonUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantAddonCreateManyTenantInputEnvelope
    set?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    disconnect?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    delete?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    connect?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    update?: TenantAddonUpdateWithWhereUniqueWithoutTenantInput | TenantAddonUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantAddonUpdateManyWithWhereWithoutTenantInput | TenantAddonUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantAddonScalarWhereInput | TenantAddonScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SubscriptionCreateWithoutTenantInput, SubscriptionUncheckedCreateWithoutTenantInput> | SubscriptionCreateWithoutTenantInput[] | SubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTenantInput | SubscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutTenantInput | SubscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SubscriptionCreateManyTenantInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutTenantInput | SubscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutTenantInput | SubscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionHistoryUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutTenantInput, SubscriptionHistoryUncheckedCreateWithoutTenantInput> | SubscriptionHistoryCreateWithoutTenantInput[] | SubscriptionHistoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutTenantInput | SubscriptionHistoryCreateOrConnectWithoutTenantInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutTenantInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SubscriptionHistoryCreateManyTenantInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutTenantInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutTenantInput | SubscriptionHistoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type ReceiptTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReceiptTemplateCreateWithoutTenantInput, ReceiptTemplateUncheckedCreateWithoutTenantInput> | ReceiptTemplateCreateWithoutTenantInput[] | ReceiptTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReceiptTemplateCreateOrConnectWithoutTenantInput | ReceiptTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ReceiptTemplateUpsertWithWhereUniqueWithoutTenantInput | ReceiptTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReceiptTemplateCreateManyTenantInputEnvelope
    set?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    disconnect?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    delete?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    connect?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    update?: ReceiptTemplateUpdateWithWhereUniqueWithoutTenantInput | ReceiptTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReceiptTemplateUpdateManyWithWhereWithoutTenantInput | ReceiptTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReceiptTemplateScalarWhereInput | ReceiptTemplateScalarWhereInput[]
  }

  export type DiscountUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DiscountCreateWithoutTenantInput, DiscountUncheckedCreateWithoutTenantInput> | DiscountCreateWithoutTenantInput[] | DiscountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutTenantInput | DiscountCreateOrConnectWithoutTenantInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutTenantInput | DiscountUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DiscountCreateManyTenantInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutTenantInput | DiscountUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutTenantInput | DiscountUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type PaymentMappingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentMappingCreateWithoutTenantInput, PaymentMappingUncheckedCreateWithoutTenantInput> | PaymentMappingCreateWithoutTenantInput[] | PaymentMappingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMappingCreateOrConnectWithoutTenantInput | PaymentMappingCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentMappingUpsertWithWhereUniqueWithoutTenantInput | PaymentMappingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentMappingCreateManyTenantInputEnvelope
    set?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    disconnect?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    delete?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    connect?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    update?: PaymentMappingUpdateWithWhereUniqueWithoutTenantInput | PaymentMappingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentMappingUpdateManyWithWhereWithoutTenantInput | PaymentMappingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentMappingScalarWhereInput | PaymentMappingScalarWhereInput[]
  }

  export type ProductAdjustmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutTenantInput, ProductAdjustmentUncheckedCreateWithoutTenantInput> | ProductAdjustmentCreateWithoutTenantInput[] | ProductAdjustmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutTenantInput | ProductAdjustmentCreateOrConnectWithoutTenantInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutTenantInput | ProductAdjustmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductAdjustmentCreateManyTenantInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutTenantInput | ProductAdjustmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutTenantInput | ProductAdjustmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WebhookCreateWithoutTenantInput, WebhookUncheckedCreateWithoutTenantInput> | WebhookCreateWithoutTenantInput[] | WebhookUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTenantInput | WebhookCreateOrConnectWithoutTenantInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutTenantInput | WebhookUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WebhookCreateManyTenantInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutTenantInput | WebhookUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutTenantInput | WebhookUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput | PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput | PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutTenantInput | PurchaseOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type StockTransferUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockTransferCreateWithoutTenantInput, StockTransferUncheckedCreateWithoutTenantInput> | StockTransferCreateWithoutTenantInput[] | StockTransferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutTenantInput | StockTransferCreateOrConnectWithoutTenantInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutTenantInput | StockTransferUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockTransferCreateManyTenantInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutTenantInput | StockTransferUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutTenantInput | StockTransferUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type StockValuationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockValuationCreateWithoutTenantInput, StockValuationUncheckedCreateWithoutTenantInput> | StockValuationCreateWithoutTenantInput[] | StockValuationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutTenantInput | StockValuationCreateOrConnectWithoutTenantInput[]
    upsert?: StockValuationUpsertWithWhereUniqueWithoutTenantInput | StockValuationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockValuationCreateManyTenantInputEnvelope
    set?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    disconnect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    delete?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    update?: StockValuationUpdateWithWhereUniqueWithoutTenantInput | StockValuationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockValuationUpdateManyWithWhereWithoutTenantInput | StockValuationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockValuationScalarWhereInput | StockValuationScalarWhereInput[]
  }

  export type BackupLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BackupLogCreateWithoutTenantInput, BackupLogUncheckedCreateWithoutTenantInput> | BackupLogCreateWithoutTenantInput[] | BackupLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BackupLogCreateOrConnectWithoutTenantInput | BackupLogCreateOrConnectWithoutTenantInput[]
    upsert?: BackupLogUpsertWithWhereUniqueWithoutTenantInput | BackupLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BackupLogCreateManyTenantInputEnvelope
    set?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    disconnect?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    delete?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    connect?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    update?: BackupLogUpdateWithWhereUniqueWithoutTenantInput | BackupLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BackupLogUpdateManyWithWhereWithoutTenantInput | BackupLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BackupLogScalarWhereInput | BackupLogScalarWhereInput[]
  }

  export type CashShiftUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashShiftCreateWithoutTenantInput, CashShiftUncheckedCreateWithoutTenantInput> | CashShiftCreateWithoutTenantInput[] | CashShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutTenantInput | CashShiftCreateOrConnectWithoutTenantInput[]
    upsert?: CashShiftUpsertWithWhereUniqueWithoutTenantInput | CashShiftUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashShiftCreateManyTenantInputEnvelope
    set?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    disconnect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    delete?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    update?: CashShiftUpdateWithWhereUniqueWithoutTenantInput | CashShiftUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashShiftUpdateManyWithWhereWithoutTenantInput | CashShiftUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
  }

  export type StoreShiftUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StoreShiftCreateWithoutTenantInput, StoreShiftUncheckedCreateWithoutTenantInput> | StoreShiftCreateWithoutTenantInput[] | StoreShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutTenantInput | StoreShiftCreateOrConnectWithoutTenantInput[]
    upsert?: StoreShiftUpsertWithWhereUniqueWithoutTenantInput | StoreShiftUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StoreShiftCreateManyTenantInputEnvelope
    set?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    disconnect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    delete?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    update?: StoreShiftUpdateWithWhereUniqueWithoutTenantInput | StoreShiftUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StoreShiftUpdateManyWithWhereWithoutTenantInput | StoreShiftUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
  }

  export type CourierConfigUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CourierConfigCreateWithoutTenantInput, CourierConfigUncheckedCreateWithoutTenantInput> | CourierConfigCreateWithoutTenantInput[] | CourierConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CourierConfigCreateOrConnectWithoutTenantInput | CourierConfigCreateOrConnectWithoutTenantInput[]
    upsert?: CourierConfigUpsertWithWhereUniqueWithoutTenantInput | CourierConfigUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CourierConfigCreateManyTenantInputEnvelope
    set?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    disconnect?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    delete?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    connect?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    update?: CourierConfigUpdateWithWhereUniqueWithoutTenantInput | CourierConfigUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CourierConfigUpdateManyWithWhereWithoutTenantInput | CourierConfigUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CourierConfigScalarWhereInput | CourierConfigScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutTenantInput | SupportTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutTenantInput | SupportTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutTenantInput | SupportTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTenantInput | OrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTenantInput | OrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTenantInput | OrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MemberCreateWithoutTenantInput, MemberUncheckedCreateWithoutTenantInput> | MemberCreateWithoutTenantInput[] | MemberUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutTenantInput | MemberCreateOrConnectWithoutTenantInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutTenantInput | MemberUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MemberCreateManyTenantInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutTenantInput | MemberUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutTenantInput | MemberUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type OutletUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OutletCreateWithoutTenantInput, OutletUncheckedCreateWithoutTenantInput> | OutletCreateWithoutTenantInput[] | OutletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OutletCreateOrConnectWithoutTenantInput | OutletCreateOrConnectWithoutTenantInput[]
    upsert?: OutletUpsertWithWhereUniqueWithoutTenantInput | OutletUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OutletCreateManyTenantInputEnvelope
    set?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    disconnect?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    delete?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    connect?: OutletWhereUniqueInput | OutletWhereUniqueInput[]
    update?: OutletUpdateWithWhereUniqueWithoutTenantInput | OutletUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OutletUpdateManyWithWhereWithoutTenantInput | OutletUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OutletScalarWhereInput | OutletScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReportCreateWithoutTenantInput, ReportUncheckedCreateWithoutTenantInput> | ReportCreateWithoutTenantInput[] | ReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTenantInput | ReportCreateOrConnectWithoutTenantInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTenantInput | ReportUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReportCreateManyTenantInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTenantInput | ReportUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTenantInput | ReportUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TenantAddonUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantAddonCreateWithoutTenantInput, TenantAddonUncheckedCreateWithoutTenantInput> | TenantAddonCreateWithoutTenantInput[] | TenantAddonUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantAddonCreateOrConnectWithoutTenantInput | TenantAddonCreateOrConnectWithoutTenantInput[]
    upsert?: TenantAddonUpsertWithWhereUniqueWithoutTenantInput | TenantAddonUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantAddonCreateManyTenantInputEnvelope
    set?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    disconnect?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    delete?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    connect?: TenantAddonWhereUniqueInput | TenantAddonWhereUniqueInput[]
    update?: TenantAddonUpdateWithWhereUniqueWithoutTenantInput | TenantAddonUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantAddonUpdateManyWithWhereWithoutTenantInput | TenantAddonUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantAddonScalarWhereInput | TenantAddonScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SubscriptionCreateWithoutTenantInput, SubscriptionUncheckedCreateWithoutTenantInput> | SubscriptionCreateWithoutTenantInput[] | SubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTenantInput | SubscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutTenantInput | SubscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SubscriptionCreateManyTenantInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutTenantInput | SubscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutTenantInput | SubscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutTenantInput, SubscriptionHistoryUncheckedCreateWithoutTenantInput> | SubscriptionHistoryCreateWithoutTenantInput[] | SubscriptionHistoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutTenantInput | SubscriptionHistoryCreateOrConnectWithoutTenantInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutTenantInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SubscriptionHistoryCreateManyTenantInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutTenantInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutTenantInput | SubscriptionHistoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReceiptTemplateCreateWithoutTenantInput, ReceiptTemplateUncheckedCreateWithoutTenantInput> | ReceiptTemplateCreateWithoutTenantInput[] | ReceiptTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReceiptTemplateCreateOrConnectWithoutTenantInput | ReceiptTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ReceiptTemplateUpsertWithWhereUniqueWithoutTenantInput | ReceiptTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReceiptTemplateCreateManyTenantInputEnvelope
    set?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    disconnect?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    delete?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    connect?: ReceiptTemplateWhereUniqueInput | ReceiptTemplateWhereUniqueInput[]
    update?: ReceiptTemplateUpdateWithWhereUniqueWithoutTenantInput | ReceiptTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReceiptTemplateUpdateManyWithWhereWithoutTenantInput | ReceiptTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReceiptTemplateScalarWhereInput | ReceiptTemplateScalarWhereInput[]
  }

  export type DiscountUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DiscountCreateWithoutTenantInput, DiscountUncheckedCreateWithoutTenantInput> | DiscountCreateWithoutTenantInput[] | DiscountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutTenantInput | DiscountCreateOrConnectWithoutTenantInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutTenantInput | DiscountUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DiscountCreateManyTenantInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutTenantInput | DiscountUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutTenantInput | DiscountUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentMappingCreateWithoutTenantInput, PaymentMappingUncheckedCreateWithoutTenantInput> | PaymentMappingCreateWithoutTenantInput[] | PaymentMappingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentMappingCreateOrConnectWithoutTenantInput | PaymentMappingCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentMappingUpsertWithWhereUniqueWithoutTenantInput | PaymentMappingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentMappingCreateManyTenantInputEnvelope
    set?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    disconnect?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    delete?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    connect?: PaymentMappingWhereUniqueInput | PaymentMappingWhereUniqueInput[]
    update?: PaymentMappingUpdateWithWhereUniqueWithoutTenantInput | PaymentMappingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentMappingUpdateManyWithWhereWithoutTenantInput | PaymentMappingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentMappingScalarWhereInput | PaymentMappingScalarWhereInput[]
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutTenantInput, ProductAdjustmentUncheckedCreateWithoutTenantInput> | ProductAdjustmentCreateWithoutTenantInput[] | ProductAdjustmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutTenantInput | ProductAdjustmentCreateOrConnectWithoutTenantInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutTenantInput | ProductAdjustmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductAdjustmentCreateManyTenantInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutTenantInput | ProductAdjustmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutTenantInput | ProductAdjustmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WebhookCreateWithoutTenantInput, WebhookUncheckedCreateWithoutTenantInput> | WebhookCreateWithoutTenantInput[] | WebhookUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutTenantInput | WebhookCreateOrConnectWithoutTenantInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutTenantInput | WebhookUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WebhookCreateManyTenantInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutTenantInput | WebhookUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutTenantInput | WebhookUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput | PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput | PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutTenantInput | PurchaseOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type StockTransferUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockTransferCreateWithoutTenantInput, StockTransferUncheckedCreateWithoutTenantInput> | StockTransferCreateWithoutTenantInput[] | StockTransferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutTenantInput | StockTransferCreateOrConnectWithoutTenantInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutTenantInput | StockTransferUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockTransferCreateManyTenantInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutTenantInput | StockTransferUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutTenantInput | StockTransferUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type StockValuationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockValuationCreateWithoutTenantInput, StockValuationUncheckedCreateWithoutTenantInput> | StockValuationCreateWithoutTenantInput[] | StockValuationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutTenantInput | StockValuationCreateOrConnectWithoutTenantInput[]
    upsert?: StockValuationUpsertWithWhereUniqueWithoutTenantInput | StockValuationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockValuationCreateManyTenantInputEnvelope
    set?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    disconnect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    delete?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    update?: StockValuationUpdateWithWhereUniqueWithoutTenantInput | StockValuationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockValuationUpdateManyWithWhereWithoutTenantInput | StockValuationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockValuationScalarWhereInput | StockValuationScalarWhereInput[]
  }

  export type BackupLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BackupLogCreateWithoutTenantInput, BackupLogUncheckedCreateWithoutTenantInput> | BackupLogCreateWithoutTenantInput[] | BackupLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BackupLogCreateOrConnectWithoutTenantInput | BackupLogCreateOrConnectWithoutTenantInput[]
    upsert?: BackupLogUpsertWithWhereUniqueWithoutTenantInput | BackupLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BackupLogCreateManyTenantInputEnvelope
    set?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    disconnect?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    delete?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    connect?: BackupLogWhereUniqueInput | BackupLogWhereUniqueInput[]
    update?: BackupLogUpdateWithWhereUniqueWithoutTenantInput | BackupLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BackupLogUpdateManyWithWhereWithoutTenantInput | BackupLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BackupLogScalarWhereInput | BackupLogScalarWhereInput[]
  }

  export type CashShiftUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashShiftCreateWithoutTenantInput, CashShiftUncheckedCreateWithoutTenantInput> | CashShiftCreateWithoutTenantInput[] | CashShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutTenantInput | CashShiftCreateOrConnectWithoutTenantInput[]
    upsert?: CashShiftUpsertWithWhereUniqueWithoutTenantInput | CashShiftUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashShiftCreateManyTenantInputEnvelope
    set?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    disconnect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    delete?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    update?: CashShiftUpdateWithWhereUniqueWithoutTenantInput | CashShiftUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashShiftUpdateManyWithWhereWithoutTenantInput | CashShiftUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
  }

  export type StoreShiftUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StoreShiftCreateWithoutTenantInput, StoreShiftUncheckedCreateWithoutTenantInput> | StoreShiftCreateWithoutTenantInput[] | StoreShiftUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutTenantInput | StoreShiftCreateOrConnectWithoutTenantInput[]
    upsert?: StoreShiftUpsertWithWhereUniqueWithoutTenantInput | StoreShiftUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StoreShiftCreateManyTenantInputEnvelope
    set?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    disconnect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    delete?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    update?: StoreShiftUpdateWithWhereUniqueWithoutTenantInput | StoreShiftUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StoreShiftUpdateManyWithWhereWithoutTenantInput | StoreShiftUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
  }

  export type CourierConfigUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CourierConfigCreateWithoutTenantInput, CourierConfigUncheckedCreateWithoutTenantInput> | CourierConfigCreateWithoutTenantInput[] | CourierConfigUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CourierConfigCreateOrConnectWithoutTenantInput | CourierConfigCreateOrConnectWithoutTenantInput[]
    upsert?: CourierConfigUpsertWithWhereUniqueWithoutTenantInput | CourierConfigUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CourierConfigCreateManyTenantInputEnvelope
    set?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    disconnect?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    delete?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    connect?: CourierConfigWhereUniqueInput | CourierConfigWhereUniqueInput[]
    update?: CourierConfigUpdateWithWhereUniqueWithoutTenantInput | CourierConfigUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CourierConfigUpdateManyWithWhereWithoutTenantInput | CourierConfigUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CourierConfigScalarWhereInput | CourierConfigScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutTenantInput | SupportTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutTenantInput | SupportTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutTenantInput | SupportTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CashShiftCreateNestedManyWithoutKasirInput = {
    create?: XOR<CashShiftCreateWithoutKasirInput, CashShiftUncheckedCreateWithoutKasirInput> | CashShiftCreateWithoutKasirInput[] | CashShiftUncheckedCreateWithoutKasirInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutKasirInput | CashShiftCreateOrConnectWithoutKasirInput[]
    createMany?: CashShiftCreateManyKasirInputEnvelope
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
  }

  export type ProductAdjustmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductAdjustmentCreateWithoutUserInput, ProductAdjustmentUncheckedCreateWithoutUserInput> | ProductAdjustmentCreateWithoutUserInput[] | ProductAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutUserInput | ProductAdjustmentCreateOrConnectWithoutUserInput[]
    createMany?: ProductAdjustmentCreateManyUserInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StoreShiftCreateNestedManyWithoutOpenerInput = {
    create?: XOR<StoreShiftCreateWithoutOpenerInput, StoreShiftUncheckedCreateWithoutOpenerInput> | StoreShiftCreateWithoutOpenerInput[] | StoreShiftUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOpenerInput | StoreShiftCreateOrConnectWithoutOpenerInput[]
    createMany?: StoreShiftCreateManyOpenerInputEnvelope
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
  }

  export type DeviceTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CashShiftUncheckedCreateNestedManyWithoutKasirInput = {
    create?: XOR<CashShiftCreateWithoutKasirInput, CashShiftUncheckedCreateWithoutKasirInput> | CashShiftCreateWithoutKasirInput[] | CashShiftUncheckedCreateWithoutKasirInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutKasirInput | CashShiftCreateOrConnectWithoutKasirInput[]
    createMany?: CashShiftCreateManyKasirInputEnvelope
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
  }

  export type ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductAdjustmentCreateWithoutUserInput, ProductAdjustmentUncheckedCreateWithoutUserInput> | ProductAdjustmentCreateWithoutUserInput[] | ProductAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutUserInput | ProductAdjustmentCreateOrConnectWithoutUserInput[]
    createMany?: ProductAdjustmentCreateManyUserInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StoreShiftUncheckedCreateNestedManyWithoutOpenerInput = {
    create?: XOR<StoreShiftCreateWithoutOpenerInput, StoreShiftUncheckedCreateWithoutOpenerInput> | StoreShiftCreateWithoutOpenerInput[] | StoreShiftUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOpenerInput | StoreShiftCreateOrConnectWithoutOpenerInput[]
    createMany?: StoreShiftCreateManyOpenerInputEnvelope
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
  }

  export type DeviceTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CashShiftUpdateManyWithoutKasirNestedInput = {
    create?: XOR<CashShiftCreateWithoutKasirInput, CashShiftUncheckedCreateWithoutKasirInput> | CashShiftCreateWithoutKasirInput[] | CashShiftUncheckedCreateWithoutKasirInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutKasirInput | CashShiftCreateOrConnectWithoutKasirInput[]
    upsert?: CashShiftUpsertWithWhereUniqueWithoutKasirInput | CashShiftUpsertWithWhereUniqueWithoutKasirInput[]
    createMany?: CashShiftCreateManyKasirInputEnvelope
    set?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    disconnect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    delete?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    update?: CashShiftUpdateWithWhereUniqueWithoutKasirInput | CashShiftUpdateWithWhereUniqueWithoutKasirInput[]
    updateMany?: CashShiftUpdateManyWithWhereWithoutKasirInput | CashShiftUpdateManyWithWhereWithoutKasirInput[]
    deleteMany?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
  }

  export type ProductAdjustmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutUserInput, ProductAdjustmentUncheckedCreateWithoutUserInput> | ProductAdjustmentCreateWithoutUserInput[] | ProductAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutUserInput | ProductAdjustmentCreateOrConnectWithoutUserInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutUserInput | ProductAdjustmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductAdjustmentCreateManyUserInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutUserInput | ProductAdjustmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutUserInput | ProductAdjustmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StoreShiftUpdateManyWithoutOpenerNestedInput = {
    create?: XOR<StoreShiftCreateWithoutOpenerInput, StoreShiftUncheckedCreateWithoutOpenerInput> | StoreShiftCreateWithoutOpenerInput[] | StoreShiftUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOpenerInput | StoreShiftCreateOrConnectWithoutOpenerInput[]
    upsert?: StoreShiftUpsertWithWhereUniqueWithoutOpenerInput | StoreShiftUpsertWithWhereUniqueWithoutOpenerInput[]
    createMany?: StoreShiftCreateManyOpenerInputEnvelope
    set?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    disconnect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    delete?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    update?: StoreShiftUpdateWithWhereUniqueWithoutOpenerInput | StoreShiftUpdateWithWhereUniqueWithoutOpenerInput[]
    updateMany?: StoreShiftUpdateManyWithWhereWithoutOpenerInput | StoreShiftUpdateManyWithWhereWithoutOpenerInput[]
    deleteMany?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
  }

  export type DeviceTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CashShiftUncheckedUpdateManyWithoutKasirNestedInput = {
    create?: XOR<CashShiftCreateWithoutKasirInput, CashShiftUncheckedCreateWithoutKasirInput> | CashShiftCreateWithoutKasirInput[] | CashShiftUncheckedCreateWithoutKasirInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutKasirInput | CashShiftCreateOrConnectWithoutKasirInput[]
    upsert?: CashShiftUpsertWithWhereUniqueWithoutKasirInput | CashShiftUpsertWithWhereUniqueWithoutKasirInput[]
    createMany?: CashShiftCreateManyKasirInputEnvelope
    set?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    disconnect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    delete?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    update?: CashShiftUpdateWithWhereUniqueWithoutKasirInput | CashShiftUpdateWithWhereUniqueWithoutKasirInput[]
    updateMany?: CashShiftUpdateManyWithWhereWithoutKasirInput | CashShiftUpdateManyWithWhereWithoutKasirInput[]
    deleteMany?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutUserInput, ProductAdjustmentUncheckedCreateWithoutUserInput> | ProductAdjustmentCreateWithoutUserInput[] | ProductAdjustmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutUserInput | ProductAdjustmentCreateOrConnectWithoutUserInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutUserInput | ProductAdjustmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductAdjustmentCreateManyUserInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutUserInput | ProductAdjustmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutUserInput | ProductAdjustmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput = {
    create?: XOR<StoreShiftCreateWithoutOpenerInput, StoreShiftUncheckedCreateWithoutOpenerInput> | StoreShiftCreateWithoutOpenerInput[] | StoreShiftUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOpenerInput | StoreShiftCreateOrConnectWithoutOpenerInput[]
    upsert?: StoreShiftUpsertWithWhereUniqueWithoutOpenerInput | StoreShiftUpsertWithWhereUniqueWithoutOpenerInput[]
    createMany?: StoreShiftCreateManyOpenerInputEnvelope
    set?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    disconnect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    delete?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    update?: StoreShiftUpdateWithWhereUniqueWithoutOpenerInput | StoreShiftUpdateWithWhereUniqueWithoutOpenerInput[]
    updateMany?: StoreShiftUpdateManyWithWhereWithoutOpenerInput | StoreShiftUpdateManyWithWhereWithoutOpenerInput[]
    deleteMany?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutProductsInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductAdjustmentCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductAdjustmentCreateWithoutProductInput, ProductAdjustmentUncheckedCreateWithoutProductInput> | ProductAdjustmentCreateWithoutProductInput[] | ProductAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutProductInput | ProductAdjustmentCreateOrConnectWithoutProductInput[]
    createMany?: ProductAdjustmentCreateManyProductInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type PurchaseOrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type StockTransferItemCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransferItemCreateWithoutProductInput, StockTransferItemUncheckedCreateWithoutProductInput> | StockTransferItemCreateWithoutProductInput[] | StockTransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutProductInput | StockTransferItemCreateOrConnectWithoutProductInput[]
    createMany?: StockTransferItemCreateManyProductInputEnvelope
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
  }

  export type StockValuationCreateNestedManyWithoutProductInput = {
    create?: XOR<StockValuationCreateWithoutProductInput, StockValuationUncheckedCreateWithoutProductInput> | StockValuationCreateWithoutProductInput[] | StockValuationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutProductInput | StockValuationCreateOrConnectWithoutProductInput[]
    createMany?: StockValuationCreateManyProductInputEnvelope
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductAdjustmentCreateWithoutProductInput, ProductAdjustmentUncheckedCreateWithoutProductInput> | ProductAdjustmentCreateWithoutProductInput[] | ProductAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutProductInput | ProductAdjustmentCreateOrConnectWithoutProductInput[]
    createMany?: ProductAdjustmentCreateManyProductInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type StockTransferItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockTransferItemCreateWithoutProductInput, StockTransferItemUncheckedCreateWithoutProductInput> | StockTransferItemCreateWithoutProductInput[] | StockTransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutProductInput | StockTransferItemCreateOrConnectWithoutProductInput[]
    createMany?: StockTransferItemCreateManyProductInputEnvelope
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
  }

  export type StockValuationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockValuationCreateWithoutProductInput, StockValuationUncheckedCreateWithoutProductInput> | StockValuationCreateWithoutProductInput[] | StockValuationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutProductInput | StockValuationCreateOrConnectWithoutProductInput[]
    createMany?: StockValuationCreateManyProductInputEnvelope
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TenantUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    upsert?: TenantUpsertWithoutProductsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProductsInput, TenantUpdateWithoutProductsInput>, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductAdjustmentUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutProductInput, ProductAdjustmentUncheckedCreateWithoutProductInput> | ProductAdjustmentCreateWithoutProductInput[] | ProductAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutProductInput | ProductAdjustmentCreateOrConnectWithoutProductInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutProductInput | ProductAdjustmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductAdjustmentCreateManyProductInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutProductInput | ProductAdjustmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutProductInput | ProductAdjustmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type PurchaseOrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type StockTransferItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransferItemCreateWithoutProductInput, StockTransferItemUncheckedCreateWithoutProductInput> | StockTransferItemCreateWithoutProductInput[] | StockTransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutProductInput | StockTransferItemCreateOrConnectWithoutProductInput[]
    upsert?: StockTransferItemUpsertWithWhereUniqueWithoutProductInput | StockTransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTransferItemCreateManyProductInputEnvelope
    set?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    disconnect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    delete?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    update?: StockTransferItemUpdateWithWhereUniqueWithoutProductInput | StockTransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransferItemUpdateManyWithWhereWithoutProductInput | StockTransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransferItemScalarWhereInput | StockTransferItemScalarWhereInput[]
  }

  export type StockValuationUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockValuationCreateWithoutProductInput, StockValuationUncheckedCreateWithoutProductInput> | StockValuationCreateWithoutProductInput[] | StockValuationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutProductInput | StockValuationCreateOrConnectWithoutProductInput[]
    upsert?: StockValuationUpsertWithWhereUniqueWithoutProductInput | StockValuationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockValuationCreateManyProductInputEnvelope
    set?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    disconnect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    delete?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    update?: StockValuationUpdateWithWhereUniqueWithoutProductInput | StockValuationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockValuationUpdateManyWithWhereWithoutProductInput | StockValuationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockValuationScalarWhereInput | StockValuationScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutProductInput, ProductAdjustmentUncheckedCreateWithoutProductInput> | ProductAdjustmentCreateWithoutProductInput[] | ProductAdjustmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutProductInput | ProductAdjustmentCreateOrConnectWithoutProductInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutProductInput | ProductAdjustmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductAdjustmentCreateManyProductInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutProductInput | ProductAdjustmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutProductInput | ProductAdjustmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type StockTransferItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockTransferItemCreateWithoutProductInput, StockTransferItemUncheckedCreateWithoutProductInput> | StockTransferItemCreateWithoutProductInput[] | StockTransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutProductInput | StockTransferItemCreateOrConnectWithoutProductInput[]
    upsert?: StockTransferItemUpsertWithWhereUniqueWithoutProductInput | StockTransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockTransferItemCreateManyProductInputEnvelope
    set?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    disconnect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    delete?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    update?: StockTransferItemUpdateWithWhereUniqueWithoutProductInput | StockTransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockTransferItemUpdateManyWithWhereWithoutProductInput | StockTransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockTransferItemScalarWhereInput | StockTransferItemScalarWhereInput[]
  }

  export type StockValuationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockValuationCreateWithoutProductInput, StockValuationUncheckedCreateWithoutProductInput> | StockValuationCreateWithoutProductInput[] | StockValuationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockValuationCreateOrConnectWithoutProductInput | StockValuationCreateOrConnectWithoutProductInput[]
    upsert?: StockValuationUpsertWithWhereUniqueWithoutProductInput | StockValuationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockValuationCreateManyProductInputEnvelope
    set?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    disconnect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    delete?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    connect?: StockValuationWhereUniqueInput | StockValuationWhereUniqueInput[]
    update?: StockValuationUpdateWithWhereUniqueWithoutProductInput | StockValuationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockValuationUpdateManyWithWhereWithoutProductInput | StockValuationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockValuationScalarWhereInput | StockValuationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutProductAdjustmentsInput = {
    create?: XOR<TenantCreateWithoutProductAdjustmentsInput, TenantUncheckedCreateWithoutProductAdjustmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductAdjustmentsInput
    connect?: TenantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdjustmentsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductAdjustmentsInput = {
    create?: XOR<UserCreateWithoutProductAdjustmentsInput, UserUncheckedCreateWithoutProductAdjustmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductAdjustmentsInput
    connect?: UserWhereUniqueInput
  }

  export type StoreShiftCreateNestedOneWithoutProductAdjustmentsInput = {
    create?: XOR<StoreShiftCreateWithoutProductAdjustmentsInput, StoreShiftUncheckedCreateWithoutProductAdjustmentsInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutProductAdjustmentsInput
    connect?: StoreShiftWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutProductAdjustmentsNestedInput = {
    create?: XOR<TenantCreateWithoutProductAdjustmentsInput, TenantUncheckedCreateWithoutProductAdjustmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductAdjustmentsInput
    upsert?: TenantUpsertWithoutProductAdjustmentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProductAdjustmentsInput, TenantUpdateWithoutProductAdjustmentsInput>, TenantUncheckedUpdateWithoutProductAdjustmentsInput>
  }

  export type ProductUpdateOneRequiredWithoutAdjustmentsNestedInput = {
    create?: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdjustmentsInput
    upsert?: ProductUpsertWithoutAdjustmentsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdjustmentsInput, ProductUpdateWithoutAdjustmentsInput>, ProductUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type UserUpdateOneRequiredWithoutProductAdjustmentsNestedInput = {
    create?: XOR<UserCreateWithoutProductAdjustmentsInput, UserUncheckedCreateWithoutProductAdjustmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductAdjustmentsInput
    upsert?: UserUpsertWithoutProductAdjustmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductAdjustmentsInput, UserUpdateWithoutProductAdjustmentsInput>, UserUncheckedUpdateWithoutProductAdjustmentsInput>
  }

  export type StoreShiftUpdateOneWithoutProductAdjustmentsNestedInput = {
    create?: XOR<StoreShiftCreateWithoutProductAdjustmentsInput, StoreShiftUncheckedCreateWithoutProductAdjustmentsInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutProductAdjustmentsInput
    upsert?: StoreShiftUpsertWithoutProductAdjustmentsInput
    disconnect?: StoreShiftWhereInput | boolean
    delete?: StoreShiftWhereInput | boolean
    connect?: StoreShiftWhereUniqueInput
    update?: XOR<XOR<StoreShiftUpdateToOneWithWhereWithoutProductAdjustmentsInput, StoreShiftUpdateWithoutProductAdjustmentsInput>, StoreShiftUncheckedUpdateWithoutProductAdjustmentsInput>
  }

  export type TenantCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutOrdersInput = {
    create?: XOR<MemberCreateWithoutOrdersInput, MemberUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutOrdersInput
    connect?: MemberWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOrdersInput
    connect?: OutletWhereUniqueInput
  }

  export type StoreShiftCreateNestedOneWithoutOrdersInput = {
    create?: XOR<StoreShiftCreateWithoutOrdersInput, StoreShiftUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOrdersInput
    connect?: StoreShiftWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TransactionCreateNestedOneWithoutOrderInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput
    connect?: TransactionWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput
    connect?: TransactionWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type TenantUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    upsert?: TenantUpsertWithoutOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOrdersInput, TenantUpdateWithoutOrdersInput>, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type MemberUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<MemberCreateWithoutOrdersInput, MemberUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutOrdersInput
    upsert?: MemberUpsertWithoutOrdersInput
    disconnect?: MemberWhereInput | boolean
    delete?: MemberWhereInput | boolean
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutOrdersInput, MemberUpdateWithoutOrdersInput>, MemberUncheckedUpdateWithoutOrdersInput>
  }

  export type OutletUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OutletCreateOrConnectWithoutOrdersInput
    upsert?: OutletUpsertWithoutOrdersInput
    disconnect?: OutletWhereInput | boolean
    delete?: OutletWhereInput | boolean
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutOrdersInput, OutletUpdateWithoutOrdersInput>, OutletUncheckedUpdateWithoutOrdersInput>
  }

  export type StoreShiftUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<StoreShiftCreateWithoutOrdersInput, StoreShiftUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOrdersInput
    upsert?: StoreShiftUpsertWithoutOrdersInput
    disconnect?: StoreShiftWhereInput | boolean
    delete?: StoreShiftWhereInput | boolean
    connect?: StoreShiftWhereUniqueInput
    update?: XOR<XOR<StoreShiftUpdateToOneWithWhereWithoutOrdersInput, StoreShiftUpdateWithoutOrdersInput>, StoreShiftUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TransactionUpdateOneWithoutOrderNestedInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput
    upsert?: TransactionUpsertWithoutOrderInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutOrderInput, TransactionUpdateWithoutOrderInput>, TransactionUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput
    upsert?: TransactionUpsertWithoutOrderInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutOrderInput, TransactionUpdateWithoutOrderInput>, TransactionUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentMappingsInput = {
    create?: XOR<TenantCreateWithoutPaymentMappingsInput, TenantUncheckedCreateWithoutPaymentMappingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentMappingsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPaymentMappingsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentMappingsInput, TenantUncheckedCreateWithoutPaymentMappingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentMappingsInput
    upsert?: TenantUpsertWithoutPaymentMappingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentMappingsInput, TenantUpdateWithoutPaymentMappingsInput>, TenantUncheckedUpdateWithoutPaymentMappingsInput>
  }

  export type TenantCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutTransactionInput = {
    create?: XOR<OrderCreateWithoutTransactionInput, OrderUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTransactionInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type TenantUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    upsert?: TenantUpsertWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTransactionsInput, TenantUpdateWithoutTransactionsInput>, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type OrderUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<OrderCreateWithoutTransactionInput, OrderUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: OrderCreateOrConnectWithoutTransactionInput
    upsert?: OrderUpsertWithoutTransactionInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutTransactionInput, OrderUpdateWithoutTransactionInput>, OrderUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    upsert?: TenantUpsertWithoutCustomersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCustomersInput, TenantUpdateWithoutCustomersInput>, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutMembersInput = {
    create?: XOR<TenantCreateWithoutMembersInput, TenantUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembersInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutMemberInput = {
    create?: XOR<OrderCreateWithoutMemberInput, OrderUncheckedCreateWithoutMemberInput> | OrderCreateWithoutMemberInput[] | OrderUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMemberInput | OrderCreateOrConnectWithoutMemberInput[]
    createMany?: OrderCreateManyMemberInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<OrderCreateWithoutMemberInput, OrderUncheckedCreateWithoutMemberInput> | OrderCreateWithoutMemberInput[] | OrderUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMemberInput | OrderCreateOrConnectWithoutMemberInput[]
    createMany?: OrderCreateManyMemberInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TenantCreateWithoutMembersInput, TenantUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembersInput
    upsert?: TenantUpsertWithoutMembersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMembersInput, TenantUpdateWithoutMembersInput>, TenantUncheckedUpdateWithoutMembersInput>
  }

  export type OrderUpdateManyWithoutMemberNestedInput = {
    create?: XOR<OrderCreateWithoutMemberInput, OrderUncheckedCreateWithoutMemberInput> | OrderCreateWithoutMemberInput[] | OrderUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMemberInput | OrderCreateOrConnectWithoutMemberInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutMemberInput | OrderUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: OrderCreateManyMemberInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutMemberInput | OrderUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutMemberInput | OrderUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<OrderCreateWithoutMemberInput, OrderUncheckedCreateWithoutMemberInput> | OrderCreateWithoutMemberInput[] | OrderUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutMemberInput | OrderCreateOrConnectWithoutMemberInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutMemberInput | OrderUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: OrderCreateManyMemberInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutMemberInput | OrderUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutMemberInput | OrderUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    upsert?: TenantUpsertWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmployeesInput, TenantUpdateWithoutEmployeesInput>, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type TenantCreateNestedOneWithoutOutletsInput = {
    create?: XOR<TenantCreateWithoutOutletsInput, TenantUncheckedCreateWithoutOutletsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOutletsInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutOutletInput = {
    create?: XOR<OrderCreateWithoutOutletInput, OrderUncheckedCreateWithoutOutletInput> | OrderCreateWithoutOutletInput[] | OrderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOutletInput | OrderCreateOrConnectWithoutOutletInput[]
    createMany?: OrderCreateManyOutletInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type StoreShiftCreateNestedManyWithoutOutletInput = {
    create?: XOR<StoreShiftCreateWithoutOutletInput, StoreShiftUncheckedCreateWithoutOutletInput> | StoreShiftCreateWithoutOutletInput[] | StoreShiftUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOutletInput | StoreShiftCreateOrConnectWithoutOutletInput[]
    createMany?: StoreShiftCreateManyOutletInputEnvelope
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<OrderCreateWithoutOutletInput, OrderUncheckedCreateWithoutOutletInput> | OrderCreateWithoutOutletInput[] | OrderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOutletInput | OrderCreateOrConnectWithoutOutletInput[]
    createMany?: OrderCreateManyOutletInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type StoreShiftUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<StoreShiftCreateWithoutOutletInput, StoreShiftUncheckedCreateWithoutOutletInput> | StoreShiftCreateWithoutOutletInput[] | StoreShiftUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOutletInput | StoreShiftCreateOrConnectWithoutOutletInput[]
    createMany?: StoreShiftCreateManyOutletInputEnvelope
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutOutletsNestedInput = {
    create?: XOR<TenantCreateWithoutOutletsInput, TenantUncheckedCreateWithoutOutletsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOutletsInput
    upsert?: TenantUpsertWithoutOutletsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOutletsInput, TenantUpdateWithoutOutletsInput>, TenantUncheckedUpdateWithoutOutletsInput>
  }

  export type OrderUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OrderCreateWithoutOutletInput, OrderUncheckedCreateWithoutOutletInput> | OrderCreateWithoutOutletInput[] | OrderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOutletInput | OrderCreateOrConnectWithoutOutletInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOutletInput | OrderUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OrderCreateManyOutletInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOutletInput | OrderUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOutletInput | OrderUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type StoreShiftUpdateManyWithoutOutletNestedInput = {
    create?: XOR<StoreShiftCreateWithoutOutletInput, StoreShiftUncheckedCreateWithoutOutletInput> | StoreShiftCreateWithoutOutletInput[] | StoreShiftUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOutletInput | StoreShiftCreateOrConnectWithoutOutletInput[]
    upsert?: StoreShiftUpsertWithWhereUniqueWithoutOutletInput | StoreShiftUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: StoreShiftCreateManyOutletInputEnvelope
    set?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    disconnect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    delete?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    update?: StoreShiftUpdateWithWhereUniqueWithoutOutletInput | StoreShiftUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: StoreShiftUpdateManyWithWhereWithoutOutletInput | StoreShiftUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<OrderCreateWithoutOutletInput, OrderUncheckedCreateWithoutOutletInput> | OrderCreateWithoutOutletInput[] | OrderUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOutletInput | OrderCreateOrConnectWithoutOutletInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOutletInput | OrderUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: OrderCreateManyOutletInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOutletInput | OrderUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOutletInput | OrderUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type StoreShiftUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<StoreShiftCreateWithoutOutletInput, StoreShiftUncheckedCreateWithoutOutletInput> | StoreShiftCreateWithoutOutletInput[] | StoreShiftUncheckedCreateWithoutOutletInput[]
    connectOrCreate?: StoreShiftCreateOrConnectWithoutOutletInput | StoreShiftCreateOrConnectWithoutOutletInput[]
    upsert?: StoreShiftUpsertWithWhereUniqueWithoutOutletInput | StoreShiftUpsertWithWhereUniqueWithoutOutletInput[]
    createMany?: StoreShiftCreateManyOutletInputEnvelope
    set?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    disconnect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    delete?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    connect?: StoreShiftWhereUniqueInput | StoreShiftWhereUniqueInput[]
    update?: StoreShiftUpdateWithWhereUniqueWithoutOutletInput | StoreShiftUpdateWithWhereUniqueWithoutOutletInput[]
    updateMany?: StoreShiftUpdateManyWithWhereWithoutOutletInput | StoreShiftUpdateManyWithWhereWithoutOutletInput[]
    deleteMany?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutReportsInput = {
    create?: XOR<TenantCreateWithoutReportsInput, TenantUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReportsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<TenantCreateWithoutReportsInput, TenantUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReportsInput
    upsert?: TenantUpsertWithoutReportsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutReportsInput, TenantUpdateWithoutReportsInput>, TenantUncheckedUpdateWithoutReportsInput>
  }

  export type TenantCreateNestedOneWithoutAddonsInput = {
    create?: XOR<TenantCreateWithoutAddonsInput, TenantUncheckedCreateWithoutAddonsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAddonsInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutAddonsNestedInput = {
    create?: XOR<TenantCreateWithoutAddonsInput, TenantUncheckedCreateWithoutAddonsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAddonsInput
    upsert?: TenantUpsertWithoutAddonsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAddonsInput, TenantUpdateWithoutAddonsInput>, TenantUncheckedUpdateWithoutAddonsInput>
  }

  export type TenantCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<TenantCreateWithoutSubscriptionsInput, TenantUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionsInput
    connect?: TenantWhereUniqueInput
  }

  export type SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<TenantCreateWithoutSubscriptionsInput, TenantUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionsInput
    upsert?: TenantUpsertWithoutSubscriptionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSubscriptionsInput, TenantUpdateWithoutSubscriptionsInput>, TenantUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput> | SubscriptionHistoryCreateWithoutSubscriptionInput[] | SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput | SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionHistoryCreateManySubscriptionInputEnvelope
    set?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    disconnect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    delete?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    connect?: SubscriptionHistoryWhereUniqueInput | SubscriptionHistoryWhereUniqueInput[]
    update?: SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutSubscriptionHistoryInput = {
    create?: XOR<TenantCreateWithoutSubscriptionHistoryInput, TenantUncheckedCreateWithoutSubscriptionHistoryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionHistoryInput
    connect?: TenantWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutHistoryInput = {
    create?: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutHistoryInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutSubscriptionHistoryNestedInput = {
    create?: XOR<TenantCreateWithoutSubscriptionHistoryInput, TenantUncheckedCreateWithoutSubscriptionHistoryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionHistoryInput
    upsert?: TenantUpsertWithoutSubscriptionHistoryInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSubscriptionHistoryInput, TenantUpdateWithoutSubscriptionHistoryInput>, TenantUncheckedUpdateWithoutSubscriptionHistoryInput>
  }

  export type SubscriptionUpdateOneWithoutHistoryNestedInput = {
    create?: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutHistoryInput
    upsert?: SubscriptionUpsertWithoutHistoryInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutHistoryInput, SubscriptionUpdateWithoutHistoryInput>, SubscriptionUncheckedUpdateWithoutHistoryInput>
  }

  export type TenantCreateNestedOneWithoutReceiptTemplatesInput = {
    create?: XOR<TenantCreateWithoutReceiptTemplatesInput, TenantUncheckedCreateWithoutReceiptTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReceiptTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutReceiptTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutReceiptTemplatesInput, TenantUncheckedCreateWithoutReceiptTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReceiptTemplatesInput
    upsert?: TenantUpsertWithoutReceiptTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutReceiptTemplatesInput, TenantUpdateWithoutReceiptTemplatesInput>, TenantUncheckedUpdateWithoutReceiptTemplatesInput>
  }

  export type TenantCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<TenantCreateWithoutDiscountsInput, TenantUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDiscountsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<TenantCreateWithoutDiscountsInput, TenantUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDiscountsInput
    upsert?: TenantUpsertWithoutDiscountsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDiscountsInput, TenantUpdateWithoutDiscountsInput>, TenantUncheckedUpdateWithoutDiscountsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<TenantCreateWithoutWebhooksInput, TenantUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebhooksInput
    connect?: TenantWhereUniqueInput
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<TenantCreateWithoutWebhooksInput, TenantUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebhooksInput
    upsert?: TenantUpsertWithoutWebhooksInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWebhooksInput, TenantUpdateWithoutWebhooksInput>, TenantUncheckedUpdateWithoutWebhooksInput>
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
  }

  export type WebhookUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookUpsertWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutDeliveriesInput, WebhookUpdateWithoutDeliveriesInput>, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type TenantCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    upsert?: TenantUpsertWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSuppliersInput, TenantUpdateWithoutSuppliersInput>, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPurchaseOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: TenantUpsertWithoutPurchaseOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPurchaseOrdersInput, TenantUpdateWithoutPurchaseOrdersInput>, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ProductUpsertWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ProductUpdateWithoutPurchaseOrderItemsInput>, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type TenantCreateNestedOneWithoutStockTransfersInput = {
    create?: XOR<TenantCreateWithoutStockTransfersInput, TenantUncheckedCreateWithoutStockTransfersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockTransfersInput
    connect?: TenantWhereUniqueInput
  }

  export type StoreShiftCreateNestedOneWithoutStockTransfersInput = {
    create?: XOR<StoreShiftCreateWithoutStockTransfersInput, StoreShiftUncheckedCreateWithoutStockTransfersInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutStockTransfersInput
    connect?: StoreShiftWhereUniqueInput
  }

  export type StockTransferItemCreateNestedManyWithoutStockTransferInput = {
    create?: XOR<StockTransferItemCreateWithoutStockTransferInput, StockTransferItemUncheckedCreateWithoutStockTransferInput> | StockTransferItemCreateWithoutStockTransferInput[] | StockTransferItemUncheckedCreateWithoutStockTransferInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutStockTransferInput | StockTransferItemCreateOrConnectWithoutStockTransferInput[]
    createMany?: StockTransferItemCreateManyStockTransferInputEnvelope
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
  }

  export type StockTransferItemUncheckedCreateNestedManyWithoutStockTransferInput = {
    create?: XOR<StockTransferItemCreateWithoutStockTransferInput, StockTransferItemUncheckedCreateWithoutStockTransferInput> | StockTransferItemCreateWithoutStockTransferInput[] | StockTransferItemUncheckedCreateWithoutStockTransferInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutStockTransferInput | StockTransferItemCreateOrConnectWithoutStockTransferInput[]
    createMany?: StockTransferItemCreateManyStockTransferInputEnvelope
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutStockTransfersNestedInput = {
    create?: XOR<TenantCreateWithoutStockTransfersInput, TenantUncheckedCreateWithoutStockTransfersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockTransfersInput
    upsert?: TenantUpsertWithoutStockTransfersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStockTransfersInput, TenantUpdateWithoutStockTransfersInput>, TenantUncheckedUpdateWithoutStockTransfersInput>
  }

  export type StoreShiftUpdateOneWithoutStockTransfersNestedInput = {
    create?: XOR<StoreShiftCreateWithoutStockTransfersInput, StoreShiftUncheckedCreateWithoutStockTransfersInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutStockTransfersInput
    upsert?: StoreShiftUpsertWithoutStockTransfersInput
    disconnect?: StoreShiftWhereInput | boolean
    delete?: StoreShiftWhereInput | boolean
    connect?: StoreShiftWhereUniqueInput
    update?: XOR<XOR<StoreShiftUpdateToOneWithWhereWithoutStockTransfersInput, StoreShiftUpdateWithoutStockTransfersInput>, StoreShiftUncheckedUpdateWithoutStockTransfersInput>
  }

  export type StockTransferItemUpdateManyWithoutStockTransferNestedInput = {
    create?: XOR<StockTransferItemCreateWithoutStockTransferInput, StockTransferItemUncheckedCreateWithoutStockTransferInput> | StockTransferItemCreateWithoutStockTransferInput[] | StockTransferItemUncheckedCreateWithoutStockTransferInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutStockTransferInput | StockTransferItemCreateOrConnectWithoutStockTransferInput[]
    upsert?: StockTransferItemUpsertWithWhereUniqueWithoutStockTransferInput | StockTransferItemUpsertWithWhereUniqueWithoutStockTransferInput[]
    createMany?: StockTransferItemCreateManyStockTransferInputEnvelope
    set?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    disconnect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    delete?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    update?: StockTransferItemUpdateWithWhereUniqueWithoutStockTransferInput | StockTransferItemUpdateWithWhereUniqueWithoutStockTransferInput[]
    updateMany?: StockTransferItemUpdateManyWithWhereWithoutStockTransferInput | StockTransferItemUpdateManyWithWhereWithoutStockTransferInput[]
    deleteMany?: StockTransferItemScalarWhereInput | StockTransferItemScalarWhereInput[]
  }

  export type StockTransferItemUncheckedUpdateManyWithoutStockTransferNestedInput = {
    create?: XOR<StockTransferItemCreateWithoutStockTransferInput, StockTransferItemUncheckedCreateWithoutStockTransferInput> | StockTransferItemCreateWithoutStockTransferInput[] | StockTransferItemUncheckedCreateWithoutStockTransferInput[]
    connectOrCreate?: StockTransferItemCreateOrConnectWithoutStockTransferInput | StockTransferItemCreateOrConnectWithoutStockTransferInput[]
    upsert?: StockTransferItemUpsertWithWhereUniqueWithoutStockTransferInput | StockTransferItemUpsertWithWhereUniqueWithoutStockTransferInput[]
    createMany?: StockTransferItemCreateManyStockTransferInputEnvelope
    set?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    disconnect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    delete?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    connect?: StockTransferItemWhereUniqueInput | StockTransferItemWhereUniqueInput[]
    update?: StockTransferItemUpdateWithWhereUniqueWithoutStockTransferInput | StockTransferItemUpdateWithWhereUniqueWithoutStockTransferInput[]
    updateMany?: StockTransferItemUpdateManyWithWhereWithoutStockTransferInput | StockTransferItemUpdateManyWithWhereWithoutStockTransferInput[]
    deleteMany?: StockTransferItemScalarWhereInput | StockTransferItemScalarWhereInput[]
  }

  export type StockTransferCreateNestedOneWithoutItemsInput = {
    create?: XOR<StockTransferCreateWithoutItemsInput, StockTransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StockTransferCreateOrConnectWithoutItemsInput
    connect?: StockTransferWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockTransferItemsInput = {
    create?: XOR<ProductCreateWithoutStockTransferItemsInput, ProductUncheckedCreateWithoutStockTransferItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTransferItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type StockTransferUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<StockTransferCreateWithoutItemsInput, StockTransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StockTransferCreateOrConnectWithoutItemsInput
    upsert?: StockTransferUpsertWithoutItemsInput
    connect?: StockTransferWhereUniqueInput
    update?: XOR<XOR<StockTransferUpdateToOneWithWhereWithoutItemsInput, StockTransferUpdateWithoutItemsInput>, StockTransferUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockTransferItemsNestedInput = {
    create?: XOR<ProductCreateWithoutStockTransferItemsInput, ProductUncheckedCreateWithoutStockTransferItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockTransferItemsInput
    upsert?: ProductUpsertWithoutStockTransferItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockTransferItemsInput, ProductUpdateWithoutStockTransferItemsInput>, ProductUncheckedUpdateWithoutStockTransferItemsInput>
  }

  export type TenantCreateNestedOneWithoutStockValuationsInput = {
    create?: XOR<TenantCreateWithoutStockValuationsInput, TenantUncheckedCreateWithoutStockValuationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockValuationsInput
    connect?: TenantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockValuationsInput = {
    create?: XOR<ProductCreateWithoutStockValuationsInput, ProductUncheckedCreateWithoutStockValuationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockValuationsInput
    connect?: ProductWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutStockValuationsNestedInput = {
    create?: XOR<TenantCreateWithoutStockValuationsInput, TenantUncheckedCreateWithoutStockValuationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockValuationsInput
    upsert?: TenantUpsertWithoutStockValuationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStockValuationsInput, TenantUpdateWithoutStockValuationsInput>, TenantUncheckedUpdateWithoutStockValuationsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockValuationsNestedInput = {
    create?: XOR<ProductCreateWithoutStockValuationsInput, ProductUncheckedCreateWithoutStockValuationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockValuationsInput
    upsert?: ProductUpsertWithoutStockValuationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockValuationsInput, ProductUpdateWithoutStockValuationsInput>, ProductUncheckedUpdateWithoutStockValuationsInput>
  }

  export type TenantCreateNestedOneWithoutBackupLogsInput = {
    create?: XOR<TenantCreateWithoutBackupLogsInput, TenantUncheckedCreateWithoutBackupLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBackupLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutBackupLogsNestedInput = {
    create?: XOR<TenantCreateWithoutBackupLogsInput, TenantUncheckedCreateWithoutBackupLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBackupLogsInput
    upsert?: TenantUpsertWithoutBackupLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBackupLogsInput, TenantUpdateWithoutBackupLogsInput>, TenantUncheckedUpdateWithoutBackupLogsInput>
  }

  export type TenantCreateNestedOneWithoutStoreShiftsInput = {
    create?: XOR<TenantCreateWithoutStoreShiftsInput, TenantUncheckedCreateWithoutStoreShiftsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStoreShiftsInput
    connect?: TenantWhereUniqueInput
  }

  export type OutletCreateNestedOneWithoutStoreShiftsInput = {
    create?: XOR<OutletCreateWithoutStoreShiftsInput, OutletUncheckedCreateWithoutStoreShiftsInput>
    connectOrCreate?: OutletCreateOrConnectWithoutStoreShiftsInput
    connect?: OutletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoreShiftsInput = {
    create?: XOR<UserCreateWithoutStoreShiftsInput, UserUncheckedCreateWithoutStoreShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreShiftsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<OrderCreateWithoutStoreShiftInput, OrderUncheckedCreateWithoutStoreShiftInput> | OrderCreateWithoutStoreShiftInput[] | OrderUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreShiftInput | OrderCreateOrConnectWithoutStoreShiftInput[]
    createMany?: OrderCreateManyStoreShiftInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CashShiftCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<CashShiftCreateWithoutStoreShiftInput, CashShiftUncheckedCreateWithoutStoreShiftInput> | CashShiftCreateWithoutStoreShiftInput[] | CashShiftUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutStoreShiftInput | CashShiftCreateOrConnectWithoutStoreShiftInput[]
    createMany?: CashShiftCreateManyStoreShiftInputEnvelope
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
  }

  export type ProductAdjustmentCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<ProductAdjustmentCreateWithoutStoreShiftInput, ProductAdjustmentUncheckedCreateWithoutStoreShiftInput> | ProductAdjustmentCreateWithoutStoreShiftInput[] | ProductAdjustmentUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutStoreShiftInput | ProductAdjustmentCreateOrConnectWithoutStoreShiftInput[]
    createMany?: ProductAdjustmentCreateManyStoreShiftInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type StockTransferCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<StockTransferCreateWithoutStoreShiftInput, StockTransferUncheckedCreateWithoutStoreShiftInput> | StockTransferCreateWithoutStoreShiftInput[] | StockTransferUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutStoreShiftInput | StockTransferCreateOrConnectWithoutStoreShiftInput[]
    createMany?: StockTransferCreateManyStoreShiftInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<OrderCreateWithoutStoreShiftInput, OrderUncheckedCreateWithoutStoreShiftInput> | OrderCreateWithoutStoreShiftInput[] | OrderUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreShiftInput | OrderCreateOrConnectWithoutStoreShiftInput[]
    createMany?: OrderCreateManyStoreShiftInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<CashShiftCreateWithoutStoreShiftInput, CashShiftUncheckedCreateWithoutStoreShiftInput> | CashShiftCreateWithoutStoreShiftInput[] | CashShiftUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutStoreShiftInput | CashShiftCreateOrConnectWithoutStoreShiftInput[]
    createMany?: CashShiftCreateManyStoreShiftInputEnvelope
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
  }

  export type ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<ProductAdjustmentCreateWithoutStoreShiftInput, ProductAdjustmentUncheckedCreateWithoutStoreShiftInput> | ProductAdjustmentCreateWithoutStoreShiftInput[] | ProductAdjustmentUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutStoreShiftInput | ProductAdjustmentCreateOrConnectWithoutStoreShiftInput[]
    createMany?: ProductAdjustmentCreateManyStoreShiftInputEnvelope
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
  }

  export type StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput = {
    create?: XOR<StockTransferCreateWithoutStoreShiftInput, StockTransferUncheckedCreateWithoutStoreShiftInput> | StockTransferCreateWithoutStoreShiftInput[] | StockTransferUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutStoreShiftInput | StockTransferCreateOrConnectWithoutStoreShiftInput[]
    createMany?: StockTransferCreateManyStoreShiftInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutStoreShiftsNestedInput = {
    create?: XOR<TenantCreateWithoutStoreShiftsInput, TenantUncheckedCreateWithoutStoreShiftsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStoreShiftsInput
    upsert?: TenantUpsertWithoutStoreShiftsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStoreShiftsInput, TenantUpdateWithoutStoreShiftsInput>, TenantUncheckedUpdateWithoutStoreShiftsInput>
  }

  export type OutletUpdateOneRequiredWithoutStoreShiftsNestedInput = {
    create?: XOR<OutletCreateWithoutStoreShiftsInput, OutletUncheckedCreateWithoutStoreShiftsInput>
    connectOrCreate?: OutletCreateOrConnectWithoutStoreShiftsInput
    upsert?: OutletUpsertWithoutStoreShiftsInput
    connect?: OutletWhereUniqueInput
    update?: XOR<XOR<OutletUpdateToOneWithWhereWithoutStoreShiftsInput, OutletUpdateWithoutStoreShiftsInput>, OutletUncheckedUpdateWithoutStoreShiftsInput>
  }

  export type UserUpdateOneRequiredWithoutStoreShiftsNestedInput = {
    create?: XOR<UserCreateWithoutStoreShiftsInput, UserUncheckedCreateWithoutStoreShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreShiftsInput
    upsert?: UserUpsertWithoutStoreShiftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreShiftsInput, UserUpdateWithoutStoreShiftsInput>, UserUncheckedUpdateWithoutStoreShiftsInput>
  }

  export type OrderUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<OrderCreateWithoutStoreShiftInput, OrderUncheckedCreateWithoutStoreShiftInput> | OrderCreateWithoutStoreShiftInput[] | OrderUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreShiftInput | OrderCreateOrConnectWithoutStoreShiftInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStoreShiftInput | OrderUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: OrderCreateManyStoreShiftInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStoreShiftInput | OrderUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStoreShiftInput | OrderUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CashShiftUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<CashShiftCreateWithoutStoreShiftInput, CashShiftUncheckedCreateWithoutStoreShiftInput> | CashShiftCreateWithoutStoreShiftInput[] | CashShiftUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutStoreShiftInput | CashShiftCreateOrConnectWithoutStoreShiftInput[]
    upsert?: CashShiftUpsertWithWhereUniqueWithoutStoreShiftInput | CashShiftUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: CashShiftCreateManyStoreShiftInputEnvelope
    set?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    disconnect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    delete?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    update?: CashShiftUpdateWithWhereUniqueWithoutStoreShiftInput | CashShiftUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: CashShiftUpdateManyWithWhereWithoutStoreShiftInput | CashShiftUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
  }

  export type ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutStoreShiftInput, ProductAdjustmentUncheckedCreateWithoutStoreShiftInput> | ProductAdjustmentCreateWithoutStoreShiftInput[] | ProductAdjustmentUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutStoreShiftInput | ProductAdjustmentCreateOrConnectWithoutStoreShiftInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutStoreShiftInput | ProductAdjustmentUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: ProductAdjustmentCreateManyStoreShiftInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutStoreShiftInput | ProductAdjustmentUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutStoreShiftInput | ProductAdjustmentUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type StockTransferUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<StockTransferCreateWithoutStoreShiftInput, StockTransferUncheckedCreateWithoutStoreShiftInput> | StockTransferCreateWithoutStoreShiftInput[] | StockTransferUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutStoreShiftInput | StockTransferCreateOrConnectWithoutStoreShiftInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutStoreShiftInput | StockTransferUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: StockTransferCreateManyStoreShiftInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutStoreShiftInput | StockTransferUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutStoreShiftInput | StockTransferUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<OrderCreateWithoutStoreShiftInput, OrderUncheckedCreateWithoutStoreShiftInput> | OrderCreateWithoutStoreShiftInput[] | OrderUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStoreShiftInput | OrderCreateOrConnectWithoutStoreShiftInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStoreShiftInput | OrderUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: OrderCreateManyStoreShiftInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStoreShiftInput | OrderUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStoreShiftInput | OrderUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<CashShiftCreateWithoutStoreShiftInput, CashShiftUncheckedCreateWithoutStoreShiftInput> | CashShiftCreateWithoutStoreShiftInput[] | CashShiftUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: CashShiftCreateOrConnectWithoutStoreShiftInput | CashShiftCreateOrConnectWithoutStoreShiftInput[]
    upsert?: CashShiftUpsertWithWhereUniqueWithoutStoreShiftInput | CashShiftUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: CashShiftCreateManyStoreShiftInputEnvelope
    set?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    disconnect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    delete?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    connect?: CashShiftWhereUniqueInput | CashShiftWhereUniqueInput[]
    update?: CashShiftUpdateWithWhereUniqueWithoutStoreShiftInput | CashShiftUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: CashShiftUpdateManyWithWhereWithoutStoreShiftInput | CashShiftUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<ProductAdjustmentCreateWithoutStoreShiftInput, ProductAdjustmentUncheckedCreateWithoutStoreShiftInput> | ProductAdjustmentCreateWithoutStoreShiftInput[] | ProductAdjustmentUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: ProductAdjustmentCreateOrConnectWithoutStoreShiftInput | ProductAdjustmentCreateOrConnectWithoutStoreShiftInput[]
    upsert?: ProductAdjustmentUpsertWithWhereUniqueWithoutStoreShiftInput | ProductAdjustmentUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: ProductAdjustmentCreateManyStoreShiftInputEnvelope
    set?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    disconnect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    delete?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    connect?: ProductAdjustmentWhereUniqueInput | ProductAdjustmentWhereUniqueInput[]
    update?: ProductAdjustmentUpdateWithWhereUniqueWithoutStoreShiftInput | ProductAdjustmentUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: ProductAdjustmentUpdateManyWithWhereWithoutStoreShiftInput | ProductAdjustmentUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
  }

  export type StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput = {
    create?: XOR<StockTransferCreateWithoutStoreShiftInput, StockTransferUncheckedCreateWithoutStoreShiftInput> | StockTransferCreateWithoutStoreShiftInput[] | StockTransferUncheckedCreateWithoutStoreShiftInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutStoreShiftInput | StockTransferCreateOrConnectWithoutStoreShiftInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutStoreShiftInput | StockTransferUpsertWithWhereUniqueWithoutStoreShiftInput[]
    createMany?: StockTransferCreateManyStoreShiftInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutStoreShiftInput | StockTransferUpdateWithWhereUniqueWithoutStoreShiftInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutStoreShiftInput | StockTransferUpdateManyWithWhereWithoutStoreShiftInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutCashShiftsInput = {
    create?: XOR<TenantCreateWithoutCashShiftsInput, TenantUncheckedCreateWithoutCashShiftsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashShiftsInput
    connect?: TenantWhereUniqueInput
  }

  export type StoreShiftCreateNestedOneWithoutCashShiftsInput = {
    create?: XOR<StoreShiftCreateWithoutCashShiftsInput, StoreShiftUncheckedCreateWithoutCashShiftsInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutCashShiftsInput
    connect?: StoreShiftWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashShiftsInput = {
    create?: XOR<UserCreateWithoutCashShiftsInput, UserUncheckedCreateWithoutCashShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashShiftsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCashShiftsNestedInput = {
    create?: XOR<TenantCreateWithoutCashShiftsInput, TenantUncheckedCreateWithoutCashShiftsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashShiftsInput
    upsert?: TenantUpsertWithoutCashShiftsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashShiftsInput, TenantUpdateWithoutCashShiftsInput>, TenantUncheckedUpdateWithoutCashShiftsInput>
  }

  export type StoreShiftUpdateOneWithoutCashShiftsNestedInput = {
    create?: XOR<StoreShiftCreateWithoutCashShiftsInput, StoreShiftUncheckedCreateWithoutCashShiftsInput>
    connectOrCreate?: StoreShiftCreateOrConnectWithoutCashShiftsInput
    upsert?: StoreShiftUpsertWithoutCashShiftsInput
    disconnect?: StoreShiftWhereInput | boolean
    delete?: StoreShiftWhereInput | boolean
    connect?: StoreShiftWhereUniqueInput
    update?: XOR<XOR<StoreShiftUpdateToOneWithWhereWithoutCashShiftsInput, StoreShiftUpdateWithoutCashShiftsInput>, StoreShiftUncheckedUpdateWithoutCashShiftsInput>
  }

  export type UserUpdateOneRequiredWithoutCashShiftsNestedInput = {
    create?: XOR<UserCreateWithoutCashShiftsInput, UserUncheckedCreateWithoutCashShiftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashShiftsInput
    upsert?: UserUpsertWithoutCashShiftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashShiftsInput, UserUpdateWithoutCashShiftsInput>, UserUncheckedUpdateWithoutCashShiftsInput>
  }

  export type UserCreateNestedOneWithoutDeviceTokensInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceTokensNestedInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    upsert?: UserUpsertWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceTokensInput, UserUpdateWithoutDeviceTokensInput>, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type TenantCreateNestedOneWithoutCourierConfigsInput = {
    create?: XOR<TenantCreateWithoutCourierConfigsInput, TenantUncheckedCreateWithoutCourierConfigsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCourierConfigsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCourierConfigsNestedInput = {
    create?: XOR<TenantCreateWithoutCourierConfigsInput, TenantUncheckedCreateWithoutCourierConfigsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCourierConfigsInput
    upsert?: TenantUpsertWithoutCourierConfigsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCourierConfigsInput, TenantUpdateWithoutCourierConfigsInput>, TenantUncheckedUpdateWithoutCourierConfigsInput>
  }

  export type TenantCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSupportTicketsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneWithoutSupportTicketsNestedInput = {
    create?: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSupportTicketsInput
    upsert?: TenantUpsertWithoutSupportTicketsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSupportTicketsInput, TenantUpdateWithoutSupportTicketsInput>, TenantUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateOneWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemUncheckedCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTenantInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductCreateManyTenantInputEnvelope = {
    data: ProductCreateManyTenantInput | ProductCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutTenantInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTenantInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTenantInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput>
  }

  export type OrderCreateManyTenantInputEnvelope = {
    data: OrderCreateManyTenantInput | OrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTenantInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTenantInput = {
    id?: string
    orderId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionCreateManyTenantInputEnvelope = {
    data: TransactionCreateManyTenantInput | TransactionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerCreateManyTenantInputEnvelope = {
    data: CustomerCreateManyTenantInput | CustomerCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutTenantInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutTenantInput, MemberUncheckedCreateWithoutTenantInput>
  }

  export type MemberCreateManyTenantInputEnvelope = {
    data: MemberCreateManyTenantInput | MemberCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    position: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    position: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeCreateManyTenantInputEnvelope = {
    data: EmployeeCreateManyTenantInput | EmployeeCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OutletCreateWithoutTenantInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOutletInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOutletInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutTenantInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutTenantInput, OutletUncheckedCreateWithoutTenantInput>
  }

  export type OutletCreateManyTenantInputEnvelope = {
    data: OutletCreateManyTenantInput | OutletCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutTenantInput = {
    id?: string
    type: string
    period: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutTenantInput = {
    id?: string
    type: string
    period: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutTenantInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutTenantInput, ReportUncheckedCreateWithoutTenantInput>
  }

  export type ReportCreateManyTenantInputEnvelope = {
    data: ReportCreateManyTenantInput | ReportCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantAddonCreateWithoutTenantInput = {
    id?: string
    addonId: string
    addonName: string
    addonType: string
    status?: string
    limit?: number | null
    currentUsage?: number
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: string
  }

  export type TenantAddonUncheckedCreateWithoutTenantInput = {
    id?: string
    addonId: string
    addonName: string
    addonType: string
    status?: string
    limit?: number | null
    currentUsage?: number
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: string
  }

  export type TenantAddonCreateOrConnectWithoutTenantInput = {
    where: TenantAddonWhereUniqueInput
    create: XOR<TenantAddonCreateWithoutTenantInput, TenantAddonUncheckedCreateWithoutTenantInput>
  }

  export type TenantAddonCreateManyTenantInputEnvelope = {
    data: TenantAddonCreateManyTenantInput | TenantAddonCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutTenantInput = {
    id?: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
    history?: SubscriptionHistoryCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutTenantInput = {
    id?: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
    history?: SubscriptionHistoryUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutTenantInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutTenantInput, SubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type SubscriptionCreateManyTenantInputEnvelope = {
    data: SubscriptionCreateManyTenantInput | SubscriptionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionHistoryCreateWithoutTenantInput = {
    id?: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
    subscription?: SubscriptionCreateNestedOneWithoutHistoryInput
  }

  export type SubscriptionHistoryUncheckedCreateWithoutTenantInput = {
    id?: string
    subscriptionId?: string | null
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateOrConnectWithoutTenantInput = {
    where: SubscriptionHistoryWhereUniqueInput
    create: XOR<SubscriptionHistoryCreateWithoutTenantInput, SubscriptionHistoryUncheckedCreateWithoutTenantInput>
  }

  export type SubscriptionHistoryCreateManyTenantInputEnvelope = {
    data: SubscriptionHistoryCreateManyTenantInput | SubscriptionHistoryCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    templateType: string
    isDefault?: boolean
    paperSize?: string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    templateType: string
    isDefault?: boolean
    paperSize?: string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceiptTemplateCreateOrConnectWithoutTenantInput = {
    where: ReceiptTemplateWhereUniqueInput
    create: XOR<ReceiptTemplateCreateWithoutTenantInput, ReceiptTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ReceiptTemplateCreateManyTenantInputEnvelope = {
    data: ReceiptTemplateCreateManyTenantInput | ReceiptTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutTenantInput = {
    id?: string
    name: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    discountValueType: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    minQuantity?: number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: string | null
    applicableTo?: string
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    discountValueType: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    minQuantity?: number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: string | null
    applicableTo?: string
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountCreateOrConnectWithoutTenantInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutTenantInput, DiscountUncheckedCreateWithoutTenantInput>
  }

  export type DiscountCreateManyTenantInputEnvelope = {
    data: DiscountCreateManyTenantInput | DiscountCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMappingCreateWithoutTenantInput = {
    id?: string
    orderId: string
    itemId: string
    itemType: string
    itemName?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMappingUncheckedCreateWithoutTenantInput = {
    id?: string
    orderId: string
    itemId: string
    itemType: string
    itemName?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMappingCreateOrConnectWithoutTenantInput = {
    where: PaymentMappingWhereUniqueInput
    create: XOR<PaymentMappingCreateWithoutTenantInput, PaymentMappingUncheckedCreateWithoutTenantInput>
  }

  export type PaymentMappingCreateManyTenantInputEnvelope = {
    data: PaymentMappingCreateManyTenantInput | PaymentMappingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProductAdjustmentCreateWithoutTenantInput = {
    id?: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutAdjustmentsInput
    user: UserCreateNestedOneWithoutProductAdjustmentsInput
    storeShift?: StoreShiftCreateNestedOneWithoutProductAdjustmentsInput
  }

  export type ProductAdjustmentUncheckedCreateWithoutTenantInput = {
    id?: string
    productId: string
    userId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type ProductAdjustmentCreateOrConnectWithoutTenantInput = {
    where: ProductAdjustmentWhereUniqueInput
    create: XOR<ProductAdjustmentCreateWithoutTenantInput, ProductAdjustmentUncheckedCreateWithoutTenantInput>
  }

  export type ProductAdjustmentCreateManyTenantInputEnvelope = {
    data: ProductAdjustmentCreateManyTenantInput | ProductAdjustmentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutTenantInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateWithoutTenantInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookCreateOrConnectWithoutTenantInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutTenantInput, WebhookUncheckedCreateWithoutTenantInput>
  }

  export type WebhookCreateManyTenantInputEnvelope = {
    data: WebhookCreateManyTenantInput | WebhookCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierCreateManyTenantInputEnvelope = {
    data: SupplierCreateManyTenantInput | SupplierCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    supplierId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput>
  }

  export type PurchaseOrderCreateManyTenantInputEnvelope = {
    data: PurchaseOrderCreateManyTenantInput | PurchaseOrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StockTransferCreateWithoutTenantInput = {
    id?: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeShift?: StoreShiftCreateNestedOneWithoutStockTransfersInput
    items?: StockTransferItemCreateNestedManyWithoutStockTransferInput
  }

  export type StockTransferUncheckedCreateWithoutTenantInput = {
    id?: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    storeShiftId?: string | null
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockTransferItemUncheckedCreateNestedManyWithoutStockTransferInput
  }

  export type StockTransferCreateOrConnectWithoutTenantInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutTenantInput, StockTransferUncheckedCreateWithoutTenantInput>
  }

  export type StockTransferCreateManyTenantInputEnvelope = {
    data: StockTransferCreateManyTenantInput | StockTransferCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StockValuationCreateWithoutTenantInput = {
    id?: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockValuationsInput
  }

  export type StockValuationUncheckedCreateWithoutTenantInput = {
    id?: string
    productId: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockValuationCreateOrConnectWithoutTenantInput = {
    where: StockValuationWhereUniqueInput
    create: XOR<StockValuationCreateWithoutTenantInput, StockValuationUncheckedCreateWithoutTenantInput>
  }

  export type StockValuationCreateManyTenantInputEnvelope = {
    data: StockValuationCreateManyTenantInput | StockValuationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BackupLogCreateWithoutTenantInput = {
    id?: string
    status: string
    generatedAt?: Date | string
    emailSentAt?: Date | string | null
    size?: number | null
    filePath: string
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupLogUncheckedCreateWithoutTenantInput = {
    id?: string
    status: string
    generatedAt?: Date | string
    emailSentAt?: Date | string | null
    size?: number | null
    filePath: string
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupLogCreateOrConnectWithoutTenantInput = {
    where: BackupLogWhereUniqueInput
    create: XOR<BackupLogCreateWithoutTenantInput, BackupLogUncheckedCreateWithoutTenantInput>
  }

  export type BackupLogCreateManyTenantInputEnvelope = {
    data: BackupLogCreateManyTenantInput | BackupLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashShiftCreateWithoutTenantInput = {
    id?: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeShift?: StoreShiftCreateNestedOneWithoutCashShiftsInput
    kasir: UserCreateNestedOneWithoutCashShiftsInput
  }

  export type CashShiftUncheckedCreateWithoutTenantInput = {
    id?: string
    storeShiftId?: string | null
    kasirId: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftCreateOrConnectWithoutTenantInput = {
    where: CashShiftWhereUniqueInput
    create: XOR<CashShiftCreateWithoutTenantInput, CashShiftUncheckedCreateWithoutTenantInput>
  }

  export type CashShiftCreateManyTenantInputEnvelope = {
    data: CashShiftCreateManyTenantInput | CashShiftCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StoreShiftCreateWithoutTenantInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutTenantInput = {
    id?: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutTenantInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutTenantInput, StoreShiftUncheckedCreateWithoutTenantInput>
  }

  export type StoreShiftCreateManyTenantInputEnvelope = {
    data: StoreShiftCreateManyTenantInput | StoreShiftCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CourierConfigCreateWithoutTenantInput = {
    id?: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierConfigUncheckedCreateWithoutTenantInput = {
    id?: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierConfigCreateOrConnectWithoutTenantInput = {
    where: CourierConfigWhereUniqueInput
    create: XOR<CourierConfigCreateWithoutTenantInput, CourierConfigUncheckedCreateWithoutTenantInput>
  }

  export type CourierConfigCreateManyTenantInputEnvelope = {
    data: CourierConfigCreateManyTenantInput | CourierConfigCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutTenantInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutTenantInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput>
  }

  export type SupportTicketCreateManyTenantInputEnvelope = {
    data: SupportTicketCreateManyTenantInput | SupportTicketCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    permissions?: JsonNullableFilter<"User">
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    passwordHistory?: StringNullableFilter<"User"> | string | null
    passwordChangedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
  }

  export type ProductUpdateManyWithWhereWithoutTenantInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    tenantId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    barcode?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntFilter<"Product"> | number
    minStock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
    emoji?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    isConsignment?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutTenantInput, OrderUncheckedUpdateWithoutTenantInput>
    create: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutTenantInput, OrderUncheckedUpdateWithoutTenantInput>
  }

  export type OrderUpdateManyWithWhereWithoutTenantInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    idempotencyKey?: StringNullableFilter<"Order"> | string | null
    tenantId?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    memberId?: StringNullableFilter<"Order"> | string | null
    outletId?: StringNullableFilter<"Order"> | string | null
    storeShiftId?: StringNullableFilter<"Order"> | string | null
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    sendToKitchen?: BoolFilter<"Order"> | boolean
    kitchenStatus?: StringNullableFilter<"Order"> | string | null
    temporaryCustomerName?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTenantInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    orderId?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    reference?: StringNullableFilter<"Transaction"> | string | null
    qrCode?: StringNullableFilter<"Transaction"> | string | null
    qrCodeImage?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    servedBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
  }

  export type CustomerUpdateManyWithWhereWithoutTenantInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    tenantId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    birthday?: DateTimeNullableFilter<"Customer"> | Date | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type MemberUpsertWithWhereUniqueWithoutTenantInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutTenantInput, MemberUncheckedUpdateWithoutTenantInput>
    create: XOR<MemberCreateWithoutTenantInput, MemberUncheckedCreateWithoutTenantInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutTenantInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutTenantInput, MemberUncheckedUpdateWithoutTenantInput>
  }

  export type MemberUpdateManyWithWhereWithoutTenantInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutTenantInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    tenantId?: StringFilter<"Member"> | string
    name?: StringFilter<"Member"> | string
    email?: StringNullableFilter<"Member"> | string | null
    phone?: StringFilter<"Member"> | string
    address?: StringNullableFilter<"Member"> | string | null
    memberCode?: StringFilter<"Member"> | string
    discountType?: StringNullableFilter<"Member"> | string | null
    discountValue?: DecimalNullableFilter<"Member"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Member"> | boolean
    loyaltyPoints?: IntFilter<"Member"> | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutTenantInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutTenantInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    tenantId?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    position?: StringFilter<"Employee"> | string
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type OutletUpsertWithWhereUniqueWithoutTenantInput = {
    where: OutletWhereUniqueInput
    update: XOR<OutletUpdateWithoutTenantInput, OutletUncheckedUpdateWithoutTenantInput>
    create: XOR<OutletCreateWithoutTenantInput, OutletUncheckedCreateWithoutTenantInput>
  }

  export type OutletUpdateWithWhereUniqueWithoutTenantInput = {
    where: OutletWhereUniqueInput
    data: XOR<OutletUpdateWithoutTenantInput, OutletUncheckedUpdateWithoutTenantInput>
  }

  export type OutletUpdateManyWithWhereWithoutTenantInput = {
    where: OutletScalarWhereInput
    data: XOR<OutletUpdateManyMutationInput, OutletUncheckedUpdateManyWithoutTenantInput>
  }

  export type OutletScalarWhereInput = {
    AND?: OutletScalarWhereInput | OutletScalarWhereInput[]
    OR?: OutletScalarWhereInput[]
    NOT?: OutletScalarWhereInput | OutletScalarWhereInput[]
    id?: StringFilter<"Outlet"> | string
    tenantId?: StringFilter<"Outlet"> | string
    name?: StringFilter<"Outlet"> | string
    address?: StringNullableFilter<"Outlet"> | string | null
    phone?: StringNullableFilter<"Outlet"> | string | null
    isActive?: BoolFilter<"Outlet"> | boolean
    shiftConfig?: JsonNullableFilter<"Outlet">
    operatingHours?: JsonNullableFilter<"Outlet">
    createdAt?: DateTimeFilter<"Outlet"> | Date | string
    updatedAt?: DateTimeFilter<"Outlet"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutTenantInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutTenantInput, ReportUncheckedUpdateWithoutTenantInput>
    create: XOR<ReportCreateWithoutTenantInput, ReportUncheckedCreateWithoutTenantInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutTenantInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutTenantInput, ReportUncheckedUpdateWithoutTenantInput>
  }

  export type ReportUpdateManyWithWhereWithoutTenantInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutTenantInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    tenantId?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    period?: StringFilter<"Report"> | string
    data?: JsonFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type TenantAddonUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantAddonWhereUniqueInput
    update: XOR<TenantAddonUpdateWithoutTenantInput, TenantAddonUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantAddonCreateWithoutTenantInput, TenantAddonUncheckedCreateWithoutTenantInput>
  }

  export type TenantAddonUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantAddonWhereUniqueInput
    data: XOR<TenantAddonUpdateWithoutTenantInput, TenantAddonUncheckedUpdateWithoutTenantInput>
  }

  export type TenantAddonUpdateManyWithWhereWithoutTenantInput = {
    where: TenantAddonScalarWhereInput
    data: XOR<TenantAddonUpdateManyMutationInput, TenantAddonUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantAddonScalarWhereInput = {
    AND?: TenantAddonScalarWhereInput | TenantAddonScalarWhereInput[]
    OR?: TenantAddonScalarWhereInput[]
    NOT?: TenantAddonScalarWhereInput | TenantAddonScalarWhereInput[]
    id?: StringFilter<"TenantAddon"> | string
    tenantId?: StringFilter<"TenantAddon"> | string
    addonId?: StringFilter<"TenantAddon"> | string
    addonName?: StringFilter<"TenantAddon"> | string
    addonType?: StringFilter<"TenantAddon"> | string
    status?: StringFilter<"TenantAddon"> | string
    limit?: IntNullableFilter<"TenantAddon"> | number | null
    currentUsage?: IntFilter<"TenantAddon"> | number
    subscribedAt?: DateTimeFilter<"TenantAddon"> | Date | string
    expiresAt?: DateTimeNullableFilter<"TenantAddon"> | Date | string | null
    config?: JsonNullableFilter<"TenantAddon">
    purchasedBy?: StringFilter<"TenantAddon"> | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutTenantInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutTenantInput, SubscriptionUncheckedUpdateWithoutTenantInput>
    create: XOR<SubscriptionCreateWithoutTenantInput, SubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutTenantInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutTenantInput, SubscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutTenantInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutTenantInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    tenantId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeFilter<"Subscription"> | Date | string
    status?: StringFilter<"Subscription"> | string
    amount?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFilter<"Subscription"> | boolean
    previousPlan?: StringNullableFilter<"Subscription"> | string | null
    purchasedBy?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type SubscriptionHistoryUpsertWithWhereUniqueWithoutTenantInput = {
    where: SubscriptionHistoryWhereUniqueInput
    update: XOR<SubscriptionHistoryUpdateWithoutTenantInput, SubscriptionHistoryUncheckedUpdateWithoutTenantInput>
    create: XOR<SubscriptionHistoryCreateWithoutTenantInput, SubscriptionHistoryUncheckedCreateWithoutTenantInput>
  }

  export type SubscriptionHistoryUpdateWithWhereUniqueWithoutTenantInput = {
    where: SubscriptionHistoryWhereUniqueInput
    data: XOR<SubscriptionHistoryUpdateWithoutTenantInput, SubscriptionHistoryUncheckedUpdateWithoutTenantInput>
  }

  export type SubscriptionHistoryUpdateManyWithWhereWithoutTenantInput = {
    where: SubscriptionHistoryScalarWhereInput
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyWithoutTenantInput>
  }

  export type SubscriptionHistoryScalarWhereInput = {
    AND?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
    OR?: SubscriptionHistoryScalarWhereInput[]
    NOT?: SubscriptionHistoryScalarWhereInput | SubscriptionHistoryScalarWhereInput[]
    id?: StringFilter<"SubscriptionHistory"> | string
    subscriptionId?: StringNullableFilter<"SubscriptionHistory"> | string | null
    tenantId?: StringFilter<"SubscriptionHistory"> | string
    planType?: StringFilter<"SubscriptionHistory"> | string
    startDate?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    endDate?: DateTimeFilter<"SubscriptionHistory"> | Date | string
    price?: DecimalFilter<"SubscriptionHistory"> | Decimal | DecimalJsLike | number | string
    durationDays?: IntFilter<"SubscriptionHistory"> | number
    isTemporary?: BoolFilter<"SubscriptionHistory"> | boolean
    reverted?: BoolFilter<"SubscriptionHistory"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionHistory"> | Date | string
  }

  export type ReceiptTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: ReceiptTemplateWhereUniqueInput
    update: XOR<ReceiptTemplateUpdateWithoutTenantInput, ReceiptTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<ReceiptTemplateCreateWithoutTenantInput, ReceiptTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ReceiptTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: ReceiptTemplateWhereUniqueInput
    data: XOR<ReceiptTemplateUpdateWithoutTenantInput, ReceiptTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type ReceiptTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: ReceiptTemplateScalarWhereInput
    data: XOR<ReceiptTemplateUpdateManyMutationInput, ReceiptTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type ReceiptTemplateScalarWhereInput = {
    AND?: ReceiptTemplateScalarWhereInput | ReceiptTemplateScalarWhereInput[]
    OR?: ReceiptTemplateScalarWhereInput[]
    NOT?: ReceiptTemplateScalarWhereInput | ReceiptTemplateScalarWhereInput[]
    id?: StringFilter<"ReceiptTemplate"> | string
    tenantId?: StringFilter<"ReceiptTemplate"> | string
    name?: StringFilter<"ReceiptTemplate"> | string
    templateType?: StringFilter<"ReceiptTemplate"> | string
    isDefault?: BoolFilter<"ReceiptTemplate"> | boolean
    paperSize?: StringFilter<"ReceiptTemplate"> | string
    header?: JsonNullableFilter<"ReceiptTemplate">
    footer?: JsonNullableFilter<"ReceiptTemplate">
    fields?: JsonNullableFilter<"ReceiptTemplate">
    styles?: JsonNullableFilter<"ReceiptTemplate">
    createdAt?: DateTimeFilter<"ReceiptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReceiptTemplate"> | Date | string
  }

  export type DiscountUpsertWithWhereUniqueWithoutTenantInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutTenantInput, DiscountUncheckedUpdateWithoutTenantInput>
    create: XOR<DiscountCreateWithoutTenantInput, DiscountUncheckedCreateWithoutTenantInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutTenantInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutTenantInput, DiscountUncheckedUpdateWithoutTenantInput>
  }

  export type DiscountUpdateManyWithWhereWithoutTenantInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutTenantInput>
  }

  export type DiscountScalarWhereInput = {
    AND?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    OR?: DiscountScalarWhereInput[]
    NOT?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    id?: StringFilter<"Discount"> | string
    tenantId?: StringFilter<"Discount"> | string
    name?: StringFilter<"Discount"> | string
    discountType?: StringFilter<"Discount"> | string
    discountValue?: DecimalFilter<"Discount"> | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFilter<"Discount"> | string
    minAmount?: DecimalNullableFilter<"Discount"> | Decimal | DecimalJsLike | number | string | null
    minQuantity?: IntNullableFilter<"Discount"> | number | null
    applicableProducts?: JsonNullableFilter<"Discount">
    bundleProducts?: JsonNullableFilter<"Discount">
    bundleDiscountProduct?: StringNullableFilter<"Discount"> | string | null
    applicableTo?: StringFilter<"Discount"> | string
    isActive?: BoolFilter<"Discount"> | boolean
    startDate?: DateTimeNullableFilter<"Discount"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Discount"> | Date | string | null
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
  }

  export type PaymentMappingUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentMappingWhereUniqueInput
    update: XOR<PaymentMappingUpdateWithoutTenantInput, PaymentMappingUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentMappingCreateWithoutTenantInput, PaymentMappingUncheckedCreateWithoutTenantInput>
  }

  export type PaymentMappingUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentMappingWhereUniqueInput
    data: XOR<PaymentMappingUpdateWithoutTenantInput, PaymentMappingUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentMappingUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentMappingScalarWhereInput
    data: XOR<PaymentMappingUpdateManyMutationInput, PaymentMappingUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentMappingScalarWhereInput = {
    AND?: PaymentMappingScalarWhereInput | PaymentMappingScalarWhereInput[]
    OR?: PaymentMappingScalarWhereInput[]
    NOT?: PaymentMappingScalarWhereInput | PaymentMappingScalarWhereInput[]
    id?: StringFilter<"PaymentMapping"> | string
    orderId?: StringFilter<"PaymentMapping"> | string
    tenantId?: StringFilter<"PaymentMapping"> | string
    itemId?: StringFilter<"PaymentMapping"> | string
    itemType?: StringFilter<"PaymentMapping"> | string
    itemName?: StringNullableFilter<"PaymentMapping"> | string | null
    amount?: DecimalFilter<"PaymentMapping"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PaymentMapping"> | string
    createdAt?: DateTimeFilter<"PaymentMapping"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMapping"> | Date | string
  }

  export type ProductAdjustmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProductAdjustmentWhereUniqueInput
    update: XOR<ProductAdjustmentUpdateWithoutTenantInput, ProductAdjustmentUncheckedUpdateWithoutTenantInput>
    create: XOR<ProductAdjustmentCreateWithoutTenantInput, ProductAdjustmentUncheckedCreateWithoutTenantInput>
  }

  export type ProductAdjustmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProductAdjustmentWhereUniqueInput
    data: XOR<ProductAdjustmentUpdateWithoutTenantInput, ProductAdjustmentUncheckedUpdateWithoutTenantInput>
  }

  export type ProductAdjustmentUpdateManyWithWhereWithoutTenantInput = {
    where: ProductAdjustmentScalarWhereInput
    data: XOR<ProductAdjustmentUpdateManyMutationInput, ProductAdjustmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProductAdjustmentScalarWhereInput = {
    AND?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
    OR?: ProductAdjustmentScalarWhereInput[]
    NOT?: ProductAdjustmentScalarWhereInput | ProductAdjustmentScalarWhereInput[]
    id?: StringFilter<"ProductAdjustment"> | string
    tenantId?: StringFilter<"ProductAdjustment"> | string
    productId?: StringFilter<"ProductAdjustment"> | string
    userId?: StringFilter<"ProductAdjustment"> | string
    storeShiftId?: StringNullableFilter<"ProductAdjustment"> | string | null
    type?: StringFilter<"ProductAdjustment"> | string
    quantity?: IntFilter<"ProductAdjustment"> | number
    reason?: StringFilter<"ProductAdjustment"> | string
    stockBefore?: IntFilter<"ProductAdjustment"> | number
    stockAfter?: IntFilter<"ProductAdjustment"> | number
    createdAt?: DateTimeFilter<"ProductAdjustment"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userEmail?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type WebhookUpsertWithWhereUniqueWithoutTenantInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutTenantInput, WebhookUncheckedUpdateWithoutTenantInput>
    create: XOR<WebhookCreateWithoutTenantInput, WebhookUncheckedCreateWithoutTenantInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutTenantInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutTenantInput, WebhookUncheckedUpdateWithoutTenantInput>
  }

  export type WebhookUpdateManyWithWhereWithoutTenantInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutTenantInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: StringFilter<"Webhook"> | string
    tenantId?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    isActive?: BoolFilter<"Webhook"> | boolean
    retryCount?: IntFilter<"Webhook"> | number
    timeout?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
  }

  export type SupplierUpdateManyWithWhereWithoutTenantInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutTenantInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutTenantInput, PurchaseOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutTenantInput, PurchaseOrderUncheckedUpdateWithoutTenantInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutTenantInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    tenantId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    totalAmount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdBy?: StringFilter<"PurchaseOrder"> | string
    approvedBy?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type StockTransferUpsertWithWhereUniqueWithoutTenantInput = {
    where: StockTransferWhereUniqueInput
    update: XOR<StockTransferUpdateWithoutTenantInput, StockTransferUncheckedUpdateWithoutTenantInput>
    create: XOR<StockTransferCreateWithoutTenantInput, StockTransferUncheckedCreateWithoutTenantInput>
  }

  export type StockTransferUpdateWithWhereUniqueWithoutTenantInput = {
    where: StockTransferWhereUniqueInput
    data: XOR<StockTransferUpdateWithoutTenantInput, StockTransferUncheckedUpdateWithoutTenantInput>
  }

  export type StockTransferUpdateManyWithWhereWithoutTenantInput = {
    where: StockTransferScalarWhereInput
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyWithoutTenantInput>
  }

  export type StockTransferScalarWhereInput = {
    AND?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
    OR?: StockTransferScalarWhereInput[]
    NOT?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
    id?: StringFilter<"StockTransfer"> | string
    tenantId?: StringFilter<"StockTransfer"> | string
    fromOutletId?: StringFilter<"StockTransfer"> | string
    toOutletId?: StringFilter<"StockTransfer"> | string
    transferNumber?: StringFilter<"StockTransfer"> | string
    storeShiftId?: StringNullableFilter<"StockTransfer"> | string | null
    status?: StringFilter<"StockTransfer"> | string
    transferDate?: DateTimeFilter<"StockTransfer"> | Date | string
    receivedDate?: DateTimeNullableFilter<"StockTransfer"> | Date | string | null
    notes?: StringNullableFilter<"StockTransfer"> | string | null
    createdBy?: StringFilter<"StockTransfer"> | string
    receivedBy?: StringNullableFilter<"StockTransfer"> | string | null
    createdAt?: DateTimeFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransfer"> | Date | string
  }

  export type StockValuationUpsertWithWhereUniqueWithoutTenantInput = {
    where: StockValuationWhereUniqueInput
    update: XOR<StockValuationUpdateWithoutTenantInput, StockValuationUncheckedUpdateWithoutTenantInput>
    create: XOR<StockValuationCreateWithoutTenantInput, StockValuationUncheckedCreateWithoutTenantInput>
  }

  export type StockValuationUpdateWithWhereUniqueWithoutTenantInput = {
    where: StockValuationWhereUniqueInput
    data: XOR<StockValuationUpdateWithoutTenantInput, StockValuationUncheckedUpdateWithoutTenantInput>
  }

  export type StockValuationUpdateManyWithWhereWithoutTenantInput = {
    where: StockValuationScalarWhereInput
    data: XOR<StockValuationUpdateManyMutationInput, StockValuationUncheckedUpdateManyWithoutTenantInput>
  }

  export type StockValuationScalarWhereInput = {
    AND?: StockValuationScalarWhereInput | StockValuationScalarWhereInput[]
    OR?: StockValuationScalarWhereInput[]
    NOT?: StockValuationScalarWhereInput | StockValuationScalarWhereInput[]
    id?: StringFilter<"StockValuation"> | string
    tenantId?: StringFilter<"StockValuation"> | string
    productId?: StringFilter<"StockValuation"> | string
    valuationType?: StringFilter<"StockValuation"> | string
    quantity?: IntFilter<"StockValuation"> | number
    unitCost?: DecimalFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFilter<"StockValuation"> | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFilter<"StockValuation"> | Date | string
    purchaseOrderId?: StringNullableFilter<"StockValuation"> | string | null
    createdAt?: DateTimeFilter<"StockValuation"> | Date | string
    updatedAt?: DateTimeFilter<"StockValuation"> | Date | string
  }

  export type BackupLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: BackupLogWhereUniqueInput
    update: XOR<BackupLogUpdateWithoutTenantInput, BackupLogUncheckedUpdateWithoutTenantInput>
    create: XOR<BackupLogCreateWithoutTenantInput, BackupLogUncheckedCreateWithoutTenantInput>
  }

  export type BackupLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: BackupLogWhereUniqueInput
    data: XOR<BackupLogUpdateWithoutTenantInput, BackupLogUncheckedUpdateWithoutTenantInput>
  }

  export type BackupLogUpdateManyWithWhereWithoutTenantInput = {
    where: BackupLogScalarWhereInput
    data: XOR<BackupLogUpdateManyMutationInput, BackupLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type BackupLogScalarWhereInput = {
    AND?: BackupLogScalarWhereInput | BackupLogScalarWhereInput[]
    OR?: BackupLogScalarWhereInput[]
    NOT?: BackupLogScalarWhereInput | BackupLogScalarWhereInput[]
    id?: StringFilter<"BackupLog"> | string
    tenantId?: StringFilter<"BackupLog"> | string
    status?: StringFilter<"BackupLog"> | string
    generatedAt?: DateTimeFilter<"BackupLog"> | Date | string
    emailSentAt?: DateTimeNullableFilter<"BackupLog"> | Date | string | null
    size?: IntNullableFilter<"BackupLog"> | number | null
    filePath?: StringFilter<"BackupLog"> | string
    errorMessage?: StringNullableFilter<"BackupLog"> | string | null
    createdAt?: DateTimeFilter<"BackupLog"> | Date | string
    updatedAt?: DateTimeFilter<"BackupLog"> | Date | string
  }

  export type CashShiftUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashShiftWhereUniqueInput
    update: XOR<CashShiftUpdateWithoutTenantInput, CashShiftUncheckedUpdateWithoutTenantInput>
    create: XOR<CashShiftCreateWithoutTenantInput, CashShiftUncheckedCreateWithoutTenantInput>
  }

  export type CashShiftUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashShiftWhereUniqueInput
    data: XOR<CashShiftUpdateWithoutTenantInput, CashShiftUncheckedUpdateWithoutTenantInput>
  }

  export type CashShiftUpdateManyWithWhereWithoutTenantInput = {
    where: CashShiftScalarWhereInput
    data: XOR<CashShiftUpdateManyMutationInput, CashShiftUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashShiftScalarWhereInput = {
    AND?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
    OR?: CashShiftScalarWhereInput[]
    NOT?: CashShiftScalarWhereInput | CashShiftScalarWhereInput[]
    id?: StringFilter<"CashShift"> | string
    tenantId?: StringFilter<"CashShift"> | string
    storeShiftId?: StringNullableFilter<"CashShift"> | string | null
    kasirId?: StringFilter<"CashShift"> | string
    shiftStart?: DateTimeFilter<"CashShift"> | Date | string
    shiftEnd?: DateTimeNullableFilter<"CashShift"> | Date | string | null
    modalAwal?: DecimalFilter<"CashShift"> | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    selisih?: DecimalNullableFilter<"CashShift"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"CashShift"> | string
    catatan?: StringNullableFilter<"CashShift"> | string | null
    createdAt?: DateTimeFilter<"CashShift"> | Date | string
    updatedAt?: DateTimeFilter<"CashShift"> | Date | string
  }

  export type StoreShiftUpsertWithWhereUniqueWithoutTenantInput = {
    where: StoreShiftWhereUniqueInput
    update: XOR<StoreShiftUpdateWithoutTenantInput, StoreShiftUncheckedUpdateWithoutTenantInput>
    create: XOR<StoreShiftCreateWithoutTenantInput, StoreShiftUncheckedCreateWithoutTenantInput>
  }

  export type StoreShiftUpdateWithWhereUniqueWithoutTenantInput = {
    where: StoreShiftWhereUniqueInput
    data: XOR<StoreShiftUpdateWithoutTenantInput, StoreShiftUncheckedUpdateWithoutTenantInput>
  }

  export type StoreShiftUpdateManyWithWhereWithoutTenantInput = {
    where: StoreShiftScalarWhereInput
    data: XOR<StoreShiftUpdateManyMutationInput, StoreShiftUncheckedUpdateManyWithoutTenantInput>
  }

  export type StoreShiftScalarWhereInput = {
    AND?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
    OR?: StoreShiftScalarWhereInput[]
    NOT?: StoreShiftScalarWhereInput | StoreShiftScalarWhereInput[]
    id?: StringFilter<"StoreShift"> | string
    tenantId?: StringFilter<"StoreShift"> | string
    outletId?: StringFilter<"StoreShift"> | string
    shiftType?: StringFilter<"StoreShift"> | string
    openedBy?: StringFilter<"StoreShift"> | string
    openedAt?: DateTimeFilter<"StoreShift"> | Date | string
    closedAt?: DateTimeNullableFilter<"StoreShift"> | Date | string | null
    status?: StringFilter<"StoreShift"> | string
    modalAwal?: DecimalNullableFilter<"StoreShift"> | Decimal | DecimalJsLike | number | string | null
    catatan?: StringNullableFilter<"StoreShift"> | string | null
    createdAt?: DateTimeFilter<"StoreShift"> | Date | string
    updatedAt?: DateTimeFilter<"StoreShift"> | Date | string
  }

  export type CourierConfigUpsertWithWhereUniqueWithoutTenantInput = {
    where: CourierConfigWhereUniqueInput
    update: XOR<CourierConfigUpdateWithoutTenantInput, CourierConfigUncheckedUpdateWithoutTenantInput>
    create: XOR<CourierConfigCreateWithoutTenantInput, CourierConfigUncheckedCreateWithoutTenantInput>
  }

  export type CourierConfigUpdateWithWhereUniqueWithoutTenantInput = {
    where: CourierConfigWhereUniqueInput
    data: XOR<CourierConfigUpdateWithoutTenantInput, CourierConfigUncheckedUpdateWithoutTenantInput>
  }

  export type CourierConfigUpdateManyWithWhereWithoutTenantInput = {
    where: CourierConfigScalarWhereInput
    data: XOR<CourierConfigUpdateManyMutationInput, CourierConfigUncheckedUpdateManyWithoutTenantInput>
  }

  export type CourierConfigScalarWhereInput = {
    AND?: CourierConfigScalarWhereInput | CourierConfigScalarWhereInput[]
    OR?: CourierConfigScalarWhereInput[]
    NOT?: CourierConfigScalarWhereInput | CourierConfigScalarWhereInput[]
    id?: StringFilter<"CourierConfig"> | string
    tenantId?: StringFilter<"CourierConfig"> | string
    courier?: StringFilter<"CourierConfig"> | string
    apiKey?: StringFilter<"CourierConfig"> | string
    apiSecret?: StringFilter<"CourierConfig"> | string
    baseUrl?: StringNullableFilter<"CourierConfig"> | string | null
    isActive?: BoolFilter<"CourierConfig"> | boolean
    createdAt?: DateTimeFilter<"CourierConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CourierConfig"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutTenantInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutTenantInput, SupportTicketUncheckedUpdateWithoutTenantInput>
    create: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutTenantInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutTenantInput, SupportTicketUncheckedUpdateWithoutTenantInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutTenantInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutTenantInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    tenantId?: StringNullableFilter<"SupportTicket"> | string | null
    userId?: StringNullableFilter<"SupportTicket"> | string | null
    name?: StringFilter<"SupportTicket"> | string
    email?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    type?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    reply?: StringNullableFilter<"SupportTicket"> | string | null
    repliedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    repliedBy?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    order: OrderCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    orderId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CashShiftCreateWithoutKasirInput = {
    id?: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashShiftsInput
    storeShift?: StoreShiftCreateNestedOneWithoutCashShiftsInput
  }

  export type CashShiftUncheckedCreateWithoutKasirInput = {
    id?: string
    tenantId: string
    storeShiftId?: string | null
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftCreateOrConnectWithoutKasirInput = {
    where: CashShiftWhereUniqueInput
    create: XOR<CashShiftCreateWithoutKasirInput, CashShiftUncheckedCreateWithoutKasirInput>
  }

  export type CashShiftCreateManyKasirInputEnvelope = {
    data: CashShiftCreateManyKasirInput | CashShiftCreateManyKasirInput[]
    skipDuplicates?: boolean
  }

  export type ProductAdjustmentCreateWithoutUserInput = {
    id?: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductAdjustmentsInput
    product: ProductCreateNestedOneWithoutAdjustmentsInput
    storeShift?: StoreShiftCreateNestedOneWithoutProductAdjustmentsInput
  }

  export type ProductAdjustmentUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    productId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type ProductAdjustmentCreateOrConnectWithoutUserInput = {
    where: ProductAdjustmentWhereUniqueInput
    create: XOR<ProductAdjustmentCreateWithoutUserInput, ProductAdjustmentUncheckedCreateWithoutUserInput>
  }

  export type ProductAdjustmentCreateManyUserInputEnvelope = {
    data: ProductAdjustmentCreateManyUserInput | ProductAdjustmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoreShiftCreateWithoutOpenerInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutOpenerInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutOpenerInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutOpenerInput, StoreShiftUncheckedCreateWithoutOpenerInput>
  }

  export type StoreShiftCreateManyOpenerInputEnvelope = {
    data: StoreShiftCreateManyOpenerInput | StoreShiftCreateManyOpenerInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTokenCreateWithoutUserInput = {
    id?: string
    token: string
    platform: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    platform: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenCreateOrConnectWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenCreateManyUserInputEnvelope = {
    data: DeviceTokenCreateManyUserInput | DeviceTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type CashShiftUpsertWithWhereUniqueWithoutKasirInput = {
    where: CashShiftWhereUniqueInput
    update: XOR<CashShiftUpdateWithoutKasirInput, CashShiftUncheckedUpdateWithoutKasirInput>
    create: XOR<CashShiftCreateWithoutKasirInput, CashShiftUncheckedCreateWithoutKasirInput>
  }

  export type CashShiftUpdateWithWhereUniqueWithoutKasirInput = {
    where: CashShiftWhereUniqueInput
    data: XOR<CashShiftUpdateWithoutKasirInput, CashShiftUncheckedUpdateWithoutKasirInput>
  }

  export type CashShiftUpdateManyWithWhereWithoutKasirInput = {
    where: CashShiftScalarWhereInput
    data: XOR<CashShiftUpdateManyMutationInput, CashShiftUncheckedUpdateManyWithoutKasirInput>
  }

  export type ProductAdjustmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductAdjustmentWhereUniqueInput
    update: XOR<ProductAdjustmentUpdateWithoutUserInput, ProductAdjustmentUncheckedUpdateWithoutUserInput>
    create: XOR<ProductAdjustmentCreateWithoutUserInput, ProductAdjustmentUncheckedCreateWithoutUserInput>
  }

  export type ProductAdjustmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductAdjustmentWhereUniqueInput
    data: XOR<ProductAdjustmentUpdateWithoutUserInput, ProductAdjustmentUncheckedUpdateWithoutUserInput>
  }

  export type ProductAdjustmentUpdateManyWithWhereWithoutUserInput = {
    where: ProductAdjustmentScalarWhereInput
    data: XOR<ProductAdjustmentUpdateManyMutationInput, ProductAdjustmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type StoreShiftUpsertWithWhereUniqueWithoutOpenerInput = {
    where: StoreShiftWhereUniqueInput
    update: XOR<StoreShiftUpdateWithoutOpenerInput, StoreShiftUncheckedUpdateWithoutOpenerInput>
    create: XOR<StoreShiftCreateWithoutOpenerInput, StoreShiftUncheckedCreateWithoutOpenerInput>
  }

  export type StoreShiftUpdateWithWhereUniqueWithoutOpenerInput = {
    where: StoreShiftWhereUniqueInput
    data: XOR<StoreShiftUpdateWithoutOpenerInput, StoreShiftUncheckedUpdateWithoutOpenerInput>
  }

  export type StoreShiftUpdateManyWithWhereWithoutOpenerInput = {
    where: StoreShiftScalarWhereInput
    data: XOR<StoreShiftUpdateManyMutationInput, StoreShiftUncheckedUpdateManyWithoutOpenerInput>
  }

  export type DeviceTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    update: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    data: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
  }

  export type DeviceTokenUpdateManyWithWhereWithoutUserInput = {
    where: DeviceTokenScalarWhereInput
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceTokenScalarWhereInput = {
    AND?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    OR?: DeviceTokenScalarWhereInput[]
    NOT?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    isActive?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProductsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductAdjustmentCreateWithoutProductInput = {
    id?: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductAdjustmentsInput
    user: UserCreateNestedOneWithoutProductAdjustmentsInput
    storeShift?: StoreShiftCreateNestedOneWithoutProductAdjustmentsInput
  }

  export type ProductAdjustmentUncheckedCreateWithoutProductInput = {
    id?: string
    tenantId: string
    userId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type ProductAdjustmentCreateOrConnectWithoutProductInput = {
    where: ProductAdjustmentWhereUniqueInput
    create: XOR<ProductAdjustmentCreateWithoutProductInput, ProductAdjustmentUncheckedCreateWithoutProductInput>
  }

  export type ProductAdjustmentCreateManyProductInputEnvelope = {
    data: ProductAdjustmentCreateManyProductInput | ProductAdjustmentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseOrderId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemCreateManyProductInputEnvelope = {
    data: PurchaseOrderItemCreateManyProductInput | PurchaseOrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockTransferItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockTransfer: StockTransferCreateNestedOneWithoutItemsInput
  }

  export type StockTransferItemUncheckedCreateWithoutProductInput = {
    id?: string
    stockTransferId: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferItemCreateOrConnectWithoutProductInput = {
    where: StockTransferItemWhereUniqueInput
    create: XOR<StockTransferItemCreateWithoutProductInput, StockTransferItemUncheckedCreateWithoutProductInput>
  }

  export type StockTransferItemCreateManyProductInputEnvelope = {
    data: StockTransferItemCreateManyProductInput | StockTransferItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockValuationCreateWithoutProductInput = {
    id?: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockValuationsInput
  }

  export type StockValuationUncheckedCreateWithoutProductInput = {
    id?: string
    tenantId: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockValuationCreateOrConnectWithoutProductInput = {
    where: StockValuationWhereUniqueInput
    create: XOR<StockValuationCreateWithoutProductInput, StockValuationUncheckedCreateWithoutProductInput>
  }

  export type StockValuationCreateManyProductInputEnvelope = {
    data: StockValuationCreateManyProductInput | StockValuationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutProductsInput = {
    update: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProductsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type TenantUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type ProductAdjustmentUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductAdjustmentWhereUniqueInput
    update: XOR<ProductAdjustmentUpdateWithoutProductInput, ProductAdjustmentUncheckedUpdateWithoutProductInput>
    create: XOR<ProductAdjustmentCreateWithoutProductInput, ProductAdjustmentUncheckedCreateWithoutProductInput>
  }

  export type ProductAdjustmentUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductAdjustmentWhereUniqueInput
    data: XOR<ProductAdjustmentUpdateWithoutProductInput, ProductAdjustmentUncheckedUpdateWithoutProductInput>
  }

  export type ProductAdjustmentUpdateManyWithWhereWithoutProductInput = {
    where: ProductAdjustmentScalarWhereInput
    data: XOR<ProductAdjustmentUpdateManyMutationInput, ProductAdjustmentUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
  }

  export type StockTransferItemUpsertWithWhereUniqueWithoutProductInput = {
    where: StockTransferItemWhereUniqueInput
    update: XOR<StockTransferItemUpdateWithoutProductInput, StockTransferItemUncheckedUpdateWithoutProductInput>
    create: XOR<StockTransferItemCreateWithoutProductInput, StockTransferItemUncheckedCreateWithoutProductInput>
  }

  export type StockTransferItemUpdateWithWhereUniqueWithoutProductInput = {
    where: StockTransferItemWhereUniqueInput
    data: XOR<StockTransferItemUpdateWithoutProductInput, StockTransferItemUncheckedUpdateWithoutProductInput>
  }

  export type StockTransferItemUpdateManyWithWhereWithoutProductInput = {
    where: StockTransferItemScalarWhereInput
    data: XOR<StockTransferItemUpdateManyMutationInput, StockTransferItemUncheckedUpdateManyWithoutProductInput>
  }

  export type StockTransferItemScalarWhereInput = {
    AND?: StockTransferItemScalarWhereInput | StockTransferItemScalarWhereInput[]
    OR?: StockTransferItemScalarWhereInput[]
    NOT?: StockTransferItemScalarWhereInput | StockTransferItemScalarWhereInput[]
    id?: StringFilter<"StockTransferItem"> | string
    stockTransferId?: StringFilter<"StockTransferItem"> | string
    productId?: StringFilter<"StockTransferItem"> | string
    quantity?: IntFilter<"StockTransferItem"> | number
    receivedQuantity?: IntFilter<"StockTransferItem"> | number
    notes?: StringNullableFilter<"StockTransferItem"> | string | null
    createdAt?: DateTimeFilter<"StockTransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransferItem"> | Date | string
  }

  export type StockValuationUpsertWithWhereUniqueWithoutProductInput = {
    where: StockValuationWhereUniqueInput
    update: XOR<StockValuationUpdateWithoutProductInput, StockValuationUncheckedUpdateWithoutProductInput>
    create: XOR<StockValuationCreateWithoutProductInput, StockValuationUncheckedCreateWithoutProductInput>
  }

  export type StockValuationUpdateWithWhereUniqueWithoutProductInput = {
    where: StockValuationWhereUniqueInput
    data: XOR<StockValuationUpdateWithoutProductInput, StockValuationUncheckedUpdateWithoutProductInput>
  }

  export type StockValuationUpdateManyWithWhereWithoutProductInput = {
    where: StockValuationScalarWhereInput
    data: XOR<StockValuationUpdateManyMutationInput, StockValuationUncheckedUpdateManyWithoutProductInput>
  }

  export type TenantCreateWithoutProductAdjustmentsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProductAdjustmentsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProductAdjustmentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProductAdjustmentsInput, TenantUncheckedCreateWithoutProductAdjustmentsInput>
  }

  export type ProductCreateWithoutAdjustmentsInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdjustmentsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemUncheckedCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdjustmentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
  }

  export type UserCreateWithoutProductAdjustmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductAdjustmentsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductAdjustmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductAdjustmentsInput, UserUncheckedCreateWithoutProductAdjustmentsInput>
  }

  export type StoreShiftCreateWithoutProductAdjustmentsInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutProductAdjustmentsInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutProductAdjustmentsInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutProductAdjustmentsInput, StoreShiftUncheckedCreateWithoutProductAdjustmentsInput>
  }

  export type TenantUpsertWithoutProductAdjustmentsInput = {
    update: XOR<TenantUpdateWithoutProductAdjustmentsInput, TenantUncheckedUpdateWithoutProductAdjustmentsInput>
    create: XOR<TenantCreateWithoutProductAdjustmentsInput, TenantUncheckedCreateWithoutProductAdjustmentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProductAdjustmentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProductAdjustmentsInput, TenantUncheckedUpdateWithoutProductAdjustmentsInput>
  }

  export type TenantUpdateWithoutProductAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProductAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProductUpsertWithoutAdjustmentsInput = {
    update: XOR<ProductUpdateWithoutAdjustmentsInput, ProductUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<ProductCreateWithoutAdjustmentsInput, ProductUncheckedCreateWithoutAdjustmentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdjustmentsInput, ProductUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type ProductUpdateWithoutAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUncheckedUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductAdjustmentsInput = {
    update: XOR<UserUpdateWithoutProductAdjustmentsInput, UserUncheckedUpdateWithoutProductAdjustmentsInput>
    create: XOR<UserCreateWithoutProductAdjustmentsInput, UserUncheckedCreateWithoutProductAdjustmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductAdjustmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductAdjustmentsInput, UserUncheckedUpdateWithoutProductAdjustmentsInput>
  }

  export type UserUpdateWithoutProductAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoreShiftUpsertWithoutProductAdjustmentsInput = {
    update: XOR<StoreShiftUpdateWithoutProductAdjustmentsInput, StoreShiftUncheckedUpdateWithoutProductAdjustmentsInput>
    create: XOR<StoreShiftCreateWithoutProductAdjustmentsInput, StoreShiftUncheckedCreateWithoutProductAdjustmentsInput>
    where?: StoreShiftWhereInput
  }

  export type StoreShiftUpdateToOneWithWhereWithoutProductAdjustmentsInput = {
    where?: StoreShiftWhereInput
    data: XOR<StoreShiftUpdateWithoutProductAdjustmentsInput, StoreShiftUncheckedUpdateWithoutProductAdjustmentsInput>
  }

  export type StoreShiftUpdateWithoutProductAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutProductAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type TenantCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type MemberCreateWithoutOrdersInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateOrConnectWithoutOrdersInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOrdersInput, MemberUncheckedCreateWithoutOrdersInput>
  }

  export type OutletCreateWithoutOrdersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOutletsInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutOrdersInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
  }

  export type StoreShiftCreateWithoutOrdersInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutOrdersInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutOrdersInput, StoreShiftUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutOrderInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    tenantId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
  }

  export type TenantUpsertWithoutOrdersInput = {
    update: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type TenantUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpsertWithoutOrdersInput = {
    update: XOR<MemberUpdateWithoutOrdersInput, MemberUncheckedUpdateWithoutOrdersInput>
    create: XOR<MemberCreateWithoutOrdersInput, MemberUncheckedCreateWithoutOrdersInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutOrdersInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutOrdersInput, MemberUncheckedUpdateWithoutOrdersInput>
  }

  export type MemberUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutletUpsertWithoutOrdersInput = {
    update: XOR<OutletUpdateWithoutOrdersInput, OutletUncheckedUpdateWithoutOrdersInput>
    create: XOR<OutletCreateWithoutOrdersInput, OutletUncheckedCreateWithoutOrdersInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutOrdersInput, OutletUncheckedUpdateWithoutOrdersInput>
  }

  export type OutletUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOutletsNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type StoreShiftUpsertWithoutOrdersInput = {
    update: XOR<StoreShiftUpdateWithoutOrdersInput, StoreShiftUncheckedUpdateWithoutOrdersInput>
    create: XOR<StoreShiftCreateWithoutOrdersInput, StoreShiftUncheckedCreateWithoutOrdersInput>
    where?: StoreShiftWhereInput
  }

  export type StoreShiftUpdateToOneWithWhereWithoutOrdersInput = {
    where?: StoreShiftWhereInput
    data: XOR<StoreShiftUpdateWithoutOrdersInput, StoreShiftUncheckedUpdateWithoutOrdersInput>
  }

  export type StoreShiftUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type TransactionUpsertWithoutOrderInput = {
    update: XOR<TransactionUpdateWithoutOrderInput, TransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutOrderInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutOrderInput, TransactionUncheckedUpdateWithoutOrderInput>
  }

  export type TransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    adjustments?: ProductAdjustmentCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemUncheckedCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    adjustments?: ProductAdjustmentUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustments?: ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUncheckedUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutPaymentMappingsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentMappingsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentMappingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentMappingsInput, TenantUncheckedCreateWithoutPaymentMappingsInput>
  }

  export type TenantUpsertWithoutPaymentMappingsInput = {
    update: XOR<TenantUpdateWithoutPaymentMappingsInput, TenantUncheckedUpdateWithoutPaymentMappingsInput>
    create: XOR<TenantCreateWithoutPaymentMappingsInput, TenantUncheckedCreateWithoutPaymentMappingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentMappingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentMappingsInput, TenantUncheckedUpdateWithoutPaymentMappingsInput>
  }

  export type TenantUpdateWithoutPaymentMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
  }

  export type OrderCreateWithoutTransactionInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTransactionInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTransactionInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTransactionInput, OrderUncheckedCreateWithoutTransactionInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type TenantUpsertWithoutTransactionsInput = {
    update: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithoutTransactionInput = {
    update: XOR<OrderUpdateWithoutTransactionInput, OrderUncheckedUpdateWithoutTransactionInput>
    create: XOR<OrderCreateWithoutTransactionInput, OrderUncheckedCreateWithoutTransactionInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutTransactionInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutTransactionInput, OrderUncheckedUpdateWithoutTransactionInput>
  }

  export type OrderUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCustomersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCustomersInput = {
    update: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type TenantUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TenantCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMembersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMembersInput, TenantUncheckedCreateWithoutMembersInput>
  }

  export type OrderCreateWithoutMemberInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutMemberInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutMemberInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutMemberInput, OrderUncheckedCreateWithoutMemberInput>
  }

  export type OrderCreateManyMemberInputEnvelope = {
    data: OrderCreateManyMemberInput | OrderCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutMembersInput = {
    update: XOR<TenantUpdateWithoutMembersInput, TenantUncheckedUpdateWithoutMembersInput>
    create: XOR<TenantCreateWithoutMembersInput, TenantUncheckedCreateWithoutMembersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMembersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMembersInput, TenantUncheckedUpdateWithoutMembersInput>
  }

  export type TenantUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutMemberInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutMemberInput, OrderUncheckedUpdateWithoutMemberInput>
    create: XOR<OrderCreateWithoutMemberInput, OrderUncheckedCreateWithoutMemberInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutMemberInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutMemberInput, OrderUncheckedUpdateWithoutMemberInput>
  }

  export type OrderUpdateManyWithWhereWithoutMemberInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutMemberInput>
  }

  export type TenantCreateWithoutEmployeesInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmployeesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
  }

  export type TenantUpsertWithoutEmployeesInput = {
    update: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type TenantUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutOutletsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOutletsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOutletsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOutletsInput, TenantUncheckedCreateWithoutOutletsInput>
  }

  export type OrderCreateWithoutOutletInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    storeShift?: StoreShiftCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOutletInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOutletInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOutletInput, OrderUncheckedCreateWithoutOutletInput>
  }

  export type OrderCreateManyOutletInputEnvelope = {
    data: OrderCreateManyOutletInput | OrderCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type StoreShiftCreateWithoutOutletInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutOutletInput = {
    id?: string
    tenantId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutOutletInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutOutletInput, StoreShiftUncheckedCreateWithoutOutletInput>
  }

  export type StoreShiftCreateManyOutletInputEnvelope = {
    data: StoreShiftCreateManyOutletInput | StoreShiftCreateManyOutletInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutOutletsInput = {
    update: XOR<TenantUpdateWithoutOutletsInput, TenantUncheckedUpdateWithoutOutletsInput>
    create: XOR<TenantCreateWithoutOutletsInput, TenantUncheckedCreateWithoutOutletsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOutletsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOutletsInput, TenantUncheckedUpdateWithoutOutletsInput>
  }

  export type TenantUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOutletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutOutletInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOutletInput, OrderUncheckedUpdateWithoutOutletInput>
    create: XOR<OrderCreateWithoutOutletInput, OrderUncheckedCreateWithoutOutletInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOutletInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOutletInput, OrderUncheckedUpdateWithoutOutletInput>
  }

  export type OrderUpdateManyWithWhereWithoutOutletInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOutletInput>
  }

  export type StoreShiftUpsertWithWhereUniqueWithoutOutletInput = {
    where: StoreShiftWhereUniqueInput
    update: XOR<StoreShiftUpdateWithoutOutletInput, StoreShiftUncheckedUpdateWithoutOutletInput>
    create: XOR<StoreShiftCreateWithoutOutletInput, StoreShiftUncheckedCreateWithoutOutletInput>
  }

  export type StoreShiftUpdateWithWhereUniqueWithoutOutletInput = {
    where: StoreShiftWhereUniqueInput
    data: XOR<StoreShiftUpdateWithoutOutletInput, StoreShiftUncheckedUpdateWithoutOutletInput>
  }

  export type StoreShiftUpdateManyWithWhereWithoutOutletInput = {
    where: StoreShiftScalarWhereInput
    data: XOR<StoreShiftUpdateManyMutationInput, StoreShiftUncheckedUpdateManyWithoutOutletInput>
  }

  export type TenantCreateWithoutReportsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutReportsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutReportsInput, TenantUncheckedCreateWithoutReportsInput>
  }

  export type TenantUpsertWithoutReportsInput = {
    update: XOR<TenantUpdateWithoutReportsInput, TenantUncheckedUpdateWithoutReportsInput>
    create: XOR<TenantCreateWithoutReportsInput, TenantUncheckedCreateWithoutReportsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutReportsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutReportsInput, TenantUncheckedUpdateWithoutReportsInput>
  }

  export type TenantUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAddonsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAddonsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAddonsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAddonsInput, TenantUncheckedCreateWithoutAddonsInput>
  }

  export type TenantUpsertWithoutAddonsInput = {
    update: XOR<TenantUpdateWithoutAddonsInput, TenantUncheckedUpdateWithoutAddonsInput>
    create: XOR<TenantCreateWithoutAddonsInput, TenantUncheckedCreateWithoutAddonsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAddonsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAddonsInput, TenantUncheckedUpdateWithoutAddonsInput>
  }

  export type TenantUpdateWithoutAddonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAddonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSubscriptionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSubscriptionsInput, TenantUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionHistoryCreateWithoutSubscriptionInput = {
    id?: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSubscriptionHistoryInput
  }

  export type SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    tenantId: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionHistoryWhereUniqueInput
    create: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionHistoryCreateManySubscriptionInputEnvelope = {
    data: SubscriptionHistoryCreateManySubscriptionInput | SubscriptionHistoryCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSubscriptionsInput = {
    update: XOR<TenantUpdateWithoutSubscriptionsInput, TenantUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<TenantCreateWithoutSubscriptionsInput, TenantUncheckedCreateWithoutSubscriptionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSubscriptionsInput, TenantUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type TenantUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SubscriptionHistoryUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionHistoryWhereUniqueInput
    update: XOR<SubscriptionHistoryUpdateWithoutSubscriptionInput, SubscriptionHistoryUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionHistoryCreateWithoutSubscriptionInput, SubscriptionHistoryUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionHistoryUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionHistoryWhereUniqueInput
    data: XOR<SubscriptionHistoryUpdateWithoutSubscriptionInput, SubscriptionHistoryUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionHistoryUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SubscriptionHistoryScalarWhereInput
    data: XOR<SubscriptionHistoryUpdateManyMutationInput, SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type TenantCreateWithoutSubscriptionHistoryInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSubscriptionHistoryInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSubscriptionHistoryInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSubscriptionHistoryInput, TenantUncheckedCreateWithoutSubscriptionHistoryInput>
  }

  export type SubscriptionCreateWithoutHistoryInput = {
    id?: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutHistoryInput = {
    id?: string
    tenantId: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutHistoryInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
  }

  export type TenantUpsertWithoutSubscriptionHistoryInput = {
    update: XOR<TenantUpdateWithoutSubscriptionHistoryInput, TenantUncheckedUpdateWithoutSubscriptionHistoryInput>
    create: XOR<TenantCreateWithoutSubscriptionHistoryInput, TenantUncheckedCreateWithoutSubscriptionHistoryInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSubscriptionHistoryInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSubscriptionHistoryInput, TenantUncheckedUpdateWithoutSubscriptionHistoryInput>
  }

  export type TenantUpdateWithoutSubscriptionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSubscriptionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SubscriptionUpsertWithoutHistoryInput = {
    update: XOR<SubscriptionUpdateWithoutHistoryInput, SubscriptionUncheckedUpdateWithoutHistoryInput>
    create: XOR<SubscriptionCreateWithoutHistoryInput, SubscriptionUncheckedCreateWithoutHistoryInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutHistoryInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutHistoryInput, SubscriptionUncheckedUpdateWithoutHistoryInput>
  }

  export type SubscriptionUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutReceiptTemplatesInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutReceiptTemplatesInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutReceiptTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutReceiptTemplatesInput, TenantUncheckedCreateWithoutReceiptTemplatesInput>
  }

  export type TenantUpsertWithoutReceiptTemplatesInput = {
    update: XOR<TenantUpdateWithoutReceiptTemplatesInput, TenantUncheckedUpdateWithoutReceiptTemplatesInput>
    create: XOR<TenantCreateWithoutReceiptTemplatesInput, TenantUncheckedCreateWithoutReceiptTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutReceiptTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutReceiptTemplatesInput, TenantUncheckedUpdateWithoutReceiptTemplatesInput>
  }

  export type TenantUpdateWithoutReceiptTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutReceiptTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutDiscountsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDiscountsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDiscountsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDiscountsInput, TenantUncheckedCreateWithoutDiscountsInput>
  }

  export type TenantUpsertWithoutDiscountsInput = {
    update: XOR<TenantUpdateWithoutDiscountsInput, TenantUncheckedUpdateWithoutDiscountsInput>
    create: XOR<TenantCreateWithoutDiscountsInput, TenantUncheckedCreateWithoutDiscountsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDiscountsInput, TenantUncheckedUpdateWithoutDiscountsInput>
  }

  export type TenantUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutWebhooksInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWebhooksInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWebhooksInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWebhooksInput, TenantUncheckedCreateWithoutWebhooksInput>
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    responseCode?: number | null
    responseBody?: string | null
    attempts?: number
    nextRetryAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    responseCode?: number | null
    responseBody?: string | null
    attempts?: number
    nextRetryAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutWebhooksInput = {
    update: XOR<TenantUpdateWithoutWebhooksInput, TenantUncheckedUpdateWithoutWebhooksInput>
    create: XOR<TenantCreateWithoutWebhooksInput, TenantUncheckedCreateWithoutWebhooksInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWebhooksInput, TenantUncheckedUpdateWithoutWebhooksInput>
  }

  export type TenantUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    status?: StringFilter<"WebhookDelivery"> | string
    responseCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    attempts?: IntFilter<"WebhookDelivery"> | number
    nextRetryAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
  }

  export type WebhookCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    tenantId: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutSuppliersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSuppliersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSuppliersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSuppliersInput = {
    update: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type TenantUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type TenantCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPurchaseOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    tenantId: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPurchaseOrdersInput = {
    update: XOR<TenantUpdateWithoutPurchaseOrdersInput, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPurchaseOrdersInput, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type TenantUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    supplierId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemUncheckedCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ProductUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUncheckedUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutStockTransfersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStockTransfersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStockTransfersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStockTransfersInput, TenantUncheckedCreateWithoutStockTransfersInput>
  }

  export type StoreShiftCreateWithoutStockTransfersInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutStockTransfersInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutStockTransfersInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutStockTransfersInput, StoreShiftUncheckedCreateWithoutStockTransfersInput>
  }

  export type StockTransferItemCreateWithoutStockTransferInput = {
    id?: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockTransferItemsInput
  }

  export type StockTransferItemUncheckedCreateWithoutStockTransferInput = {
    id?: string
    productId: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferItemCreateOrConnectWithoutStockTransferInput = {
    where: StockTransferItemWhereUniqueInput
    create: XOR<StockTransferItemCreateWithoutStockTransferInput, StockTransferItemUncheckedCreateWithoutStockTransferInput>
  }

  export type StockTransferItemCreateManyStockTransferInputEnvelope = {
    data: StockTransferItemCreateManyStockTransferInput | StockTransferItemCreateManyStockTransferInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutStockTransfersInput = {
    update: XOR<TenantUpdateWithoutStockTransfersInput, TenantUncheckedUpdateWithoutStockTransfersInput>
    create: XOR<TenantCreateWithoutStockTransfersInput, TenantUncheckedCreateWithoutStockTransfersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStockTransfersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStockTransfersInput, TenantUncheckedUpdateWithoutStockTransfersInput>
  }

  export type TenantUpdateWithoutStockTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStockTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StoreShiftUpsertWithoutStockTransfersInput = {
    update: XOR<StoreShiftUpdateWithoutStockTransfersInput, StoreShiftUncheckedUpdateWithoutStockTransfersInput>
    create: XOR<StoreShiftCreateWithoutStockTransfersInput, StoreShiftUncheckedCreateWithoutStockTransfersInput>
    where?: StoreShiftWhereInput
  }

  export type StoreShiftUpdateToOneWithWhereWithoutStockTransfersInput = {
    where?: StoreShiftWhereInput
    data: XOR<StoreShiftUpdateWithoutStockTransfersInput, StoreShiftUncheckedUpdateWithoutStockTransfersInput>
  }

  export type StoreShiftUpdateWithoutStockTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutStockTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type StockTransferItemUpsertWithWhereUniqueWithoutStockTransferInput = {
    where: StockTransferItemWhereUniqueInput
    update: XOR<StockTransferItemUpdateWithoutStockTransferInput, StockTransferItemUncheckedUpdateWithoutStockTransferInput>
    create: XOR<StockTransferItemCreateWithoutStockTransferInput, StockTransferItemUncheckedCreateWithoutStockTransferInput>
  }

  export type StockTransferItemUpdateWithWhereUniqueWithoutStockTransferInput = {
    where: StockTransferItemWhereUniqueInput
    data: XOR<StockTransferItemUpdateWithoutStockTransferInput, StockTransferItemUncheckedUpdateWithoutStockTransferInput>
  }

  export type StockTransferItemUpdateManyWithWhereWithoutStockTransferInput = {
    where: StockTransferItemScalarWhereInput
    data: XOR<StockTransferItemUpdateManyMutationInput, StockTransferItemUncheckedUpdateManyWithoutStockTransferInput>
  }

  export type StockTransferCreateWithoutItemsInput = {
    id?: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockTransfersInput
    storeShift?: StoreShiftCreateNestedOneWithoutStockTransfersInput
  }

  export type StockTransferUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    storeShiftId?: string | null
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferCreateOrConnectWithoutItemsInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutItemsInput, StockTransferUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutStockTransferItemsInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockTransferItemsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockTransferItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockTransferItemsInput, ProductUncheckedCreateWithoutStockTransferItemsInput>
  }

  export type StockTransferUpsertWithoutItemsInput = {
    update: XOR<StockTransferUpdateWithoutItemsInput, StockTransferUncheckedUpdateWithoutItemsInput>
    create: XOR<StockTransferCreateWithoutItemsInput, StockTransferUncheckedCreateWithoutItemsInput>
    where?: StockTransferWhereInput
  }

  export type StockTransferUpdateToOneWithWhereWithoutItemsInput = {
    where?: StockTransferWhereInput
    data: XOR<StockTransferUpdateWithoutItemsInput, StockTransferUncheckedUpdateWithoutItemsInput>
  }

  export type StockTransferUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockTransfersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutStockTransfersNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutStockTransferItemsInput = {
    update: XOR<ProductUpdateWithoutStockTransferItemsInput, ProductUncheckedUpdateWithoutStockTransferItemsInput>
    create: XOR<ProductCreateWithoutStockTransferItemsInput, ProductUncheckedCreateWithoutStockTransferItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockTransferItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockTransferItemsInput, ProductUncheckedUpdateWithoutStockTransferItemsInput>
  }

  export type ProductUpdateWithoutStockTransferItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockTransferItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutStockValuationsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStockValuationsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStockValuationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStockValuationsInput, TenantUncheckedCreateWithoutStockValuationsInput>
  }

  export type ProductCreateWithoutStockValuationsInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockValuationsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    adjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    stockTransferItems?: StockTransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockValuationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockValuationsInput, ProductUncheckedCreateWithoutStockValuationsInput>
  }

  export type TenantUpsertWithoutStockValuationsInput = {
    update: XOR<TenantUpdateWithoutStockValuationsInput, TenantUncheckedUpdateWithoutStockValuationsInput>
    create: XOR<TenantCreateWithoutStockValuationsInput, TenantUncheckedCreateWithoutStockValuationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStockValuationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStockValuationsInput, TenantUncheckedUpdateWithoutStockValuationsInput>
  }

  export type TenantUpdateWithoutStockValuationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStockValuationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProductUpsertWithoutStockValuationsInput = {
    update: XOR<ProductUpdateWithoutStockValuationsInput, ProductUncheckedUpdateWithoutStockValuationsInput>
    create: XOR<ProductCreateWithoutStockValuationsInput, ProductUncheckedCreateWithoutStockValuationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockValuationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockValuationsInput, ProductUncheckedUpdateWithoutStockValuationsInput>
  }

  export type ProductUpdateWithoutStockValuationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockValuationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutBackupLogsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBackupLogsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBackupLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBackupLogsInput, TenantUncheckedCreateWithoutBackupLogsInput>
  }

  export type TenantUpsertWithoutBackupLogsInput = {
    update: XOR<TenantUpdateWithoutBackupLogsInput, TenantUncheckedUpdateWithoutBackupLogsInput>
    create: XOR<TenantCreateWithoutBackupLogsInput, TenantUncheckedCreateWithoutBackupLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBackupLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBackupLogsInput, TenantUncheckedUpdateWithoutBackupLogsInput>
  }

  export type TenantUpdateWithoutBackupLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBackupLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutStoreShiftsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStoreShiftsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStoreShiftsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStoreShiftsInput, TenantUncheckedCreateWithoutStoreShiftsInput>
  }

  export type OutletCreateWithoutStoreShiftsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOutletsInput
    orders?: OrderCreateNestedManyWithoutOutletInput
  }

  export type OutletUncheckedCreateWithoutStoreShiftsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOutletInput
  }

  export type OutletCreateOrConnectWithoutStoreShiftsInput = {
    where: OutletWhereUniqueInput
    create: XOR<OutletCreateWithoutStoreShiftsInput, OutletUncheckedCreateWithoutStoreShiftsInput>
  }

  export type UserCreateWithoutStoreShiftsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoreShiftsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoreShiftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreShiftsInput, UserUncheckedCreateWithoutStoreShiftsInput>
  }

  export type OrderCreateWithoutStoreShiftInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOrdersInput
    user: UserCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    member?: MemberCreateNestedOneWithoutOrdersInput
    outlet?: OutletCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    transaction?: TransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStoreShiftInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transaction?: TransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStoreShiftInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStoreShiftInput, OrderUncheckedCreateWithoutStoreShiftInput>
  }

  export type OrderCreateManyStoreShiftInputEnvelope = {
    data: OrderCreateManyStoreShiftInput | OrderCreateManyStoreShiftInput[]
    skipDuplicates?: boolean
  }

  export type CashShiftCreateWithoutStoreShiftInput = {
    id?: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashShiftsInput
    kasir: UserCreateNestedOneWithoutCashShiftsInput
  }

  export type CashShiftUncheckedCreateWithoutStoreShiftInput = {
    id?: string
    tenantId: string
    kasirId: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftCreateOrConnectWithoutStoreShiftInput = {
    where: CashShiftWhereUniqueInput
    create: XOR<CashShiftCreateWithoutStoreShiftInput, CashShiftUncheckedCreateWithoutStoreShiftInput>
  }

  export type CashShiftCreateManyStoreShiftInputEnvelope = {
    data: CashShiftCreateManyStoreShiftInput | CashShiftCreateManyStoreShiftInput[]
    skipDuplicates?: boolean
  }

  export type ProductAdjustmentCreateWithoutStoreShiftInput = {
    id?: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductAdjustmentsInput
    product: ProductCreateNestedOneWithoutAdjustmentsInput
    user: UserCreateNestedOneWithoutProductAdjustmentsInput
  }

  export type ProductAdjustmentUncheckedCreateWithoutStoreShiftInput = {
    id?: string
    tenantId: string
    productId: string
    userId: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type ProductAdjustmentCreateOrConnectWithoutStoreShiftInput = {
    where: ProductAdjustmentWhereUniqueInput
    create: XOR<ProductAdjustmentCreateWithoutStoreShiftInput, ProductAdjustmentUncheckedCreateWithoutStoreShiftInput>
  }

  export type ProductAdjustmentCreateManyStoreShiftInputEnvelope = {
    data: ProductAdjustmentCreateManyStoreShiftInput | ProductAdjustmentCreateManyStoreShiftInput[]
    skipDuplicates?: boolean
  }

  export type StockTransferCreateWithoutStoreShiftInput = {
    id?: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockTransfersInput
    items?: StockTransferItemCreateNestedManyWithoutStockTransferInput
  }

  export type StockTransferUncheckedCreateWithoutStoreShiftInput = {
    id?: string
    tenantId: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StockTransferItemUncheckedCreateNestedManyWithoutStockTransferInput
  }

  export type StockTransferCreateOrConnectWithoutStoreShiftInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutStoreShiftInput, StockTransferUncheckedCreateWithoutStoreShiftInput>
  }

  export type StockTransferCreateManyStoreShiftInputEnvelope = {
    data: StockTransferCreateManyStoreShiftInput | StockTransferCreateManyStoreShiftInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutStoreShiftsInput = {
    update: XOR<TenantUpdateWithoutStoreShiftsInput, TenantUncheckedUpdateWithoutStoreShiftsInput>
    create: XOR<TenantCreateWithoutStoreShiftsInput, TenantUncheckedCreateWithoutStoreShiftsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStoreShiftsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStoreShiftsInput, TenantUncheckedUpdateWithoutStoreShiftsInput>
  }

  export type TenantUpdateWithoutStoreShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStoreShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OutletUpsertWithoutStoreShiftsInput = {
    update: XOR<OutletUpdateWithoutStoreShiftsInput, OutletUncheckedUpdateWithoutStoreShiftsInput>
    create: XOR<OutletCreateWithoutStoreShiftsInput, OutletUncheckedCreateWithoutStoreShiftsInput>
    where?: OutletWhereInput
  }

  export type OutletUpdateToOneWithWhereWithoutStoreShiftsInput = {
    where?: OutletWhereInput
    data: XOR<OutletUpdateWithoutStoreShiftsInput, OutletUncheckedUpdateWithoutStoreShiftsInput>
  }

  export type OutletUpdateWithoutStoreShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOutletsNestedInput
    orders?: OrderUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutStoreShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type UserUpsertWithoutStoreShiftsInput = {
    update: XOR<UserUpdateWithoutStoreShiftsInput, UserUncheckedUpdateWithoutStoreShiftsInput>
    create: XOR<UserCreateWithoutStoreShiftsInput, UserUncheckedCreateWithoutStoreShiftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreShiftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreShiftsInput, UserUncheckedUpdateWithoutStoreShiftsInput>
  }

  export type UserUpdateWithoutStoreShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutStoreShiftInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStoreShiftInput, OrderUncheckedUpdateWithoutStoreShiftInput>
    create: XOR<OrderCreateWithoutStoreShiftInput, OrderUncheckedCreateWithoutStoreShiftInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStoreShiftInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStoreShiftInput, OrderUncheckedUpdateWithoutStoreShiftInput>
  }

  export type OrderUpdateManyWithWhereWithoutStoreShiftInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStoreShiftInput>
  }

  export type CashShiftUpsertWithWhereUniqueWithoutStoreShiftInput = {
    where: CashShiftWhereUniqueInput
    update: XOR<CashShiftUpdateWithoutStoreShiftInput, CashShiftUncheckedUpdateWithoutStoreShiftInput>
    create: XOR<CashShiftCreateWithoutStoreShiftInput, CashShiftUncheckedCreateWithoutStoreShiftInput>
  }

  export type CashShiftUpdateWithWhereUniqueWithoutStoreShiftInput = {
    where: CashShiftWhereUniqueInput
    data: XOR<CashShiftUpdateWithoutStoreShiftInput, CashShiftUncheckedUpdateWithoutStoreShiftInput>
  }

  export type CashShiftUpdateManyWithWhereWithoutStoreShiftInput = {
    where: CashShiftScalarWhereInput
    data: XOR<CashShiftUpdateManyMutationInput, CashShiftUncheckedUpdateManyWithoutStoreShiftInput>
  }

  export type ProductAdjustmentUpsertWithWhereUniqueWithoutStoreShiftInput = {
    where: ProductAdjustmentWhereUniqueInput
    update: XOR<ProductAdjustmentUpdateWithoutStoreShiftInput, ProductAdjustmentUncheckedUpdateWithoutStoreShiftInput>
    create: XOR<ProductAdjustmentCreateWithoutStoreShiftInput, ProductAdjustmentUncheckedCreateWithoutStoreShiftInput>
  }

  export type ProductAdjustmentUpdateWithWhereUniqueWithoutStoreShiftInput = {
    where: ProductAdjustmentWhereUniqueInput
    data: XOR<ProductAdjustmentUpdateWithoutStoreShiftInput, ProductAdjustmentUncheckedUpdateWithoutStoreShiftInput>
  }

  export type ProductAdjustmentUpdateManyWithWhereWithoutStoreShiftInput = {
    where: ProductAdjustmentScalarWhereInput
    data: XOR<ProductAdjustmentUpdateManyMutationInput, ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftInput>
  }

  export type StockTransferUpsertWithWhereUniqueWithoutStoreShiftInput = {
    where: StockTransferWhereUniqueInput
    update: XOR<StockTransferUpdateWithoutStoreShiftInput, StockTransferUncheckedUpdateWithoutStoreShiftInput>
    create: XOR<StockTransferCreateWithoutStoreShiftInput, StockTransferUncheckedCreateWithoutStoreShiftInput>
  }

  export type StockTransferUpdateWithWhereUniqueWithoutStoreShiftInput = {
    where: StockTransferWhereUniqueInput
    data: XOR<StockTransferUpdateWithoutStoreShiftInput, StockTransferUncheckedUpdateWithoutStoreShiftInput>
  }

  export type StockTransferUpdateManyWithWhereWithoutStoreShiftInput = {
    where: StockTransferScalarWhereInput
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyWithoutStoreShiftInput>
  }

  export type TenantCreateWithoutCashShiftsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashShiftsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashShiftsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashShiftsInput, TenantUncheckedCreateWithoutCashShiftsInput>
  }

  export type StoreShiftCreateWithoutCashShiftsInput = {
    id?: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStoreShiftsInput
    outlet: OutletCreateNestedOneWithoutStoreShiftsInput
    opener: UserCreateNestedOneWithoutStoreShiftsInput
    orders?: OrderCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftUncheckedCreateWithoutCashShiftsInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStoreShiftInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutStoreShiftInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutStoreShiftInput
  }

  export type StoreShiftCreateOrConnectWithoutCashShiftsInput = {
    where: StoreShiftWhereUniqueInput
    create: XOR<StoreShiftCreateWithoutCashShiftsInput, StoreShiftUncheckedCreateWithoutCashShiftsInput>
  }

  export type UserCreateWithoutCashShiftsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCashShiftsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCashShiftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashShiftsInput, UserUncheckedCreateWithoutCashShiftsInput>
  }

  export type TenantUpsertWithoutCashShiftsInput = {
    update: XOR<TenantUpdateWithoutCashShiftsInput, TenantUncheckedUpdateWithoutCashShiftsInput>
    create: XOR<TenantCreateWithoutCashShiftsInput, TenantUncheckedCreateWithoutCashShiftsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashShiftsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashShiftsInput, TenantUncheckedUpdateWithoutCashShiftsInput>
  }

  export type TenantUpdateWithoutCashShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StoreShiftUpsertWithoutCashShiftsInput = {
    update: XOR<StoreShiftUpdateWithoutCashShiftsInput, StoreShiftUncheckedUpdateWithoutCashShiftsInput>
    create: XOR<StoreShiftCreateWithoutCashShiftsInput, StoreShiftUncheckedCreateWithoutCashShiftsInput>
    where?: StoreShiftWhereInput
  }

  export type StoreShiftUpdateToOneWithWhereWithoutCashShiftsInput = {
    where?: StoreShiftWhereInput
    data: XOR<StoreShiftUpdateWithoutCashShiftsInput, StoreShiftUncheckedUpdateWithoutCashShiftsInput>
  }

  export type StoreShiftUpdateWithoutCashShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutCashShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type UserUpsertWithoutCashShiftsInput = {
    update: XOR<UserUpdateWithoutCashShiftsInput, UserUncheckedUpdateWithoutCashShiftsInput>
    create: XOR<UserCreateWithoutCashShiftsInput, UserUncheckedCreateWithoutCashShiftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashShiftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashShiftsInput, UserUncheckedUpdateWithoutCashShiftsInput>
  }

  export type UserUpdateWithoutCashShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCashShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeviceTokensInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeviceTokensInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeviceTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
  }

  export type UserUpsertWithoutDeviceTokensInput = {
    update: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutCourierConfigsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCourierConfigsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCourierConfigsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCourierConfigsInput, TenantUncheckedCreateWithoutCourierConfigsInput>
  }

  export type TenantUpsertWithoutCourierConfigsInput = {
    update: XOR<TenantUpdateWithoutCourierConfigsInput, TenantUncheckedUpdateWithoutCourierConfigsInput>
    create: XOR<TenantCreateWithoutCourierConfigsInput, TenantUncheckedCreateWithoutCourierConfigsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCourierConfigsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCourierConfigsInput, TenantUncheckedUpdateWithoutCourierConfigsInput>
  }

  export type TenantUpdateWithoutCourierConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCourierConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSupportTicketsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    members?: MemberCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    outlets?: OutletCreateNestedManyWithoutTenantInput
    reports?: ReportCreateNestedManyWithoutTenantInput
    addons?: TenantAddonCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateCreateNestedManyWithoutTenantInput
    discounts?: DiscountCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhooks?: WebhookCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    isActive?: boolean
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    subscriptionPlan?: string | null
    previousPlan?: string | null
    temporaryUpgrade?: boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: number
    tenantsLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    members?: MemberUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    outlets?: OutletUncheckedCreateNestedManyWithoutTenantInput
    reports?: ReportUncheckedCreateNestedManyWithoutTenantInput
    addons?: TenantAddonUncheckedCreateNestedManyWithoutTenantInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutTenantInput
    subscriptionHistory?: SubscriptionHistoryUncheckedCreateNestedManyWithoutTenantInput
    receiptTemplates?: ReceiptTemplateUncheckedCreateNestedManyWithoutTenantInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutTenantInput
    paymentMappings?: PaymentMappingUncheckedCreateNestedManyWithoutTenantInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    stockTransfers?: StockTransferUncheckedCreateNestedManyWithoutTenantInput
    stockValuations?: StockValuationUncheckedCreateNestedManyWithoutTenantInput
    backupLogs?: BackupLogUncheckedCreateNestedManyWithoutTenantInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutTenantInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutTenantInput
    courierConfigs?: CourierConfigUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSupportTicketsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
  }

  export type UserCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    tenantId: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    cashShifts?: CashShiftUncheckedCreateNestedManyWithoutKasirInput
    productAdjustments?: ProductAdjustmentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    storeShifts?: StoreShiftUncheckedCreateNestedManyWithoutOpenerInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type TenantUpsertWithoutSupportTicketsInput = {
    update: XOR<TenantUpdateWithoutSupportTicketsInput, TenantUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSupportTicketsInput, TenantUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type TenantUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    members?: MemberUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    outlets?: OutletUpdateManyWithoutTenantNestedInput
    reports?: ReportUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionPlan?: NullableStringFieldUpdateOperationsInput | string | null
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    features?: NullableJsonNullValueInput | InputJsonValue
    tenantsActive?: IntFieldUpdateOperationsInput | number
    tenantsLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    members?: MemberUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    outlets?: OutletUncheckedUpdateManyWithoutTenantNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTenantNestedInput
    addons?: TenantAddonUncheckedUpdateManyWithoutTenantNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    subscriptionHistory?: SubscriptionHistoryUncheckedUpdateManyWithoutTenantNestedInput
    receiptTemplates?: ReceiptTemplateUncheckedUpdateManyWithoutTenantNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutTenantNestedInput
    paymentMappings?: PaymentMappingUncheckedUpdateManyWithoutTenantNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutTenantNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutTenantNestedInput
    backupLogs?: BackupLogUncheckedUpdateManyWithoutTenantNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutTenantNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutTenantNestedInput
    courierConfigs?: CourierConfigUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    twoFactorBackupCodes?: string | null
    passwordHistory?: string | null
    passwordChangedAt?: Date | string | null
    mustChangePassword?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    sku?: string | null
    barcode?: string | null
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    minStock?: number
    category?: string | null
    image?: string | null
    emoji?: string | null
    isActive?: boolean
    isConsignment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyTenantInput = {
    id?: string
    idempotencyKey?: string | null
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyTenantInput = {
    id?: string
    orderId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthday?: Date | string | null
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberCreateManyTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone: string
    address?: string | null
    memberCode: string
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    loyaltyPoints?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyTenantInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    position: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutletCreateManyTenantInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    isActive?: boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyTenantInput = {
    id?: string
    type: string
    period: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TenantAddonCreateManyTenantInput = {
    id?: string
    addonId: string
    addonName: string
    addonType: string
    status?: string
    limit?: number | null
    currentUsage?: number
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: string
  }

  export type SubscriptionCreateManyTenantInput = {
    id?: string
    plan: string
    startDate: Date | string
    endDate: Date | string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: boolean
    previousPlan?: string | null
    purchasedBy?: string
    createdAt?: Date | string
  }

  export type SubscriptionHistoryCreateManyTenantInput = {
    id?: string
    subscriptionId?: string | null
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
  }

  export type ReceiptTemplateCreateManyTenantInput = {
    id?: string
    name: string
    templateType: string
    isDefault?: boolean
    paperSize?: string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountCreateManyTenantInput = {
    id?: string
    name: string
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    discountValueType: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    minQuantity?: number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: string | null
    applicableTo?: string
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMappingCreateManyTenantInput = {
    id?: string
    orderId: string
    itemId: string
    itemType: string
    itemName?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductAdjustmentCreateManyTenantInput = {
    id?: string
    productId: string
    userId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId?: string | null
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type WebhookCreateManyTenantInput = {
    id?: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    isActive?: boolean
    retryCount?: number
    timeout?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    contactPerson?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyTenantInput = {
    id?: string
    supplierId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferCreateManyTenantInput = {
    id?: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    storeShiftId?: string | null
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockValuationCreateManyTenantInput = {
    id?: string
    productId: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupLogCreateManyTenantInput = {
    id?: string
    status: string
    generatedAt?: Date | string
    emailSentAt?: Date | string | null
    size?: number | null
    filePath: string
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftCreateManyTenantInput = {
    id?: string
    storeShiftId?: string | null
    kasirId: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreShiftCreateManyTenantInput = {
    id?: string
    outletId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourierConfigCreateManyTenantInput = {
    id?: string
    courier: string
    apiKey: string
    apiSecret: string
    baseUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyTenantInput = {
    id?: string
    userId?: string | null
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutKasirNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOpenerNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistory?: NullableStringFieldUpdateOperationsInput | string | null
    passwordChangedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    adjustments?: ProductAdjustmentUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    stockTransferItems?: StockTransferItemUncheckedUpdateManyWithoutProductNestedInput
    stockValuations?: StockValuationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isConsignment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberCode?: StringFieldUpdateOperationsInput | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutletUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOutletNestedInput
    storeShifts?: StoreShiftUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOutletNestedInput
    storeShifts?: StoreShiftUncheckedUpdateManyWithoutOutletNestedInput
  }

  export type OutletUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    shiftConfig?: NullableJsonNullValueInput | InputJsonValue
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantAddonUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TenantAddonUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TenantAddonUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    addonName?: StringFieldUpdateOperationsInput | string
    addonType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    limit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    purchasedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: SubscriptionHistoryUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temporaryUpgrade?: BoolFieldUpdateOperationsInput | boolean
    previousPlan?: NullableStringFieldUpdateOperationsInput | string | null
    purchasedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneWithoutHistoryNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    templateType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    paperSize?: StringFieldUpdateOperationsInput | string
    header?: NullableJsonNullValueInput | InputJsonValue
    footer?: NullableJsonNullValueInput | InputJsonValue
    fields?: NullableJsonNullValueInput | InputJsonValue
    styles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountValueType?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    applicableProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleProducts?: NullableJsonNullValueInput | InputJsonValue
    bundleDiscountProduct?: NullableStringFieldUpdateOperationsInput | string | null
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMappingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMappingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMappingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutAdjustmentsNestedInput
    user?: UserUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    storeShift?: StoreShiftUpdateOneWithoutProductAdjustmentsNestedInput
  }

  export type ProductAdjustmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    timeout?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeShift?: StoreShiftUpdateOneWithoutStockTransfersNestedInput
    items?: StockTransferItemUpdateManyWithoutStockTransferNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockTransferItemUncheckedUpdateManyWithoutStockTransferNestedInput
  }

  export type StockTransferUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockValuationsNestedInput
  }

  export type StockValuationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    filePath?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeShift?: StoreShiftUpdateOneWithoutCashShiftsNestedInput
    kasir?: UserUpdateOneRequiredWithoutCashShiftsNestedInput
  }

  export type CashShiftUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    kasirId?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    kasirId?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreShiftUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierConfigUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierConfigUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourierConfigUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    apiSecret?: StringFieldUpdateOperationsInput | string
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    tenantId: string
    orderId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    status?: $Enums.TransactionStatus
    reference?: string | null
    qrCode?: string | null
    qrCodeImage?: string | null
    notes?: string | null
    servedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftCreateManyKasirInput = {
    id?: string
    tenantId: string
    storeShiftId?: string | null
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductAdjustmentCreateManyUserInput = {
    id?: string
    tenantId: string
    productId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    userEmail?: string | null
    userName?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    status?: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type StoreShiftCreateManyOpenerInput = {
    id?: string
    tenantId: string
    outletId: string
    shiftType: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenCreateManyUserInput = {
    id?: string
    token: string
    platform: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    name: string
    email: string
    subject: string
    message: string
    type?: string
    priority?: string
    status?: string
    reply?: string | null
    repliedAt?: Date | string | null
    repliedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    order?: OrderUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeImage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    servedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUpdateWithoutKasirInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashShiftsNestedInput
    storeShift?: StoreShiftUpdateOneWithoutCashShiftsNestedInput
  }

  export type CashShiftUncheckedUpdateWithoutKasirInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUncheckedUpdateManyWithoutKasirInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    product?: ProductUpdateOneRequiredWithoutAdjustmentsNestedInput
    storeShift?: StoreShiftUpdateOneWithoutProductAdjustmentsNestedInput
  }

  export type ProductAdjustmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreShiftUpdateWithoutOpenerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    outlet?: OutletUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutOpenerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateManyWithoutOpenerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    outletId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reply?: NullableStringFieldUpdateOperationsInput | string | null
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    repliedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ProductAdjustmentCreateManyProductInput = {
    id?: string
    tenantId: string
    userId: string
    storeShiftId?: string | null
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type PurchaseOrderItemCreateManyProductInput = {
    id?: string
    purchaseOrderId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferItemCreateManyProductInput = {
    id?: string
    stockTransferId: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockValuationCreateManyProductInput = {
    id?: string
    tenantId: string
    valuationType: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    totalCost: Decimal | DecimalJsLike | number | string
    purchaseDate: Date | string
    purchaseOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    user?: UserUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    storeShift?: StoreShiftUpdateOneWithoutProductAdjustmentsNestedInput
  }

  export type ProductAdjustmentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockTransfer?: StockTransferUpdateOneRequiredWithoutItemsNestedInput
  }

  export type StockTransferItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTransferId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    stockTransferId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockValuationsNestedInput
  }

  export type StockValuationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockValuationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    valuationType?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    cost?: Decimal | DecimalJsLike | number | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    memberId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyMemberInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    outletId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyOutletInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    storeShiftId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreShiftCreateManyOutletInput = {
    id?: string
    tenantId: string
    shiftType: string
    openedBy: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: string
    modalAwal?: Decimal | DecimalJsLike | number | string | null
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    storeShift?: StoreShiftUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    storeShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreShiftUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStoreShiftsNestedInput
    opener?: UserUpdateOneRequiredWithoutStoreShiftsNestedInput
    orders?: OrderUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStoreShiftNestedInput
    cashShifts?: CashShiftUncheckedUpdateManyWithoutStoreShiftNestedInput
    productAdjustments?: ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftNestedInput
    stockTransfers?: StockTransferUncheckedUpdateManyWithoutStoreShiftNestedInput
  }

  export type StoreShiftUncheckedUpdateManyWithoutOutletInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    openedBy?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    modalAwal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryCreateManySubscriptionInput = {
    id?: string
    tenantId: string
    planType: string
    startDate: Date | string
    endDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    durationDays: number
    isTemporary?: boolean
    reverted?: boolean
    createdAt?: Date | string
  }

  export type SubscriptionHistoryUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionHistoryNestedInput
  }

  export type SubscriptionHistoryUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionHistoryUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    durationDays?: IntFieldUpdateOperationsInput | number
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    reverted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    status: string
    responseCode?: number | null
    responseBody?: string | null
    attempts?: number
    nextRetryAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    tenantId: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemCreateManyStockTransferInput = {
    id?: string
    productId: string
    quantity: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferItemUpdateWithoutStockTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockTransferItemsNestedInput
  }

  export type StockTransferItemUncheckedUpdateWithoutStockTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferItemUncheckedUpdateManyWithoutStockTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyStoreShiftInput = {
    id?: string
    idempotencyKey?: string | null
    tenantId: string
    orderNumber: string
    userId: string
    customerId?: string | null
    memberId?: string | null
    outletId?: string | null
    total: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    status?: $Enums.OrderStatus
    sendToKitchen?: boolean
    kitchenStatus?: string | null
    temporaryCustomerName?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashShiftCreateManyStoreShiftInput = {
    id?: string
    tenantId: string
    kasirId: string
    shiftStart?: Date | string
    shiftEnd?: Date | string | null
    modalAwal: Decimal | DecimalJsLike | number | string
    uangFisikTutup?: Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: Decimal | DecimalJsLike | number | string | null
    selisih?: Decimal | DecimalJsLike | number | string | null
    status?: string
    catatan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductAdjustmentCreateManyStoreShiftInput = {
    id?: string
    tenantId: string
    productId: string
    userId: string
    type: string
    quantity: number
    reason: string
    stockBefore: number
    stockAfter: number
    createdAt?: Date | string
  }

  export type StockTransferCreateManyStoreShiftInput = {
    id?: string
    tenantId: string
    fromOutletId: string
    toOutletId: string
    transferNumber: string
    status?: string
    transferDate?: Date | string
    receivedDate?: Date | string | null
    notes?: string | null
    createdBy: string
    receivedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    member?: MemberUpdateOneWithoutOrdersNestedInput
    outlet?: OutletUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transaction?: TransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    outletId?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    sendToKitchen?: BoolFieldUpdateOperationsInput | boolean
    kitchenStatus?: NullableStringFieldUpdateOperationsInput | string | null
    temporaryCustomerName?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashShiftsNestedInput
    kasir?: UserUpdateOneRequiredWithoutCashShiftsNestedInput
  }

  export type CashShiftUncheckedUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kasirId?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashShiftUncheckedUpdateManyWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kasirId?: StringFieldUpdateOperationsInput | string
    shiftStart?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modalAwal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uangFisikTutup?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    saldoSeharusnya?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    selisih?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductAdjustmentsNestedInput
    product?: ProductUpdateOneRequiredWithoutAdjustmentsNestedInput
    user?: UserUpdateOneRequiredWithoutProductAdjustmentsNestedInput
  }

  export type ProductAdjustmentUncheckedUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAdjustmentUncheckedUpdateManyWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    stockBefore?: IntFieldUpdateOperationsInput | number
    stockAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockTransfersNestedInput
    items?: StockTransferItemUpdateManyWithoutStockTransferNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StockTransferItemUncheckedUpdateManyWithoutStockTransferNestedInput
  }

  export type StockTransferUncheckedUpdateManyWithoutStoreShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromOutletId?: StringFieldUpdateOperationsInput | string
    toOutletId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}