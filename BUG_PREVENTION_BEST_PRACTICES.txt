===================================================================================
           BUG PREVENTION STRATEGY & BEST PRACTICES GUIDE
              For New-Warungin SaaS POS Development Team
                        December 9, 2025
===================================================================================

üìö TABLE OF CONTENTS
1. Architecture Best Practices
2. Common Pitfalls & How to Avoid Them
3. Testing Strategy
4. Code Review Checklist
5. Deployment Safety Practices
6. Debugging Techniques
7. Performance Anti-patterns
8. Security Vulnerabilities
9. Database Design Safety
10. API Design Guidelines

===================================================================================
1. ARCHITECTURE BEST PRACTICES
===================================================================================

1.1 LAYERED ARCHITECTURE (Already Following - GOOD!)

Current Structure:
```
client/src/
  ‚îú‚îÄ‚îÄ views/              ‚Üê React components (presentation layer)
  ‚îú‚îÄ‚îÄ components/         ‚Üê Reusable components
  ‚îú‚îÄ‚îÄ stores/             ‚Üê Pinia state management
  ‚îú‚îÄ‚îÄ composables/        ‚Üê Vue 3 composables (business logic)
  ‚îú‚îÄ‚îÄ utils/              ‚Üê Helper functions
  ‚îî‚îÄ‚îÄ api.ts              ‚Üê API client

src/
  ‚îú‚îÄ‚îÄ routes/             ‚Üê Route handlers
  ‚îú‚îÄ‚îÄ services/           ‚Üê Business logic
  ‚îú‚îÄ‚îÄ middlewares/        ‚Üê Express middlewares
  ‚îú‚îÄ‚îÄ validators/         ‚Üê Input validation (Zod)
  ‚îú‚îÄ‚îÄ utils/              ‚Üê Helper functions
  ‚îî‚îÄ‚îÄ config/             ‚Üê Configuration
```

‚úÖ ADVANTAGES:
- Clear separation of concerns
- Easy to test each layer independently
- Reduces coupling between modules

‚ö†Ô∏è RISKS & MITIGATIONS:

Risk 1: Business logic in components (Vue files)
  ‚ùå DON'T:
     ```vue
     <script>
       const fetchOrders = async () => {
         const res = await api.get('/orders');
         const filtered = res.data.filter(o => o.status === 'paid' && o.date > lastMonth);
         const sorted = filtered.sort((a,b) => b.total - a.total);
         orders.value = sorted;
       }
     </script>
     ```
  
  ‚úÖ DO:
     ```vue
     <script setup>
       import { useOrderStore } from '@/stores/orders';
       const orderStore = useOrderStore();
       onMounted(() => orderStore.fetchFilteredOrders());
     </script>
     
     // In stores/orders.ts
     const fetchFilteredOrders = async () => {
       const orders = await orderService.getFilteredOrders();
       state.orders = orders;
     }
     ```

Risk 2: Multiple data transformations in different places
  ‚ùå DON'T: Calculate discount logic in 3 places (POS, API, Report)
  ‚úÖ DO: Calculate once in discountService, use everywhere
  Result: Single source of truth, easier to fix bugs

Risk 3: Tight coupling between frontend & backend
  ‚ùå DON'T: Hardcode API endpoint URLs in components
  ‚úÖ DO: Use API client abstraction layer
  Benefit: Easy to change endpoints, mock for testing

---

1.2 DEPENDENCY INJECTION & LOOSE COUPLING

Current Status: Partially using (dependency injection in some services)

Principle: Inject dependencies rather than importing them directly

‚ùå BAD (tight coupling):
```typescript
// order.service.ts
import { productService } from './product.service';
import { paymentService } from './payment.service';

export const createOrder = async (items: OrderItem[]) => {
  const products = await productService.getProducts(items.map(i => i.productId));
  // ...
}
```

‚úÖ GOOD (loose coupling):
```typescript
export const createOrder = async (
  items: OrderItem[],
  productService: ProductService,  // ‚Üê injected
  paymentService: PaymentService   // ‚Üê injected
) => {
  const products = await productService.getProducts(items.map(i => i.productId));
  // ...
}

// Usage:
createOrder(items, productService, paymentService);
```

Benefits:
- Easy to mock dependencies in tests
- Can swap implementations (e.g., use cache vs no cache)
- Reduces side effects

---

1.3 ERROR HANDLING CONSISTENCY

Current Status: Good error handling in auth, partial in others

Pattern to Follow:

```typescript
// ‚úÖ Custom error class
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public code?: string,
    public context?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// ‚úÖ Service layer (handles business logic errors)
export const createOrder = async (input: OrderInput): Promise<Order> => {
  if (input.items.length === 0) {
    throw new AppError('Order must have at least 1 item', 400, 'EMPTY_ORDER');
  }
  
  const product = await db.product.findUnique({ where: { id: item.productId } });
  if (!product) {
    throw new AppError(
      `Product ${item.productId} not found`,
      404,
      'PRODUCT_NOT_FOUND',
      { productId: item.productId }
    );
  }
  
  try {
    return await db.order.create({ data: { ...orderData } });
  } catch (error) {
    if (error.code === 'P2003') { // Foreign key violation
      throw new AppError('Invalid product or customer reference', 400, 'INVALID_REFERENCE');
    }
    throw new AppError('Failed to create order', 500, 'ORDER_CREATE_FAILED', { error });
  }
};

// ‚úÖ Route layer (handles HTTP)
router.post('/orders', async (req, res, next) => {
  try {
    const validated = orderSchema.parse(req.body);
    const order = await orderService.createOrder(validated);
    res.status(201).json({ order });
  } catch (error) {
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.code,
        message: error.message,
        ...(process.env.NODE_ENV === 'development' && { context: error.context })
      });
    }
    
    // Log unexpected errors
    logger.error('Unexpected error in POST /orders', { error });
    res.status(500).json({ 
      error: 'INTERNAL_SERVER_ERROR',
      message: 'An unexpected error occurred'
    });
  }
});

// ‚úÖ Frontend layer (handles UI)
const handleCreateOrder = async () => {
  try {
    loading.value = true;
    const order = await api.post('/orders', formData);
    showSuccess('Order created successfully!');
    router.push(`/orders/${order.id}`);
  } catch (error) {
    if (error.response?.data?.error === 'PRODUCT_NOT_FOUND') {
      showError('One of the products is no longer available');
    } else {
      showError(error.response?.data?.message || 'Failed to create order');
    }
  } finally {
    loading.value = false;
  }
};
```

Benefits:
- Consistent error responses across all endpoints
- Errors carry context for debugging
- Frontend can handle specific error types
- Logging captures unexpected errors

---

1.4 INPUT VALIDATION AT BOUNDARIES

Current Status: ‚úÖ Using Zod validators (good!)

Pattern:
```typescript
// validators/order.validator.ts
import { z } from 'zod';

export const createOrderSchema = z.object({
  items: z.array(
    z.object({
      productId: z.string().uuid('Invalid product ID'),
      quantity: z.number().int().positive('Quantity must be > 0'),
      customPrice: z.number().nonnegative().optional(),
    })
  ).min(1, 'At least 1 item required'),
  customerId: z.string().uuid().optional(),
  notes: z.string().max(500).optional(),
});

export type CreateOrderInput = z.infer<typeof createOrderSchema>;

// routes/order.routes.ts
router.post('/orders', async (req, res, next) => {
  try {
    const validated = createOrderSchema.parse(req.body);
    // ‚úÖ At this point, validated is guaranteed to match the schema
    const order = await orderService.createOrder(validated);
    res.json({ order });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.errors });
    }
    next(error);
  }
});
```

Benefits:
- Type-safe validation
- Clear error messages
- Prevents invalid data from reaching service layer
- Documentation in code (schema = documentation)

Anti-patterns to AVOID:

‚ùå DON'T validate in service layer:
```typescript
// Bad - validation logic scattered
export const createOrder = async (data) => {
  if (!data.items || data.items.length === 0) throw new Error('...');
  if (data.customerId && !isValidUUID(data.customerId)) throw new Error('...');
  // ... more validation ...
}
```

‚ùå DON'T skip validation on frontend (user can bypass):
```typescript
// Bad - only frontend validation
if (quantity < 1) return; // User can open DevTools and change this
```

‚úÖ DO validate everywhere:
- Frontend: UX, immediate feedback
- Backend: Security, data integrity

===================================================================================
2. COMMON PITFALLS & HOW TO AVOID THEM
===================================================================================

2.1 N+1 QUERY PROBLEM

Description: Fetching a list of items (1 query), then fetching details for each item (N queries) = N+1 total queries

‚ùå ANTI-PATTERN (slow):
```typescript
// BAD: N+1 queries
export const getOrders = async () => {
  const orders = await db.order.findMany(); // ‚Üê 1 query
  
  for (let order of orders) {
    order.items = await db.orderItem.findMany({  // ‚Üê N queries (1 per order)
      where: { orderId: order.id }
    });
  }
  
  return orders;
};

// Performance: 1 + N queries where N = number of orders
// If 1000 orders: 1001 database roundtrips! üò±
```

‚úÖ SOLUTION (eager loading):
```typescript
// GOOD: 1 query with join
export const getOrders = async () => {
  const orders = await db.order.findMany({
    include: { items: true }  // ‚Üê Prisma does JOIN, 1 query total
  });
  return orders;
};

// Performance: 1 database roundtrip regardless of number of orders
```

‚ö†Ô∏è CARE: Don't include everything (can cause performance issues too)

```typescript
// ‚ö†Ô∏è Be selective:
export const getOrders = async () => {
  return await db.order.findMany({
    include: {
      items: true,           // ‚Üê Include if needed
      customer: true,        // ‚Üê Include if needed
      // Don't include: { payments: true, history: true, metadata: true }
    },
    select: {                // ‚Üê Or use select for specific fields
      id: true,
      createdAt: true,
      total: true,
      items: { select: { id: true, quantity: true, price: true } }
    }
  });
};
```

2.2 ASYNC/AWAIT ANTI-PATTERNS

‚ùå PROBLEM 1: Awaiting in loops (sequential when can be parallel):
```typescript
// BAD: processes items one by one
for (const item of items) {
  await processItem(item);  // Each waits for previous to finish
}
// Time: T‚ÇÅ + T‚ÇÇ + T‚ÇÉ + ... (total is sum)
```

‚úÖ SOLUTION: Use Promise.all()
```typescript
// GOOD: processes all items in parallel
await Promise.all(items.map(item => processItem(item)));
// Time: max(T‚ÇÅ, T‚ÇÇ, T‚ÇÉ, ...) (total is max)
```

‚ùå PROBLEM 2: Swallowing errors:
```typescript
// BAD: error silently ignored
const result = await fetchData().catch(err => null);
// Later: if (result.items) { ... } ‚Üê Crashes! result is null
```

‚úÖ SOLUTION: Handle errors properly
```typescript
// GOOD: handle error explicitly
try {
  const result = await fetchData();
  if (result.items) { ... }
} catch (error) {
  logger.error('Failed to fetch data', { error });
  showError('Could not load data, please try again');
}
```

‚ùå PROBLEM 3: Fire-and-forget without error handling:
```typescript
// BAD: email sending might fail silently
router.post('/orders', async (req, res) => {
  const order = await createOrder(req.body);
  
  sendOrderConfirmationEmail(order);  // ‚Üê No await, no error handling
  
  res.json({ order });
  // User gets response, but email might never send
});
```

‚úÖ SOLUTION: Either await with error handling, or queue it:
```typescript
// GOOD OPTION 1: Wait for email to send
router.post('/orders', async (req, res) => {
  const order = await createOrder(req.body);
  
  try {
    await sendOrderConfirmationEmail(order);
  } catch (error) {
    logger.error('Failed to send order confirmation', { orderId: order.id, error });
    // Decide: fail the order creation, or just log and continue?
  }
  
  res.json({ order });
});

// GOOD OPTION 2: Queue email for async processing
router.post('/orders', async (req, res) => {
  const order = await createOrder(req.body);
  
  // Queue email job (will be processed by background worker)
  await emailQueue.enqueue({
    type: 'ORDER_CONFIRMATION',
    orderId: order.id,
    customerEmail: order.customer.email
  });
  
  res.json({ order });
  // Order is returned immediately, email sent in background
});
```

2.3 RACE CONDITIONS

Description: Multiple operations happen simultaneously, causing unexpected behavior

‚ùå EXAMPLE:
```typescript
// Multiple POS terminals processing order simultaneously
Terminal A: Get product stock (50 units)
Terminal B: Get product stock (50 units)
Terminal A: Create order for 40 units ‚Üí stock becomes 10
Terminal B: Create order for 40 units ‚Üí stock becomes 10 (WRONG! Should be -30)
```

‚úÖ SOLUTION 1: Optimistic Locking
```typescript
export const createOrder = async (items: OrderItem[]) => {
  for (const item of items) {
    const result = await db.product.updateMany({
      where: {
        id: item.productId,
        stock: { gte: item.quantity }  // ‚Üê Only update if stock is enough
      },
      data: {
        stock: { decrement: item.quantity }
      }
    });
    
    if (result.count === 0) {
      // Stock wasn't enough (another order might have taken it)
      throw new AppError('Insufficient stock', 400, 'INSUFFICIENT_STOCK');
    }
  }
};
```

‚úÖ SOLUTION 2: Pessimistic Locking (row-level)
```typescript
export const createOrder = async (items: OrderItem[]) => {
  const products = await db.$transaction(async (tx) => {
    // Lock rows until transaction completes
    const productsToUpdate = await tx.product.findMany({
      where: { id: { in: items.map(i => i.productId) } },
      // Force lock (PostgreSQL: FOR UPDATE)
    });
    
    // Check stock & update
    for (const item of items) {
      const product = productsToUpdate.find(p => p.id === item.productId);
      if (product.stock < item.quantity) {
        throw new Error('Insufficient stock');
      }
    }
    
    // Update all at once
    const updates = items.map(item =>
      tx.product.update({
        where: { id: item.productId },
        data: { stock: { decrement: item.quantity } }
      })
    );
    
    return await Promise.all(updates);
  });
};
```

‚úÖ SOLUTION 3: Queue-based Processing (safest)
```typescript
// Don't process orders directly, queue them
router.post('/orders', async (req, res) => {
  const order = await db.order.create({
    data: { ...validated, status: 'PENDING' }
  });
  
  // Queue order for processing
  await orderQueue.enqueue({ orderId: order.id });
  
  res.status(201).json({ order });
});

// Background worker processes one at a time
orderQueue.onJob(async (job) => {
  const order = await getOrder(job.orderId);
  
  try {
    await processOrder(order);  // Updates stock, payment, kitchen order
    await order.update({ status: 'CONFIRMED' });
  } catch (error) {
    await order.update({ status: 'FAILED', error: error.message });
  }
});
```

2.4 STATE MUTATION & UNPREDICTABLE BEHAVIOR

‚ùå AVOID Mutating objects directly:
```typescript
// BAD: mutating data causes hard-to-track bugs
const updateOrder = (orderId, updates) => {
  const order = orders.value.find(o => o.id === orderId);
  order.status = 'completed';  // ‚Üê Direct mutation
  order.total = updates.total;
};
```

‚úÖ USE Immutable patterns:
```typescript
// GOOD: creating new objects
const updateOrder = (orderId, updates) => {
  orders.value = orders.value.map(order =>
    order.id === orderId
      ? { ...order, status: 'completed', total: updates.total }  // New object
      : order
  );
};
```

Benefit: Easier to trace changes, Vue reactivity works better

---

2.5 UNDEFINED & NULL HANDLING

‚ùå PROBLEM: Checking existence incorrectly
```typescript
// BAD: doesn't handle falsy values
if (product.price) {  // ‚Üê Fails if price is 0!
  // ...
}

// BAD: doesn't handle null vs undefined
const count = data.items?.length;  // undefined if no items
if (count) { ... }  // Fails if count is 0

// BAD: assumes nested path exists
const discount = user.profile.preferences.discount; // Crashes if any level is null
```

‚úÖ GOOD: Explicit null checks
```typescript
// GOOD
if (product.price != null && product.price > 0) {
  // ...
}

// GOOD
const count = data.items?.length ?? 0;  // Default to 0
if (count > 0) { ... }

// GOOD
const discount = user?.profile?.preferences?.discount ?? 0;
```

---

2.6 ARRAY OPERATIONS WITHOUT GUARDS

‚ö†Ô∏è THIS IS THE BUG THAT WAS JUST FIXED! (Remember "B.value.some is not a function")

‚ùå MISTAKE:
```typescript
const allowedStoreIds = user.permissions?.allowedStoreIds;
if (allowedStoreIds.length > 1) {  // ‚Üê Crashes if allowedStoreIds is not array!
  // ...
}
```

‚úÖ CORRECT:
```typescript
// Option 1: Explicit check
const allowedStoreIds = user.permissions?.allowedStoreIds;
if (Array.isArray(allowedStoreIds) && allowedStoreIds.length > 1) {
  // ...
}

// Option 2: Helper function (already exists in codebase!)
import { safeSome } from '@/utils/array-helpers';
if (safeSome(allowedStoreIds, id => id === targetId)) {
  // ...
}

// Option 3: Ensure array upfront
const allowedStoreIds = Array.isArray(user.permissions?.allowedStoreIds)
  ? user.permissions.allowedStoreIds
  : [];
if (allowedStoreIds.length > 1) { ... }
```

===================================================================================
3. TESTING STRATEGY
===================================================================================

Current Status: Some unit tests exist, but coverage could be higher

3.1 TESTING PYRAMID

```
        /\
       /  \         E2E Tests (5-10%)
      /    \        - User workflows
     /------\       - Database involved
    /        \
   /  /\      \     Integration Tests (30-40%)
  /  /  \      \    - Service + Database
 /  /    \      \   - API endpoints
/__/______\_____\   - Multiple components
|                |
|  Unit Tests    |   Unit Tests (50-60%)
| (70-80%)       |   - Pure functions
|________________|   - Single responsibility
                     - No DB, no HTTP

Test Count:
- 200+ Unit tests (fast, run in < 1s)
- 50+ Integration tests (slower, run in 10-30s)
- 10+ E2E tests (slowest, run in 1-5 mins)
```

3.2 UNIT TEST EXAMPLES

```typescript
// services/__tests__/discount.service.test.ts
import { describe, it, expect } from 'vitest';
import { calculateDiscount } from '../discount.service';

describe('Discount Service', () => {
  describe('calculateDiscount', () => {
    it('should apply percentage discount', () => {
      const discount = calculateDiscount(100, { type: 'PERCENTAGE', value: 10 });
      expect(discount).toBe(10);
    });
    
    it('should apply fixed amount discount', () => {
      const discount = calculateDiscount(100, { type: 'FIXED', value: 10 });
      expect(discount).toBe(10);
    });
    
    it('should cap discount at order total', () => {
      const discount = calculateDiscount(100, { type: 'PERCENTAGE', value: 150 });
      expect(discount).toBe(100); // Can't discount more than total
    });
    
    it('should return 0 for invalid discount', () => {
      const discount = calculateDiscount(100, null);
      expect(discount).toBe(0);
    });
  });
});
```

3.3 INTEGRATION TEST EXAMPLES

```typescript
// tests/integration/order.integration.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { createTestDatabase } from '../test-utils';
import { orderService } from '../../src/services/order.service';

describe('Order Service Integration', () => {
  let db;
  
  beforeEach(async () => {
    db = await createTestDatabase();
  });
  
  afterEach(async () => {
    await db.disconnect();
  });
  
  it('should create order and deduct stock', async () => {
    // Setup
    const product = await db.product.create({
      data: { name: 'Pizza', sku: 'PIZZA001', price: 50000, stock: 10 }
    });
    
    // Action
    const order = await orderService.createOrder({
      items: [{ productId: product.id, quantity: 3 }]
    });
    
    // Verify
    expect(order.id).toBeDefined();
    const updatedProduct = await db.product.findUnique({
      where: { id: product.id }
    });
    expect(updatedProduct.stock).toBe(7); // 10 - 3
  });
  
  it('should fail if stock insufficient', async () => {
    const product = await db.product.create({
      data: { name: 'Pizza', sku: 'PIZZA001', price: 50000, stock: 2 }
    });
    
    await expect(
      orderService.createOrder({
        items: [{ productId: product.id, quantity: 5 }]
      })
    ).rejects.toThrow('Insufficient stock');
  });
});
```

3.4 E2E TEST EXAMPLES

```typescript
// tests/e2e/order-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Complete Order Flow', () => {
  test('customer should be able to place order', async ({ page }) => {
    // Navigate to POS
    await page.goto('http://localhost:3000/pos');
    
    // Login
    await page.fill('[name="email"]', 'kasir@demo.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('button:has-text("Login")');
    
    // Wait for dashboard
    await expect(page).toHaveURL(/\/dashboard/);
    
    // Click POS
    await page.click('a:has-text("POS")');
    
    // Add product
    await page.click('button:has-text("Add Product")');
    await page.fill('[placeholder="Search product"]', 'Pizza');
    await page.click('text=Pizza Margherita');
    await page.fill('[name="quantity"]', '2');
    
    // Checkout
    await page.click('button:has-text("Checkout")');
    
    // Payment
    await page.selectOption('[name="paymentMethod"]', 'cash');
    await page.fill('[name="amount"]', '100000');
    await page.click('button:has-text("Pay")');
    
    // Verify success
    await expect(page.locator('text=Order created')).toBeVisible();
  });
});
```

3.5 TESTING CHECKLIST

Before merging code:
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] No console errors in tests
- [ ] Code coverage > 80% for new code
- [ ] E2E tests for critical user flows pass

For bug fixes:
- [ ] Write a test that reproduces the bug
- [ ] Verify test fails before fix
- [ ] Apply fix
- [ ] Verify test passes after fix
- [ ] No other tests break

===================================================================================
4. CODE REVIEW CHECKLIST
===================================================================================

Every PR should be reviewed against this checklist:

‚úÖ FUNCTIONALITY
- [ ] Code implements the requirement/fixes the bug
- [ ] All edge cases handled
- [ ] Error cases tested
- [ ] No console.log() left in code (use logger instead)

‚úÖ PERFORMANCE
- [ ] No N+1 queries (if database involved)
- [ ] No unnecessary renders (Vue reactivity check)
- [ ] No large objects/arrays created unnecessarily
- [ ] Async operations parallelized where possible

‚úÖ SECURITY
- [ ] Input validated (backend AND frontend)
- [ ] No hardcoded secrets
- [ ] No SQL injection risks
- [ ] XSS protection in place
- [ ] Authorization checks present

‚úÖ CODE QUALITY
- [ ] Code is readable (clear variable names)
- [ ] Functions are small & focused (< 50 lines)
- [ ] No code duplication (DRY principle)
- [ ] Comments explain WHY, not WHAT
- [ ] No dead code or unused imports

‚úÖ TESTING
- [ ] Tests are comprehensive (happy path + edge cases)
- [ ] Tests are readable
- [ ] Tests can run in isolation
- [ ] All tests pass

‚úÖ DOCUMENTATION
- [ ] Changes documented in comments if non-obvious
- [ ] API documentation updated (if applicable)
- [ ] README updated (if affecting setup/usage)
- [ ] Breaking changes documented

‚úÖ DATABASE
- [ ] No N+1 queries
- [ ] Proper indexes used
- [ ] Migrations written correctly
- [ ] Data types appropriate
- [ ] Foreign keys consistent

‚ùå MUST NOT MERGE IF:
- [ ] Tests fail
- [ ] Security vulnerability introduced
- [ ] Breaking change not documented
- [ ] Code doesn't follow team standards
- [ ] Error handling missing for external API calls

===================================================================================
5. DEPLOYMENT SAFETY PRACTICES
===================================================================================

5.1 PRE-DEPLOYMENT CHECKLIST

```
[ ] All tests passing (unit, integration, E2E)
[ ] Code review approved by 2+ reviewers
[ ] No security vulnerabilities (npm audit)
[ ] Dependencies updated (if applicable)
[ ] Database migrations tested on staging
[ ] Environment variables configured
[ ] Monitoring/alerts configured
[ ] Rollback plan documented
[ ] Stakeholders notified
[ ] Maintenance window scheduled (if needed)
[ ] Backups taken
```

5.2 DEPLOYMENT PROCESS

```
1. Create release branch from main
2. Run full test suite
3. Build Docker image
4. Deploy to staging environment
5. Run smoke tests on staging
6. Get approval from product/ops team
7. Deploy to production (blue-green deployment)
8. Verify critical features work
9. Monitor error logs & metrics for 30 mins
10. If issues: ROLLBACK immediately
11. If all good: Mark release as stable
```

5.3 ROLLBACK PROCEDURE

```
IF CRITICAL BUG discovered after deployment:

1. STOP - Don't make more changes
2. ALERT - Notify team immediately
3. REVERT - Deploy previous stable version
4. FIX - Fix bug on local/staging
5. TEST - Test thoroughly
6. RE-DEPLOY - Deploy the fix
7. POST-MORTEM - What went wrong? Why?
8. IMPROVE - Update process to prevent recurrence

Critical bugs examples:
- Payment processing broken
- Data loss
- Security vulnerability
- System unavailable
```

5.4 BLUE-GREEN DEPLOYMENT (Recommended)

```
Before:                          After:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Blue (v1)      ‚îÇ    ‚îÄ‚îÄ‚Üí      ‚îÇ  Blue (v1)      ‚îÇ  (old, kept for rollback)
‚îÇ  Production ‚úì   ‚îÇ             ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                        ‚îÇ
                                        ‚îú‚îÄ‚îÄ‚Üí ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                             ‚îÇ  Green (v2)     ‚îÇ
                                             ‚îÇ  Production ‚úì   ‚îÇ
                                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

If v2 has issues: switch back to v1 immediately (just change DNS/LB)
No downtime, instant rollback
```

===================================================================================
6. DEBUGGING TECHNIQUES
===================================================================================

6.1 SYSTEMATIC DEBUGGING PROCESS

When something breaks:

1. **IDENTIFY**: What's broken?
   - Feature not working?
   - Performance issue?
   - Data inconsistency?
   - User report?

2. **REPRODUCE**: Can you make it happen again?
   - If not reproducible: inconsistent bug (timing, concurrency)
   - Always try to make it reproducible first

3. **ISOLATE**: What changed?
   - Check git log (what was deployed recently?)
   - Check database (was data modified?)
   - Check logs (any errors around the time it started?)

4. **HYPOTHESIZE**: What could cause it?
   - Could be multiple root causes
   - Eliminate most likely first

5. **TEST**: Validate your hypothesis
   - Change one thing at a time
   - Re-run test
   - Did it fix the issue?

6. **VERIFY**: Is it really fixed?
   - Test multiple times
   - Test edge cases
   - Write a test to prevent regression

6.2 DEBUGGING TOOLS

Frontend:
- Chrome DevTools (Network, Console, Performance, Sources)
- Vue DevTools extension
- React DevTools (if using React)

Backend:
- VS Code Debugger (Node.js)
- `npm run dev` with debug logging
- Database GUI tool (DBeaver, TablePlus)
- curl / Postman for API testing

6.3 ADDING LOGGING FOR DEBUGGING

‚úÖ GOOD LOGGING:
```typescript
logger.info('Order created', {
  orderId: order.id,
  tenantId: order.tenantId,
  totalAmount: order.total,
  itemCount: order.items.length,
  userId: req.userId
});

// Output:
// [INFO] 2025-12-09T10:30:45.123Z Order created {"orderId":"ORD-123","tenantId":"TNT-456",...}
```

‚ùå BAD LOGGING:
```typescript
console.log('Order created!');  // No context
console.log(order);             // Entire object, too much data
console.log('DEBUG: processing order...'); // No timestamp, manual debug log
```

===================================================================================
7. PERFORMANCE ANTI-PATTERNS
===================================================================================

7.1 DON'T: Load all data unnecessarily

‚ùå BAD:
```typescript
// Loading all 10,000 products to display 50 on page
GET /products ‚Üí returns all 10,000 items
Frontend: takes first 50 ‚Üí wastes bandwidth

Performance: 10s to load, high memory usage
```

‚úÖ GOOD:
```typescript
// Pagination: load only what's needed
GET /products?page=1&limit=50 ‚Üí returns 50 items, page info
Frontend: fast, memory efficient

Performance: 1s to load
```

7.2 DON'T: Synchronous operations when async possible

‚ùå BAD:
```typescript
for (const order of orders) {
  await sendEmail(order);  // Waits 5s per order
}
// Total: 5s √ó 1000 orders = 83 minutes!
```

‚úÖ GOOD:
```typescript
await Promise.all(
  orders.map(order => sendEmail(order))  // Sends all in parallel
);
// Total: 5s (all in parallel)
```

7.3 DON'T: Re-compute expensive values

‚ùå BAD:
```typescript
// Computed property called on every render
computed: {
  totalRevenue: () => {
    // Calculate sum of all orders (expensive!)
    return orders.value.reduce((sum, o) => sum + o.total, 0);
  }
}

// Re-calculated even if orders.value didn't change!
```

‚úÖ GOOD:
```typescript
computed: {
  totalRevenue: () => {
    // Only recalculates if orders changes
    return orders.value.reduce((sum, o) => sum + o.total, 0);
  }
}

// Or: cache the value
data: {
  totalRevenue: 0,
  orders: []
},
watch: {
  orders: {
    deep: true,
    handler(newOrders) {
      this.totalRevenue = newOrders.reduce((sum, o) => sum + o.total, 0);
    }
  }
}
```

7.4 DON'T: Create unnecessary DOM elements

‚ùå BAD:
```vue
<!-- Renders 10,000 items = 10,000 DOM nodes -->
<div v-for="order in allOrders" :key="order.id">
  {{ order.id }} - {{ order.total }}
</div>

Performance: Slow rendering, high memory usage
```

‚úÖ GOOD:
```vue
<!-- Virtual scrolling: renders only visible items -->
<virtual-scroll
  :items="allOrders"
  :item-size="50"
  :visible-items="20"
>
  <template v-slot="{ item }">
    <div>{{ item.id }} - {{ item.total }}</div>
  </template>
</virtual-scroll>

Performance: 1000 items but only ~30 DOM nodes visible = fast
```

===================================================================================
8. SECURITY VULNERABILITIES
===================================================================================

8.1 SQL INJECTION

‚ùå VULNERABLE:
```typescript
const query = `SELECT * FROM orders WHERE id = '${orderId}'`;
// If orderId = "1' OR '1'='1", returns all orders!
```

‚úÖ SAFE:
```typescript
// Prisma automatically parameterizes queries
const order = await db.order.findUnique({
  where: { id: orderId }  // Parameterized
});
```

Lesson: Always use ORM/parameterized queries, NEVER string concatenation

---

8.2 CROSS-SITE SCRIPTING (XSS)

‚ùå VULNERABLE:
```vue
<!-- User input directly injected into HTML -->
<div>{{ userInput }}</div>  <!-- Vue escapes this, safe -->
<div v-html="userInput"></div>  <!-- DANGEROUS! -->
<!-- If userInput = "<img src=x onerror='alert(1)'>", script runs! -->
```

‚úÖ SAFE:
```vue
<!-- Vue escapes by default -->
<div>{{ userInput }}</div>  <!-- Safe -->

<!-- If must use HTML, sanitize it -->
<div v-html="sanitize(userInput)"></div>  <!-- Safe -->

import DOMPurify from 'dompurify';
const sanitize = (html) => DOMPurify.sanitize(html);
```

Lesson: Never use v-html with user input, always sanitize

---

8.3 AUTHENTICATION BYPASS

‚ùå VULNERABLE:
```typescript
// Token validation optional
if (req.headers.authorization) {
  token = verifyToken(req.headers.authorization);
} else {
  token = null;  // Allow without token!
}
```

‚úÖ SAFE:
```typescript
// Token required
const token = verifyToken(req.headers.authorization);
if (!token) {
  throw new Error('Unauthorized');
}
```

Lesson: Always validate authentication, never make it optional

---

8.4 UNAUTHORIZED ACCESS

‚ùå VULNERABLE:
```typescript
// No tenant check
router.get('/orders/:id', (req, res) => {
  const order = await db.order.findUnique({
    where: { id: req.params.id }
  });
  res.json(order);  // User can see ANY order!
});
```

‚úÖ SAFE:
```typescript
// Tenant check
router.get('/orders/:id', authGuard, (req, res) => {
  const order = await db.order.findUnique({
    where: {
      id: req.params.id,
      tenantId: req.user.tenantId  // ‚Üê Only their tenant's orders
    }
  });
  
  if (!order) {
    throw new AppError('Order not found', 404);
  }
  
  res.json(order);
});
```

Lesson: Always check tenant/user ownership before returning data

---

8.5 SENSITIVE DATA IN LOGS

‚ùå VULNERABLE:
```typescript
logger.info('User login', { email, password, token });
// Logs contain passwords, tokens!
```

‚úÖ SAFE:
```typescript
logger.info('User login', { email, userId });
// Never log: passwords, tokens, credit cards, SSN
```

Lesson: Think about what you log - could it be a security risk?

===================================================================================
9. DATABASE DESIGN SAFETY
===================================================================================

9.1 FOREIGN KEY CONSTRAINTS

‚úÖ GOOD: Enforce relationships
```sql
CREATE TABLE orderItems (
  id UUID PRIMARY KEY,
  orderId UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  productId UUID NOT NULL REFERENCES products(id),
  -- If order deleted, order items deleted too
);
```

Prevents orphaned data (order items without order)

9.2 UNIQUE CONSTRAINTS

‚úÖ GOOD: Prevent duplicates
```typescript
// In Prisma schema
model Product {
  id String @id
  tenantId String
  sku String
  
  @@unique([tenantId, sku])  // SKU must be unique per tenant
}
```

Prevents duplicate SKUs within a tenant

9.3 INDEXES

‚úÖ GOOD: Speed up queries
```typescript
model Order {
  id String @id
  tenantId String
  createdAt DateTime
  status String
  
  @@index([tenantId, createdAt])  // Index for listing orders by tenant
  @@index([status])  // Index for filtering by status
}
```

Without index: queries scan entire table (slow)
With index: queries use B-tree lookup (fast)

9.4 TRANSACTIONS FOR DATA CONSISTENCY

‚úÖ GOOD: All-or-nothing updates
```typescript
const order = await db.$transaction(async (tx) => {
  // Either ALL succeed or ALL rollback
  const order = await tx.order.create({ data: orderData });
  const stock = await tx.product.update({
    where: { id: productId },
    data: { stock: { decrement: quantity } }
  });
  
  if (stock.stock < 0) {
    throw new Error('Insufficient stock');  // Rollback everything
  }
  
  return order;
});
```

Without transaction: order created but stock not updated (inconsistent)

===================================================================================
10. API DESIGN GUIDELINES
===================================================================================

10.1 CONSISTENT RESPONSE FORMAT

‚úÖ ALL responses should follow same format:
```typescript
// Success
{
  "success": true,
  "data": { ... },
  "message": "Order created successfully"
}

// Error
{
  "success": false,
  "error": "INSUFFICIENT_STOCK",
  "message": "Not enough stock for product X"
}

// List with pagination
{
  "success": true,
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 50,
    "total": 250,
    "totalPages": 5
  }
}
```

Benefits:
- Frontend knows what to expect
- Easier error handling
- Better API documentation

10.2 VERSIONING

As API grows, maintain backwards compatibility:

```
/api/v1/orders    ‚Üê Stable, old
/api/v2/orders    ‚Üê New version with changes
```

When introducing breaking changes:
1. Create v2 endpoint
2. Keep v1 working for 6 months
3. Migrate customers to v2
4. Deprecate v1

10.3 RATE LIMITING

Protect against abuse:

```typescript
// Limit: 1000 requests per minute per API key
router.use(rateLimit({
  windowMs: 60 * 1000,  // 1 minute
  max: 1000,            // 1000 requests
  keyGenerator: (req) => req.headers['x-api-key'],
  message: 'Too many requests, please retry later'
}));
```

10.4 PAGINATION

Never return all data:

```
GET /orders?page=1&limit=50
```

Always:
- Default limit (50)
- Max limit (500)
- Return pagination metadata

===================================================================================
FINAL RECOMMENDATIONS
===================================================================================

üéØ IMMEDIATE ACTIONS:
1. ‚úÖ Deploy bugfix for Login.vue (done)
2. üî¥ Fix payment gateway status (Week 1)
3. üî¥ Finish encryption migration (Week 2)

üéØ SHORT TERM (Next month):
1. Add comprehensive testing (unit + integration)
2. Implement monitoring & alerting
3. Security audit of codebase
4. Complete partial features

üéØ LONG TERM (Next 3 months):
1. Optimize for scale (database, caching)
2. Mobile app or PWA enhancement
3. Omnichannel integrations

üéØ CONTINUOUS:
1. Code reviews (2+ approvals)
2. Dependency updates
3. Security patches
4. User feedback integration

===================================================================================
Document prepared for New-Warungin development team
December 9, 2025
===================================================================================
