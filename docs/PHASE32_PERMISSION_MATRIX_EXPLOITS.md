# PHASE 32.5: PERMISSION MATRIX & SECURITY EXPLOITS
## Complete Authorization Framework & Attack Scenario Testing

**Date:** January 1, 2026  
**Phase:** 32.5 - Senior Security Architect & Penetration Tester  
**Status:** READY FOR EXECUTION

---

## EXECUTIVE SUMMARY

This document provides:
1. **Complete Permission Matrix** - ALL actions × ALL roles
2. **Authorization Rules** - WHY each permission is granted/denied
3. **Attack Scenarios** - Exploit attempts and expected defenses
4. **Exact Fixes** - Middleware, guards, policy implementations

---

## SECTION 1: ROLE DEFINITIONS

### 1.1 Role Hierarchy

```
┌──────────────────────────────────────────┐
│         SUPER ADMIN                      │
│  - Global system control                 │
│  - Create/Delete tenants                 │
│  - View all data across all tenants      │
│  - Super Admin only: tenantId = NULL     │
└────────────────┬─────────────────────────┘
                 │
                 │ (Can manage)
                 ▼
┌──────────────────────────────────────────┐
│         TENANT ADMIN                     │
│  - Manage single tenant's data           │
│  - Manage staff and outlets              │
│  - Can NOT create new tenants            │
│  - Can NOT see other tenant's data       │
└────────────────┬─────────────────────────┘
                 │
                 │ (Can manage)
                 ▼
┌──────────────────────────────────────────┐
│         STAFF                            │
│  - Use POS to create transactions        │
│  - View assigned outlets only            │
│  - Can NOT manage users or settings      │
└──────────────────────────────────────────┘
```

### 1.2 Role Attributes

| Role | tenant_id | Can View Other Tenants | Can Create Tenants | Can Delete Tenants |
|------|-----------|------------------------|--------------------|--------------------|
| SUPER_ADMIN | NULL | YES (All) | YES | YES |
| TENANT_ADMIN | NOT NULL | NO (Own only) | NO | NO |
| STAFF | NOT NULL | NO (Own only) | NO | NO |

---

## SECTION 2: COMPLETE PERMISSION MATRIX

### 2.1 TENANT MANAGEMENT

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| CREATE tenant | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Only Super Admin can create new SaaS customers |
| READ all tenants | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Admin sees only own tenant data |
| UPDATE tenant (own) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can modify their own tenant settings |
| UPDATE tenant (other) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant edit forbidden |
| DELETE tenant (own) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Only Super Admin deletes tenants |
| DELETE tenant (other) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant delete forbidden |
| LIST tenants | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Admin doesn't see other tenants |

**Enforcement Points:**
- Middleware: `TenantGuard` checks `user.tenant_id` vs `request.params.tenant_id`
- ORM: All Prisma queries filter `where: {tenant_id: userContext.tenant_id}`
- API: Tenant ID cannot be in request body (server assigns from auth context)

---

### 2.2 USER MANAGEMENT

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| CREATE user (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages own staff |
| CREATE user (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant staff creation forbidden |
| READ own profile | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | Everyone can see self |
| READ user (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can see all staff |
| READ user (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant user read forbidden |
| UPDATE user role (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages staff roles |
| UPDATE user role to SUPER_ADMIN | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Only Super Admin can create Super Admin |
| UPDATE user (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant user edit forbidden |
| DELETE user (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can delete own staff |
| DELETE user (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant delete forbidden |
| DELETE last admin (own tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Prevent tenant from losing admin |
| ASSIGN role SUPER_ADMIN | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Only Super Admin can create Super Admin |
| DEACTIVATE user | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages staff status |
| LIST users (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Staff can't see other staff |
| LIST users (all) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant list forbidden |
| RESET password | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin resets own staff |
| CHANGE own password | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | Everyone changes own password |

**Enforcement:**
```typescript
// RoleGuard middleware
@UseGuards(AuthGuard, RoleGuard)
createUser(
  @TenantContext() tenantId,
  @RoleContext() role
) {
  if (role !== 'SUPER_ADMIN' && role !== 'ADMIN') {
    throw ForbiddenException('Only admins can create users');
  }
  // ...
}
```

---

### 2.3 OUTLET MANAGEMENT

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| CREATE outlet (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages outlets |
| CREATE outlet (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant outlet creation forbidden |
| READ outlet list (own) | ✅ ALLOWED | ✅ ALLOWED | ⚠️ ASSIGNED | Staff sees assigned outlets only |
| READ outlet list (all) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Staff can't see all outlets |
| READ outlet detail (own) | ✅ ALLOWED | ✅ ALLOWED | ⚠️ ASSIGNED | Must be assigned to outlet |
| READ outlet detail (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant outlet read forbidden |
| UPDATE outlet (own) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can update own outlets |
| UPDATE outlet (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant outlet edit forbidden |
| DELETE outlet (own) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can delete own outlets |
| DELETE outlet (active trans) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Prevent deletion with active transactions |
| DELETE outlet (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant delete forbidden |
| ASSIGN staff to outlet | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages staff assignment |
| ASSIGN staff (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant assignment forbidden |

**Enforcement:**
```typescript
// OutletGuard - ensure outlet belongs to user's tenant
if (outlet.tenant_id !== userContext.tenant_id) {
  throw ForbiddenException('Outlet not found');
}
```

---

### 2.4 TRANSACTION MANAGEMENT

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| CREATE transaction (assigned outlet) | ✅ ALLOWED | ❌ DENIED | ✅ ALLOWED | Staff creates POS transactions |
| CREATE transaction (all outlets) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Staff limited to assigned outlets |
| CREATE transaction (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant transaction forbidden |
| READ transaction list (own) | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | Each role sees their own data |
| READ transaction list (all) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Staff can't see all transactions |
| READ transaction detail | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | Same tenant only |
| READ transaction (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant transaction read forbidden |
| UPDATE transaction (own) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Immutable after creation (payment systems) |
| DELETE transaction | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | No one deletes transactions (audit trail) |
| VOID transaction (own outlet) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can void, Staff cannot |
| EXPORT transactions | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin exports reports |

**Enforcement:**
```typescript
// TransactionGuard - ensure outlet belongs to user's tenant
const transaction = await getTransaction(transactionId);
const outlet = await getOutlet(transaction.outlet_id);
if (outlet.tenant_id !== userContext.tenant_id) {
  throw ForbiddenException('Transaction not found');
}
```

---

### 2.5 INVENTORY MANAGEMENT

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| CREATE item (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages inventory |
| CREATE item (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant item creation forbidden |
| READ item list (own) | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | Staff can see items to sell |
| READ item list (all) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Staff sees own tenant items only |
| READ item (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant item read forbidden |
| UPDATE item (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages item details |
| UPDATE item quantity | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Only admin adjusts inventory |
| UPDATE item (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant item edit forbidden |
| DELETE item (own tenant) | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin can delete items |
| DELETE item (other tenant) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant item delete forbidden |
| IMPORT items | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin bulk imports inventory |
| EXPORT items | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin exports item list |

---

### 2.6 ANALYTICS & REPORTING

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| VIEW analytics dashboard | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only for business reports |
| VIEW revenue report | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Staff doesn't access financials |
| VIEW transaction history | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | All can view (for reference) |
| VIEW audit logs | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin oversight |
| VIEW audit logs (all tenants) | ✅ ALLOWED | ❌ DENIED | ❌ DENIED | Cross-tenant audit forbidden |
| EXPORT analytics | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only |

---

### 2.7 SETTINGS & CONFIGURATION

| Action | Super Admin | Tenant Admin | Staff | Reasoning |
|--------|-----------|------------|-------|-----------|
| ACCESS settings page | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin configuration |
| UPDATE business info | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin manages tenant profile |
| UPDATE security settings | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin controls security |
| ENABLE 2FA | ✅ ALLOWED | ✅ ALLOWED | ✅ ALLOWED | Everyone can enable 2FA for self |
| VIEW API keys | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only |
| GENERATE API key | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only |
| REVOKE API key | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only |
| VIEW integrations | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only |
| CONFIGURE integrations | ✅ ALLOWED | ✅ ALLOWED | ❌ DENIED | Admin only |

---

## SECTION 3: ATTACK SCENARIOS & DEFENSES

### 3.1 ATTACK SCENARIO 1: Tenant Admin Accessing Other Tenant's Data

```
Attacker: Tenant A Admin
Target: Tenant B outlet data
Method: Direct API call with Tenant B outlet ID
```

#### Attack Code:
```bash
# Tenant A Admin token
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
TENANT_A_ID="tenant_a_uuid"
TENANT_B_OUTLET_ID="outlet_from_tenant_b_uuid"

# Attempt 1: Get outlet by ID
curl -X GET "http://localhost:3000/api/outlets/$TENANT_B_OUTLET_ID" \
  -H "Authorization: Bearer $TOKEN"

# Attempt 2: Use query parameter
curl -X GET "http://localhost:3000/api/outlets?tenantId=tenant_b_uuid" \
  -H "Authorization: Bearer $TOKEN"

# Attempt 3: Manipulate outlet ID in path
curl -X POST "http://localhost:3000/api/outlets/$TENANT_B_OUTLET_ID/transactions" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 100000,
    "paymentMethod": "cash"
  }'
```

#### Expected Defenses:

**Defense Layer 1: TenantGuard Middleware**
```typescript
// middleware/tenant.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';

@Injectable()
export class TenantGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user; // From JWT
    const outletId = request.params.outletId; // From URL
    
    const outlet = await this.outletsService.findById(outletId);
    
    // Check if outlet belongs to user's tenant
    if (!outlet || outlet.tenant_id !== user.tenant_id) {
      throw new ForbiddenException('Outlet not found');
      // Note: Generic message - don't reveal existence
    }
    
    return true;
  }
}

// Usage in controller
@Controller('outlets')
@UseGuards(AuthGuard, TenantGuard)
export class OutletsController {
  @Get(':outletId')
  async getOutlet(@Param('outletId') outletId: string) {
    // TenantGuard already verified ownership
    return this.outletsService.findById(outletId);
  }
}
```

**Defense Layer 2: ORM-Level Filtering**
```typescript
// outlets.service.ts
async findById(id: string, tenantId: string) {
  const outlet = await this.prisma.outlets.findUnique({
    where: { id },
    // IMPORTANT: Always verify tenant_id in application code
    // Even if Guard checked it
  });
  
  // Double-check in service (defense in depth)
  if (!outlet || outlet.tenant_id !== tenantId) {
    throw new NotFoundException('Outlet not found');
  }
  
  return outlet;
}
```

**Defense Layer 3: Query-Level Filtering (Best)**
```typescript
// Use composite where clause
async findByIdAndTenant(id: string, tenantId: string) {
  return this.prisma.outlets.findUnique({
    where: {
      id_tenant_id: { // Composite unique key
        id,
        tenant_id: tenantId
      }
    }
  });
}
```

#### Test Cases:

**Test 3.1.1: PASS - TenantGuard blocks access**
```
Expected: 403 Forbidden or 404 Not Found (generic)
Error message: "Outlet not found" (doesn't reveal existence)
API call: Blocked by middleware before controller executes
```

**Test 3.1.2: Verify response doesn't leak tenant_b outlet data**
```
Response should NOT include:
- outlet.id (different tenant's outlet)
- outlet.name
- outlet.location
- outlet.transactions

Expected: {"error": "Outlet not found", "statusCode": 404}
```

---

### 3.2 ATTACK SCENARIO 2: Staff Escalating to Admin

```
Attacker: Staff User
Target: Promote own role to ADMIN
Method: Direct API call or payload manipulation
```

#### Attack Code:
```bash
STAFF_TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
STAFF_USER_ID="staff_user_uuid"

# Attempt 1: Update own role
curl -X PUT "http://localhost:3000/api/users/$STAFF_USER_ID" \
  -H "Authorization: Bearer $STAFF_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "role": "ADMIN"
  }'

# Attempt 2: Create another user and set role to ADMIN
curl -X POST "http://localhost:3000/api/users" \
  -H "Authorization: Bearer $STAFF_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "newadmin@test.com",
    "name": "New Admin",
    "role": "ADMIN"
  }'

# Attempt 3: Privilege escalation via SUPER_ADMIN
curl -X PUT "http://localhost:3000/api/users/$STAFF_USER_ID" \
  -H "Authorization: Bearer $STAFF_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "role": "SUPER_ADMIN"
  }'
```

#### Expected Defenses:

**Defense Layer 1: RoleGuard Middleware**
```typescript
// middleware/role.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';

export const ROLE_HIERARCHY = {
  'SUPER_ADMIN': 3,
  'ADMIN': 2,
  'STAFF': 1
};

@Injectable()
export class RoleGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const requiredRoles = Reflect.getMetadata('roles', context.getHandler());
    
    if (!requiredRoles) return true;
    
    const userRoleLevel = ROLE_HIERARCHY[user.role];
    const hasPermission = requiredRoles.some(
      role => userRoleLevel >= ROLE_HIERARCHY[role]
    );
    
    if (!hasPermission) {
      throw new ForbiddenException('Insufficient permissions');
    }
    
    return true;
  }
}

// Usage
@Controller('users')
export class UsersController {
  @Put(':userId')
  @UseGuards(AuthGuard, RoleGuard)
  @Roles('ADMIN', 'SUPER_ADMIN')
  async updateUser(
    @Param('userId') userId: string,
    @Body() updateUserDto: UpdateUserDto,
    @Req() request
  ) {
    const user = request.user;
    
    // Rule 1: Staff cannot update anyone
    if (user.role === 'STAFF') {
      throw new ForbiddenException('Only admins can update users');
    }
    
    // Rule 2: Admin cannot update to SUPER_ADMIN
    if (updateUserDto.role === 'SUPER_ADMIN' && user.role !== 'SUPER_ADMIN') {
      throw new ForbiddenException('Only super admin can assign super admin role');
    }
    
    // Rule 3: Admin cannot update other tenant's users
    const targetUser = await this.usersService.findById(userId);
    if (targetUser.tenant_id !== user.tenant_id) {
      throw new ForbiddenException('User not found');
    }
    
    return this.usersService.update(userId, updateUserDto);
  }
}
```

**Defense Layer 2: Immutable Role Field**
```typescript
// Prevent role changes in update endpoints
// Option A: Remove from DTO
export class UpdateUserDto {
  email?: string;
  name?: string;
  // role NOT included - can't be updated via this endpoint
}

// Option B: Separate endpoint for role changes
@Post('/:userId/assign-role')
@UseGuards(AuthGuard, RoleGuard)
@Roles('SUPER_ADMIN') // Only Super Admin
async assignRole(
  @Param('userId') userId: string,
  @Body() { role }: AssignRoleDto
) {
  // Extra strict validation
  if (role === 'SUPER_ADMIN') {
    throw new ForbiddenException('Cannot assign super admin via API');
  }
  
  // ... assign role
}
```

#### Test Cases:

**Test 3.2.1: PASS - Staff cannot escalate own role**
```
Request: PUT /users/staff_user_id with role: "ADMIN"
Expected: 403 Forbidden
Message: "Insufficient permissions"
Database: User role unchanged (still STAFF)
```

**Test 3.2.2: PASS - Staff cannot create admin user**
```
Request: POST /users with role: "ADMIN"
Expected: 403 Forbidden
Message: "Only admins can create users"
Database: No new user created
```

**Test 3.2.3: PASS - Admin cannot create super admin**
```
Request: POST /users with role: "SUPER_ADMIN"
User: Tenant Admin (not Super Admin)
Expected: 403 Forbidden
Message: "Only super admin can assign super admin role"
Database: No new user created, role enforced
```

---

### 3.3 ATTACK SCENARIO 3: Manipulating Tenant ID in Request Body

```
Attacker: Tenant A User
Target: Create resource in Tenant B
Method: Set tenantId in request payload
```

#### Attack Code:
```bash
TOKEN="tenant_a_token"

# Attempt: Create outlet for Tenant B
curl -X POST "http://localhost:3000/api/outlets" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "tenantId": "tenant_b_uuid",  # Attacker tries to set this
    "name": "Attacker Outlet",
    "address": "123 Evil St",
    "city": "Jakarta"
  }'
```

#### Expected Defense:

**Defense: Never Trust Request Body for Tenant ID**
```typescript
@Controller('outlets')
@UseGuards(AuthGuard)
export class OutletsController {
  @Post()
  async createOutlet(
    @Body() createOutletDto: CreateOutletDto,
    @Req() request
  ) {
    const user = request.user;
    
    // RULE: Never accept tenant_id from request body
    // Always use authenticated user's tenant_id
    
    // Remove any tenantId from DTO
    const { tenantId, ...safeData } = createOutletDto;
    
    // Force tenant_id from auth context
    const outlet = await this.outletsService.create({
      ...safeData,
      tenant_id: user.tenant_id  // From token, NOT body
    });
    
    return outlet;
  }
}
```

**Better: Use Middleware to Strip Sensitive Fields**
```typescript
@Injectable()
export class StripTenantIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Remove tenant-related fields from request body
    if (req.body) {
      delete req.body.tenant_id;
      delete req.body.tenantId;
      delete req.body.parentTenantId;
    }
    next();
  }
}
```

#### Test Cases:

**Test 3.3.1: PASS - Tenant ID from body ignored**
```
Request: POST /outlets with tenantId: "tenant_b_uuid"
Created outlet.tenant_id: should be "tenant_a_uuid" (from token)
Expected: Outlet created for Tenant A, NOT Tenant B
```

**Test 3.3.2: PASS - Verify cross-tenant creation prevented**
```
Query after creation:
SELECT tenant_id FROM outlets WHERE name = 'Attacker Outlet';
Expected: tenant_a_uuid (user's actual tenant)
NOT: tenant_b_uuid (attempted tenant)
```

---

### 3.4 ATTACK SCENARIO 4: Accessing Soft-Deleted Data

```
Attacker: Any user
Target: Access soft-deleted records (is_deleted = true)
Method: Direct query or API call
```

#### Attack Code:
```bash
TOKEN="user_token"
OUTLET_ID="deleted_outlet_uuid"

# Attempt: GET deleted outlet
curl -X GET "http://localhost:3000/api/outlets/$OUTLET_ID" \
  -H "Authorization: Bearer $TOKEN"

# Attempt: List all outlets including deleted
curl -X GET "http://localhost:3000/api/outlets?includeDeleted=true" \
  -H "Authorization: Bearer $TOKEN"
```

#### Expected Defenses:

**Defense Layer 1: Filter Soft-Deleted in All Queries**
```typescript
// outlets.service.ts
async findById(id: string, tenantId: string) {
  return this.prisma.outlets.findUnique({
    where: { id },
    include {
      // Include relation loading
    }
  });
  
  // FORGOT: Check is_deleted!
  // BUG: Returns soft-deleted outlets
}

// CORRECT:
async findById(id: string, tenantId: string) {
  const outlet = await this.prisma.outlets.findUnique({
    where: { id },
  });
  
  // Check both tenant AND soft-delete
  if (!outlet || outlet.tenant_id !== tenantId || outlet.is_deleted) {
    throw new NotFoundException('Outlet not found');
  }
  
  return outlet;
}

// BEST: Use Prisma middleware
this.prisma.$use(async (params, next) => {
  if (
    params.model === 'outlets' &&
    params.action === 'findUnique'
  ) {
    params.where = {
      ...params.where,
      is_deleted: false  // Always filter
    };
  }
  return next(params);
});
```

**Defense Layer 2: Query Scope**
```typescript
// Create helper for scoped queries
async findActivById(id: string, tenantId: string) {
  return this.prisma.outlets.findUnique({
    where: {
      id_tenant_id_is_deleted: {
        id,
        tenant_id: tenantId,
        is_deleted: false
      }
    }
  });
}
```

#### Test Cases:

**Test 3.4.1: PASS - Cannot access soft-deleted outlet**
```
Setup:
- Create outlet A
- Soft-delete outlet A (is_deleted = true)

Request: GET /outlets/{outlet_a_id}
Expected: 404 Not Found
Message: "Outlet not found"
Data leaked: None (can't determine if deleted or never existed)
```

**Test 3.4.2: PASS - Soft-deleted not in list**
```
Setup:
- Create outlets: A (active), B (active), C (deleted)

Request: GET /outlets
Expected: Returns [A, B]
Does NOT include: C
```

---

### 3.5 ATTACK SCENARIO 5: Direct API Call Bypassing UI

```
Attacker: Any user with token
Target: Call API endpoints directly
Method: Curl, Postman, or custom client
```

#### Attack Code:
```bash
TOKEN="staff_token"

# Scenario 1: Staff creates transaction for unassigned outlet
curl -X POST "http://localhost:3000/api/transactions" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "outletId": "outlet_not_assigned_to_staff",
    "amount": 100000,
    "paymentMethod": "cash"
  }'

# Scenario 2: Staff exports sensitive report
curl -X GET "http://localhost:3000/api/analytics/revenue-export?format=csv" \
  -H "Authorization: Bearer $TOKEN"

# Scenario 3: Staff tries to modify transaction price
curl -X PUT "http://localhost:3000/api/transactions/trans123" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 1000  # Changed from 100000
  }'
```

#### Expected Defenses:

**Defense: Endpoint-Level Authorization**
```typescript
// transactions.controller.ts
@Controller('transactions')
@UseGuards(AuthGuard, TenantGuard)
export class TransactionsController {
  
  @Post()
  @UseGuards(RoleGuard)
  @Roles('STAFF', 'ADMIN', 'SUPER_ADMIN')
  async createTransaction(
    @Body() createTransactionDto: CreateTransactionDto,
    @Req() request
  ) {
    const user = request.user;
    
    // Rule 1: Staff can only create if assigned to outlet
    if (user.role === 'STAFF') {
      const isAssigned = await this.staffOutletService.isAssignedToOutlet(
        user.id,
        createTransactionDto.outletId
      );
      
      if (!isAssigned) {
        throw new ForbiddenException('Not assigned to this outlet');
      }
    }
    
    // Rule 2: Verify outlet belongs to user's tenant
    const outlet = await this.outletsService.findById(
      createTransactionDto.outletId
    );
    
    if (outlet.tenant_id !== user.tenant_id) {
      throw new ForbiddenException('Outlet not found');
    }
    
    return this.transactionsService.create(createTransactionDto, user);
  }
  
  // Staff should NOT be able to call this
  @Put(':transactionId')
  @UseGuards(RoleGuard)
  @Roles('ADMIN', 'SUPER_ADMIN') // NOT STAFF
  async updateTransaction(
    @Param('transactionId') transactionId: string,
    @Body() updateTransactionDto: UpdateTransactionDto
  ) {
    // Transactions should be immutable once created
    // Only admins can void/adjust
    return this.transactionsService.update(
      transactionId,
      updateTransactionDto
    );
  }
}
```

#### Test Cases:

**Test 3.5.1: PASS - Staff cannot create transaction for unassigned outlet**
```
Setup:
- Staff A assigned to Outlet A only
- Outlet B exists but Staff A not assigned

Request: POST /transactions with outletId: Outlet B
Expected: 403 Forbidden
Message: "Not assigned to this outlet"
Database: No transaction created
```

**Test 3.5.2: PASS - Staff cannot access export endpoint**
```
Request: GET /analytics/revenue-export
User: Staff
Expected: 403 Forbidden
Message: "Admin access required"
Data leaked: None
```

**Test 3.5.3: PASS - Staff cannot update transaction**
```
Request: PUT /transactions/trans123 with new amount
User: Staff
Expected: 403 Forbidden
Message: "Only admins can modify transactions"
Database: Transaction unchanged
```

---

## SECTION 4: IMPLEMENTATION CHECKLIST

### 4.1 Guards & Middleware

- [ ] **AuthGuard** - Validates JWT token
  - Extracts user info from token
  - Adds to request.user
  - Blocks if no token or invalid

- [ ] **TenantGuard** - Enforces tenant isolation
  - Verifies resource tenant_id matches user.tenant_id
  - Returns 404 for cross-tenant access (no info leak)
  - Applied to all multi-tenant endpoints

- [ ] **RoleGuard** - Enforces role-based access
  - Uses role hierarchy
  - Checks @Roles() decorator
  - Returns 403 for insufficient permissions

- [ ] **SoftDeleteGuard** - Filters soft-deleted records
  - Automatically excludes is_deleted = true
  - Applied via Prisma middleware
  - Transparent to business logic

### 4.2 Data Validation

- [ ] **DTO Validation** - Sanitize all inputs
  - Remove sensitive fields from body (tenant_id)
  - Use class-validator for format checking
  - Sanitize strings (XSS prevention)

- [ ] **Business Logic Validation** - Enforce rules
  - Check resource ownership before operations
  - Verify relationships (outlet belongs to tenant)
  - Validate constraints (don't delete last admin)

### 4.3 Audit & Logging

- [ ] **Audit Logs** - Track all sensitive actions
  - Log CREATE, UPDATE, DELETE operations
  - Include user_id, tenant_id, IP, timestamp
  - Store old_values and new_values (for disputes)

- [ ] **Security Logs** - Track violations
  - Log failed permission checks
  - Log suspicious patterns (multiple 403s)
  - Alert on cross-tenant access attempts

---

## SECTION 5: ATTACK SUMMARY TABLE

| Attack | Method | Defense | Status |
|--------|--------|---------|--------|
| Cross-tenant read | Guess ID | TenantGuard + ORM filter | [ ] PASS |
| Privilege escalation | API call | RoleGuard + immutable role | [ ] PASS |
| Tenant ID manipulation | Body param | Strip sensitive fields | [ ] PASS |
| Soft-delete bypass | Query string | Prisma middleware filter | [ ] PASS |
| Direct API abuse | Curl | Endpoint authorization | [ ] PASS |
| Session hijacking | Token theft | IP + device fingerprint | [ ] PASS |
| CSRF attack | Form hijack | CSRF token validation | [ ] PASS |

---

## SECTION 6: TESTING COMMANDS

```bash
# Test 1: Cross-tenant access
TOKEN_A="$(curl -X POST http://localhost:3000/api/auth/login \
  -d '{"email":"admin_a@test.com","password":"pass"}' \
  -H "Content-Type: application/json" \
  | jq -r '.token')"

curl -X GET "http://localhost:3000/api/outlets/outlet_from_tenant_b" \
  -H "Authorization: Bearer $TOKEN_A"
# Expected: 404 Not Found

# Test 2: Privilege escalation
TOKEN_STAFF="$(curl -X POST http://localhost:3000/api/auth/login \
  -d '{"email":"staff@test.com","password":"pass"}' \
  -H "Content-Type: application/json" \
  | jq -r '.token')"

curl -X POST "http://localhost:3000/api/users" \
  -H "Authorization: Bearer $TOKEN_STAFF" \
  -H "Content-Type: application/json" \
  -d '{"email":"newadmin@test.com","role":"ADMIN"}'
# Expected: 403 Forbidden

# Test 3: Soft-delete access
curl -X GET "http://localhost:3000/api/outlets/deleted_outlet_id" \
  -H "Authorization: Bearer $TOKEN_A"
# Expected: 404 Not Found
```

---

**Audit Date:** [To be filled]  
**Status:** Ready for Execution  
**Auditor:** Security Architect & Penetration Tester
